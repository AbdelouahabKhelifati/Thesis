<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="eXtremeDB Fundamental Concepts">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>eXtremeDB Indexes</title>
        <link href="../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <script src="../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <h1><i>e</i>X<i>treme</i>DB Indexes</h1>
            <blockquote>
                <p><i>e</i>X<i>treme</i>DB supports hash indexes, and tree indexes of the following types: <code>tree</code> (b-tree), <code>patricia</code> (Patricia Trie), <code>rtree</code> (R-tree spatial), <code>kdtree</code> (kd-tree multi-dimensional), <code>trigram</code> (text substring) and <code>user-defined</code> (“custom”). <code>Hash</code> and <code>unique tree</code> indexes can also be used to uniquely identify objects in the database.  Also, specialized hash indexes of type <code>oid</code> and <code><a name="kanchor837"></a>autoid</code> are provided as unique object identifiers. Unlike oids and autoids, however, <code>hash</code> and <code>tree</code> index values are only required to be unique within a class; the <code>nonunique</code> declaration can be used to allow duplicate values for <code>hash</code> or <code>tree</code> indexes.  </p>
                <p>(See the <a href="../Users_Guides/Core/Indexes_Cursors.htm">Indexes and Cursors</a> page for detailed descriptions and implementation details for each of the index types described below.)</p>
                <h2>Tree Index </h2>
                <p>An <i>e</i>X<i>treme</i>DB <code>tree</code> index is a tree-like structure in the application’s memory that contains a collection of keys. A key can be simple (based on a single field) or compound (containing more than one field).  The tree-index stores the keys in sorted order. In order to support sorting, the tree-index must have a compare function.  Regardless of the key type (simple or compound), the compare function must be able to compare two keys and determine whether the first key is less than (compare returns -1), equal to (0) or greater than (1) the second key. The tree-index algorithm sorts the keys based on this comparison.</p>
                <blockquote>
                    <h3>Search Methods</h3>
                    <p>Search APIs are generated by the <a href="../Getting_Started/Package_Contents/mcocomp.htm"><code>mcocomp</code></a> schema compiler to locate desired objects or groups of objects by unique identifier or by index.  While exact match lookups by unique identifier ( <code>unique tree</code> or <code>hash</code> index, <code>oid</code> and <code>autoid</code> ) using the generated  <code>_find()</code> functions are extremely efficient for locating individual objects, the rich set of specialized indexes mentioned above employ <i style="font-weight: bold;">cursors</i> to navigate a group of objects as an ordered or unordered result set.</p>
                    <h3>Find</h3>
                    <p>By definition, an exact match lookup on a unique index returns exactly one result or zero if no match is found. So for C and C++ applications, the <a href="../Getting_Started/Package_Contents/mcocomp.htm">mcocomp</a> schema compiler generates a <code>_find()</code> function for each unique index. Java and C# applications use the <i>Cursor.Find()</i> method.</p>
                    <h3>Search</h3>
                    <p>A <i style="font-weight: bold;">cursor</i> is essentially an iterator over the collection of objects in a result set.  For each index declared for a class in the schema definition, the <a href="../Programming/C/DDL.htm">DDL</a> compiler generates functions to instantiate a cursor, position it based on some value(s), and obtain a handle to the database object from the cursor.  <code>List</code> and <code>nonunique</code> hash-based cursors allow navigation in sequential order (first to last, or last to first), though the order of the sequence is not defined; it is simply a mechanism to iterate over the unordered list of objects of a class.  </p>
                    <p>For C or C++ applications, mcocomp generates a <code>_search()</code> function for each <code>nonunique</code> index in the schema. Java and C# applications use the <i>Cursor.Search()</i> method. The search function is used whenever it is necessary to establish:</p>
                    <ul>
                        <li value="1">a starting position in a sorted list with a known starting value and optionally retrieve subsequent results in ascending or descending sorted order.</li>
                        <li value="2">a starting position in a sorted list when only part of the starting value is known, find the closest match, and optionally retrieve subsequent results in ascending or descending sorted order.</li>
                        <li value="3">a starting position as above, iterate over the sorted list in ascending or descending sorted order until a lower/upper bound is reached, using the _compare() method to determine when the range limit is reached.</li>
                        <li value="4">a starting position with a known starting value, iterate over the list to retrieve each duplicate, using the <code>_compare()</code> method to determine when the last duplicate was retrieved.</li>
                    </ul>
                    <h3>Pattern Search</h3>
                    <p><i>e</i>X<i>treme</i>DB also supports "wild card" pattern matching ability. This is the capability to search tree index entries matching patterns specified with wild card characters for single character and multiple character matches. By default, the question mark “?” will match any single character in the specified position within the pattern, and the asterisk “*” will match any combination of characters (including no characters) in that position. If a match on the characters “?” or “*” is desired, the wild card characters themselves can be modified by specifying different characters in the pattern search policy (see below).</p>
                    <p>For example, “G*e*” would return “Graves” and “Gorine”, while “Gr?ve*” would match “Graves”, “Grove”, “Grover” and so on... In this example, ‘*’ matches zero, one, or more characters, while ‘?’ matches exactly one character. Further, the pattern “G*E*” would match all uppercase entries like “GRAVES”, “GORINE”. However, because the standard compare functions used to match index values with search keys use case-sensitive compare functions, the case specified in the search pattern will affect the search results.</p>
                    <h3>Key-Value-Inclusive Indexes</h3>
                    <p><i>e</i>X<i>treme</i>DB allows a “key-value-inclusive” or “cache-oblivious” implementation for in-memory (<code>transient</code>) database classes. This expedites access for certain access patterns. In particular experiments with very large B-Tree indexes show significant performance improvements. Also, the trigram index (described <a href="#Trigram">below</a>) is implemented via the “key-value-inclusive” tree because it is much more efficient to keep 3 extra bytes (trigrams) on the index page than to simply store an 8-byte object address which requires further access steps.</p>
                    <h3>Covering Indexes</h3>
                    <p><a name="kanchor838"></a>If all the fields requested in an index search are available in the index tree node, then the runtime doesn't have to look up the object covered by the index again. This can significantly increase the performance of searches. Since all the requested fields are available within the index, the index is called a “covering index”. In addition, a “covering” index can be also declared inclusive to leverage CPU cache usage.</p>
                </blockquote>
                <h2>Patricia Trie Index</h2>
                <p>The <i>e</i>X<i>treme</i>DB <code>Patricia</code> index uses a Patricia <code>trie</code> structure that is based on a radix tree using a radix of two. The term "trie" is derived from the word "retrieval". Patricia stands for "Practical Algorithm to Retrieve Information Coded as Alphanumeric”. This algorithm is optimized to perform quick IP address prefix matching for IP subnet, network or routing table lookups.  So Patricia Trie indexes are particularly useful for network and telecommunications applications.</p>
                <p>A Patricia index can be declared over scalar and boolean data types as well as arrays and vectors of those types.  In fact, the boolean data type was introduced to facilitate Patricia index implementation where bit arrays are used to store IP addresses.</p>
                <h2>RTree Index</h2>
                <p><code>RTree</code> indexes are commonly used to speed spatial searches, for example, find the rectangle that contains this point, find all rectangles that overlap this rectangle, or find all rectangles in the neighborhood of this point.</p>
                <p>All manner of shapes can be stored and searched with the <code>rtree</code> index.  For example, a point is represented as a rectangle with width and height = 1 and a line that has starting and ending coordinates of 15, 844 and 0, 3647 is stored as rectangle with its upper left corner at 15, 844 and its lower right corner at 0, 3647.</p>
                <p>To determine if two lines intersect, or if a point is within a given area (described by a circle, rectangle, etc.), an <code>rtree</code> search is performed to find all overlapping rectangles.</p>
                <h2>Kd-Tree Index</h2>
                <p>A <code>kdtree</code> is a data structure for organizing points in a k-dimensional space. <code>kdtrees</code> are a useful data structure for several applications, such as lookups that involve a multidimensional search key.  The <code>kdtree</code> is a binary tree in which every node is a k-dimensional point. Every non-leaf node generates a splitting hyperplane that divides the space into two subspaces. Points left of the hyperplane represent the left sub-tree of that node and the points right of the hyperplane represent the right sub-tree. The hyperplane direction is chosen in the following way: every node split to sub-trees is associated with one of the k-dimensions, such that the hyperplane is perpendicular to that dimension vector.</p>
                <p>The <code>kdtree</code> uses a Query-By-Example approach to locate objects that match a given search condition. The application creates pattern object(s) and assigns values to the fields that are included in the search criteria. The <code>kdtree</code> supports simple exact matches as well as range lookups.  In the latter case, two pattern objects will be specified: one for the lower and one for the upper bounds of the search condition.  If a field value is defined only for one boundary, it is considered an open interval that corresponds to a greater-than-or-equal-to or less-than-or-equal-to search condition.</p>
                <h2><a name="Trigram"></a>Trigram Index</h2>
                <p>Trigram search is a method of searching for text when the exact syntax or spelling of the target object is not precisely known. It finds objects which match the maximum number of three-character strings in the entered search terms, i.e. near matches. A classical B-Tree index allows exact match queries (eg. x='qqq'), range queries (eg. “x &gt;= 10 and x &lt;= 100”) and prefix match queries (eg. “x &gt;= 'abc’).</p>
                <p>However, for more complex regular expressions like “%xyz%” a B-Tree index would require a sequential search, which is significantly slower. In this case a trigram index can be ideal.</p>
                <p>The idea of <code>trigram</code> index is rather simple. Assume that we have a string key 'qwerty'. The string is split into trigrams: sequences of three subsequent characters: "qwe", "wer", "ert", "rty". These trigrams are stored in a normal B-Tree index. Now consider a query looking for the substring "wert". The query condition is also split into trigrams: "wer" and "ert". The search then is looking for these trigrams in the index. The result of the lookup is two lists of objects -- so called inverse lists. The next step is to join these lists: i.e. to find objects which are present in both lists.</p>
                <h2>OID</h2>
                <p>An <i>e</i>X<i>treme</i>DB <code>oid</code> is a unique object identifier which is implemented internally as a unique hash index. Generally, an <code>oid</code> is a user-defined structure which has fixed-length fields corresponding to identifying characteristics of a principle database class. C and C++ applications can use <code>oids</code> to quickly retrieve the object it identifies.</p>
                <h2>Autoid</h2>
                <p>An <code>autoid</code> is similar to <code>oid</code> in that it is a unique object identifier implemented internally as a unique hash index. However it differs in that its value is determined by the <i>e</i>X<i>treme</i>DB runtime, and the value is unique for the class, not the entire database. Autoids are 8-byte signed integer values  which means that the value can be incremented every microsecond for nearly 300,000 years without overflowing.</p>
                <h2>LIST</h2>
                <p>A sequential navigation method is available for unordered lists of objects by specifying a <code>list</code> index. This allows applications to iterate over the objects of a class without regard to any particular order.</p>
            </blockquote>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>