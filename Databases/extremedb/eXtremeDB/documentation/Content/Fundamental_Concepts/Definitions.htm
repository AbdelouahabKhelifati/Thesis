<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="eXtremeDB Fundamental Concepts">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>eXtremeDB Definitions</title>
        <link href="../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <script src="../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <h1><i>e</i>X<i>treme</i>DB Definitions</h1>
            <blockquote>
                <p>A <b style="font-style: italic;">database</b> is a collection of related data organized for efficient storage and retrieval.  Beyond this, any attempt to more specifically describe a database inevitably involves individual features of one or more specific database implementations.  The following definitions describe the <i>e</i>X<i>treme</i>DB implementation.</p>
                <p>Each database has groupings of elements. We call the definition of a group of elements a <i style="font-weight: bold;">class</i>; other terms commonly used are “table” and “record definition”. Instances of the class stored in the database are called <i style="font-weight: bold;">objects</i>, analogous to records and rows. As will be explained in detail in this documentation, an <i>e</i>X<i>treme</i>DB class is much more than a relational database table or other database record definitions. Our purpose here is not to equate <i>e</i>X<i>treme</i>DB elements to those of relational or other databases, but rather to outline the hierarchy of elements and contrast them with elements of familiar database architectures.</p>
                <p>The term <i>class</i> is used in most object-oriented languages, such as C++,  Java or C#. The class defines the properties of the object and the methods used to control the object’s behavior. This definition is correct for <i>e</i>X<i>treme</i>DB classes as well - <i>a database class defines object fields and <b>access methods</b></i>.</p>
                <p>Elements are called <i style="font-weight: bold;">fields</i> in <i>e</i>X<i>treme</i>DB. Other common terms are “attribute” and “column”. Fields have a type property. The <i style="font-weight: bold;">type</i> determines whether the element holds <code>character</code>, <code>integer</code>, <code>real</code>, or <code>binary</code> data. See the following link for a complete list of <a href="../Programming/C/DDL/Base_Data_Types.htm"><i>e</i>X<i>treme</i>DB data types</a>. <i>e</i>X<i>treme</i>DB also supports arbitrarily large fields through <b style="font-style: italic;">blob</b> and <b style="font-style: italic;">vector</b> types, and complex fields through the <b style="font-style: italic;">structure</b> type.</p>
                <p>A <b style="font-style: italic;">blob</b> is an arbitrarily large stream of bytes; untyped “opaque” data. From the <i>e</i>X<i>treme</i>DB perspective it has no structure. Classic examples are audio streams (.wav files), video streams (.mpg files), graphic files (.jpg files), and streams of text larger than 64 K.</p>
                <p>A <i style="font-weight: bold;">vector</i> is an arbitrarily large stream of typed data (vector elements), such as a stream of 2-byte integers, strings or structures. In <i>e</i>X<i>treme</i>DB you can define vectors of any type except blob. Vectors are useful when describing real-world complex objects such as tree-like data structures.</p>
                <p>In addition to grouping fields into a class, <i>e</i>X<i>treme</i>DB allows a sub-grouping called a <b style="font-style: italic;">structure</b>. A structure declaration names a type and specifies elements of the structure that can have different types. Structures and simple types are building blocks to construct class definitions. Structures can be used as elements of other structures (i.e. nested structures). Like other element types, you can have a vector of structures.</p>
                <p>Generally speaking, fields are either simple or complex. Simple fields are atomic types such as <code>char</code>, <code>integer</code>, <code>string</code>, and so on. Complex fields can be vectors of simple types, structures (which may in turn contain structures and vectors), vectors of structures, and blobs.</p>
                <p>
                    <img src="../Resources/Images/note.png" />Note:	<i>e</i>X<i>treme</i>DB structures, in contrast to C or C++ structures, cannot be instantiated separately; they exist only as a part of an object of some class.</p>
                <p>In the relational or hierarchical data models, records are constructed from basic data type fields. The collection of built-in data types and built-in operations were motivated by the needs of business data processing applications. However, in many engineering or scientific applications this collection of types is not adequate. For example, in a scientific application, a requirement could be to describe a time series and store and access it with appropriate operations. Another common example is tree-like structures that are widely used in engineering applications such as routing tables or “electronic program guide” implementations for set-top boxes. Historically, complex data types and operations on them have been simulated using basic data types and operations provided by the DBMS with substantial inefficiency and added complexity. Complex objects are represented by multiple basic tables or records and defining relationships between them.</p>
                <p>When working with traditional relational or hierarchical data models, application developers represent their objects as records or rows in tables. In many cases objects cannot be represented with one record, and developers are forced to store parts of an object in different tables and define relationships between the object’s parts (in DBMS jargon, these steps are known as normalization and object-relational mapping). However, objects are entities, all parts of which are working as a whole. Consequently, developers usually introduce their own APIs to store and retrieve objects. These APIs shield the inner complexity within objects from the application, but at the same time, introduce extra layers of application code that must be written, debugged and executed.</p>
                <p>It is possible to use <i>e</i>X<i>treme</i>DB in the same manner as described in the previous paragraph. Alternatively, because <i>e</i>X<i>treme</i>DB employs an object-oriented approach to database development, objects can have a more complex nature than merely a one-dimensional collection of fields. <i>e</i>X<i>treme</i>DB fields can have complex structure themselves, for example, a field may be a dynamic array of structures; structures in this vector can also hold other structures or arrays. <i>e</i>X<i>treme</i>DB class access methods allow for simple but highly efficient access to objects without extra layers of navigation code.</p>
                <p><i>e</i>X<i>treme</i>DB extends C and C++ data types with <span class="Param">ACID</span>-compliant data access methods (see <a href="http://en.wikipedia.org/wiki/ACID" title="Definition of ACID" alt="Definition of ACID">http://en.wikipedia.org/wiki/ACID</a>) to provide developers with a simple, clean, efficient, and easily adjustable approach to database development.  Similarly, Java and .Net developers can add <i>e</i>X<i>treme</i>DB persistence to Java and C# classes by simple annotation.</p>
                <p><i>e</i>X<i>treme</i>DB, like other databases, provides indexes to provide access to objects based on key values. An index definition consists of any combination of fields, structure elements or vector elements from a given class. Indexes can be of various types, the most common of which are either hash or tree (BTree). Tree indexes can have a mix of ascending and descending components and, in addition to exact-match searches, can be used for sorting and range-based retrieval. Hash indexes are used for fast storage and retrieval but without sorting or range-based access.  Both tree and hash indexes can be declared unique or nonunique to exclude or allow duplicate values.</p>
                <p><i>e</i>X<i>treme</i>DB also provides a number of specialized <i style="font-weight: bold;">indexes</i> that optimize access to records and groups of records for particular types of applications, such as the following:</p>
                <ul>
                    <li value="1"><i style="font-weight: bold;">Patricia Trie</i>: Particularly useful for network and telecommunications applications, these are often used to quickly perform IP address prefix matching for IP subnet, network or routing table lookups.</li>
                    <li value="2"><i style="font-weight: bold;">R-Tree</i>: These indexes are commonly used to index latitude/longitude and speed spatial searches; for example to find the rectangle that bounds a given point, or all rectangles that overlap a specified rectangle.</li>
                    <li value="3"><i style="font-weight: bold;">Kd-Tree</i>: Using a data structure for organizing points in a k-dimensional space, kd-trees speed lookups that involve a multidimensional search key, and are most commonly used in query-by-form and query-by-example cases.</li>
                </ul>
                <p>Indexes can also be used to establish relationships between objects of different classes (in addition to the use of <i style="font-weight: bold;">oid</i> and <i style="font-weight: bold;"><a name="kanchor214"></a>autoid</i>, which are discussed later) as in relational databases which employ the concept of primary and foreign keys. By definition, a primary key is a column or combination of columns that uniquely identify a row in a table. Correspondingly, a foreign key is a column or combination of columns whose values match the primary key of some other table. In <i>e</i>X<i>treme</i>DB a primary key is normally implemented as a unique index on a field or combination of fields within a class, while a foreign key is normally implemented as a non-unique index (allowing duplicates), whose elements (fields) correspond to a primary key of some other class in the database.</p>
                <p>In addition to indexes, classes in <i>e</i>X<i>treme</i>DB can be declared to have an object identifier, or <i style="font-weight: bold;">oid</i>.  These are different from primary keys in that the composition of an oid is the same for every class in the database.  A class can also have a reference to object(s) of another class, called a reference, by declaring a field of data type ref. A <i style="font-weight: bold;">ref</i> is a reference in one object to the oid of another object.</p>
                <p>At first, it may seem strange that oids must have an identical composition for every class in the database. In actuality, this models the real world in many application environments. For example, a system that receives data from some automated source will receive objects that have an identifier already supplied by the source. An example could be a network of sensors for which the oid of every sensor class is sensor-type + sensor-id + measurement-timestamp. Note that not every class is required to have an oid.</p>
                <p>Oids and refs are often better alternatives to indexes for establishing inter-object relationships. An object can have a vector of references, as one means to implement a one-to-many relationship across classes. Indexes can and should be used to implement fast random access to objects by one or more key fields, for sorted access, and for range retrieval.</p>
                <p><i>e</i>X<i>treme</i>DB also provides the <i style="font-weight: bold;">autoid</i> type. An autoid is similar to what other DBMS variously call sequence, serial, auto-increment, etc. Autoid is similar to oid, except that the structure and value of autoid fields are determined by the <i>e</i>X<i>treme</i>DB<a name="kanchor215"></a> runtime system. An application uses the <code>autoid_t</code> typedef in C and C++ applications to declare program variables used to store autoid values and the <code>AutoID</code> attribute in Java and C# applications, to create a reference in one object to the autoid value of another object. Autoid and <code>autoid_t</code> can be used as an alternative to oid and ref  respectively, whenever a natural oid does not exist, is deemed too cumbersome, or an automatically incrementing identifier is desired.</p>
                <p>To express the content and organization of a database for C and C++ projects, the database designer uses some or all of these components in a data definition language (<a href="../Programming/C/DDL.htm">DDL</a>) to create a database schema. The schema is a textual description of the data model. It is processed by the <i>e</i>X<i>treme</i>DB <a href="../Getting_Started/Package_Contents/mcocomp.htm">schema compiler</a>, which ensures that the schema is syntactically correct and then generates the application programming interface (<i style="font-weight: bold;">API</i>) header (.h) and implementation (.c) files.  When the application is compiled the database dictionary for the database is produced from the implementation file. The database dictionary is simply a binary form of the schema that the database runtime can use more efficiently.</p>
                <p>In contrast, in  Java and C# projects, the “schema” consists of native language classes that are marked with the <code>Persistent</code> attribute and the database dictionary is generated at run-time when the attributes of database objects are obtained through the reflection mechanism N.B.: “Persistent” in this context only means that objects are stored in an <i>e</i>X<i>treme</i>DB database, which might be in-memory or on a file system.  The <code>Persistent</code> annotation serves only to distinguish these classes from ordinary transient Java or C# classes whose objects are not stored in the database.</p>
                <p>
                    <img src="../Resources/Images/note.png" />Note:	It is possible also to build <i>e</i>X<i>treme</i>DB application architectures that combine Java or C# class implementations with modules or libraries that interface with an <i>e</i>X<i>treme</i>DB database through the C or C++ API. In this case the schema file necessary for the C or C++ modules must be generated from the persistent Java or C# classes by calling the <i>Database</i> method <code>GenerateMcoFile()</code> to generate an <i>e</i>X<i>treme</i>DB data definition language (<a href="../Programming/C/DDL.htm">DDL</a>) schema file that can then be processed by the schema compiler <code><a href="../Getting_Started/Package_Contents/mcocomp.htm">mcocomp</a></code>.</p>
                <p>A C or C++ <i>e</i>X<i>treme</i>DB application uses the API generated by the schema compiler to store, read, and manipulate objects in an <i>e</i>X<i>treme</i>DB database. This is in contrast to many database products that offer a static proprietary navigational API, or a static standard API (like SQL). The <i>e</i>X<i>treme</i>DB API is always tailored to the application, so the integration with the application happens naturally. It is very much like the API would be if a developer wrote a database interface specifically for the needs of the application. And that is what is intended. In the world of embedded systems, the most common alternative for any commercial database product is the “homegrown” database. <i>e</i>X<i>treme</i>DB offers all the advantages of “homegrown”, i.e. optimal performance and small footprint, without excess baggage, and an API that fits seamlessly with the rest of the application while also delivering the advantages of an off-the-shelf database solution: lower development cost, lower maintenance cost, and shorter time to market.</p>
                <p><a href="javascript:void(0);" class="MCHelpControl MCHelpControl-Related relatedTopics" data-mc-topics="Database Models|Database_Models.htm||eXtremeDB Indexes|Indexes.htm||Horizontal Database Partitioning|Horizontal_Database_Partitioning.htm"><span class="MCHelpControl-RelatedHotSpot_"><img class="MCHelpControl_Image_Icon" src="../../Skins/Default/Stylesheets/Images/transparent.gif" height="16" width="16" alt="Related Topics Link Icon" />Related Topics</span></a>
                </p>
            </blockquote>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>