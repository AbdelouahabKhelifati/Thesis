<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="[%=System.LinkedTitle%]|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>eXtremeDB Transaction Logging Applications</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <h1><i>e</i>X<i>treme</i>DB Transaction Logging Applications</h1>
            <blockquote>
                <p>C/C++ applications using <i>e</i>X<i>treme</i>DB<i> Transaction Logging</i> must first initialize the TL subsystem by calling <code><a href="../../Programming/C/TL_Functions/init.htm">mco_translog_init()</a></code> before the database is opened via <code><a href="../../Programming/C/Core_Functions/Static/Database_Control/open_dev.htm">mco_db_open_dev()</a></code>.  In java and C# applications, the <i>Database</i> constructor initializes the TL subsystem when the database is instantiated.</p>
                <p>After transaction logging is initialized, C/C++ applications connect to the database as in any <i>e</i>X<i>treme</i>DB application by calling <code><a href="../../Programming/C/Core_Functions/Static/Database_Control/connect.htm">mco_db_connect()</a></code> or  <code style="color: #000000;"><a href="../../Programming/C/Core_Functions/Static/Database_Control/connect_ctx.htm">mco_db_connect_ctx()</a></code>, Java and C# applications simply instantiate a <i>Connection</i>.</p>
                <p>At this point a save-point should be created by calling the <code><a href="../../Programming/C/Core_Functions/Static/Database_Control/save.htm">mco_db_save()</a></code> C/C++ function, (in Java and C# applications the <code>Connection.SaveSnapshot()</code> method) before logging is started.  This establishes the starting point for all logged transactions to follow.</p>
                <p>Java and C# applications can recover a database from a saved image and log file as illustrated in the following code fragments extracted from <a href="../../Programming/Csharp/SDK_Samples/TL/TLogBasicCS.htm">\samples\csharp\tl\TLogBasicCS</a>:</p>
                <div class="code-block"><pre>    &#160;
        const string TL_LOG_FILE = "tlogbasic_tl_cs.log";
        const String DBIMAGE_FILE = "tlogbasicdb_cs.bak";
        Database.Parameters parameters = new Database.Parameters();
        &#160;
        if (File.Exists(DBIMAGE_FILE))
        {
            // set database image filename
            parameters.DatabaseSnapshotFilePath = DBIMAGE_FILE;
            loadedSnapshot = true;
        }
    &#160;
        // create Database object
        db = new Database(new ExtremedbWrapper(),
        Database.Mode.TransactionLoggingSupport);
    &#160;
        db.Open("tlogbasicdb", parameters, devs); // open database.
        if (loadedSnapshot)
        {
            // Apply stored log file to databas
            LogReader logr = new LogReader(con, TL_LOG_FILE);
            LogReader.LogInfo linfo = new LogReader.LogInfo();
            logr.Apply();
        }
        con.SaveSnapshot(DBIMAGE_FILE);
    }
    &#160;</pre>
                </div>
                <p>In C/C++ applications, the following additional log file operations can be performed on log files:</p>
                <blockquote>
                    <p> A log file may be marked with a label at any point by calling the function <code><a href="../../Programming/C/TL_Functions/label.htm">mco_translog_label()</a></code>, which provides the ability to restore the log up to that label.  Also, a log file may be truncated and restarted by the function <code><a href="../../Programming/C/TL_Functions/truncate.htm">mco_translog_truncate()</a></code>.  Note that it is wise to create a database save-point prior to truncating the log file, otherwise the transactions will be unrecoverable.  Further, it is wise to create the save-point to a different (new) file than the previous save-point.  If you overwrite the existing save-point and the system crashes prior to completing the new save-point, there can be no recovery.  So, for safety, the sequence should be:</p>
                    <blockquote>
                        <p>1.	create a new save-point</p>
                        <p>2.	truncate the log file</p>
                        <p>3.	delete the previous save-point file</p>
                    </blockquote>
                    <p>&#160;</p>
                    <p>If transaction logging is not synchronous (see <code>MCO_TRANSLOG_SYNC_INSTANTLY</code> below), a log file may be flushed to disk at any time by calling the function <code><a href="../../Programming/C/TL_Functions/flush.htm">mco_translog_flush()</a></code> to  force immediate flushing of the file system buffers related to a log file.  However, automatic flushing strategies (activated by elapsed time or by transaction count) can be specified when starting transaction logging (see the function <code><a href="../../Programming/C/TL_Functions/start.htm">mco_translog_start()</a></code>) that eliminate the need for an application to explicitly flush the log file.</p>
                    <p>&#160;</p>
                    <p>Information about the current log file (the current log size, the count of stored transactions and other information) may be gathered during the logging process by calling the function <code><a href="../../Programming/C/TL_Functions/get_info.htm">mco_translog_get_info()</a></code>.  Or, information can be obtained about a specific log file on persistent media (the ability to apply or append to this log, the log file size and other information) by calling <code><a href="../../Programming/C/TL_Functions/query_info.htm">mco_translog_query_info()</a></code>.</p>
                </blockquote>
                <blockquote>
                    <p>A database can be restored from compatible log files by calling the function <code><a href="../../Programming/C/TL_Functions/apply.htm">mco_translog_apply()</a></code>.  Note that a proper save-point, i.e. a previously stored database image, should be restored via <code><a href="../../Programming/C/Core_Functions/Static/Database_Control/load.htm">mco_db_load()</a></code>, or a new empty database should be opened before applying a log file(s).  Then, <code><a href="../../Programming/C/TL_Functions/apply.htm">mco_translog_apply()</a></code><a name="kanchor299"></a> is called to replay any transactions committed after that database image was saved.  Before applying the log(s) to the database, the TL runtime first checks for dictionary compatibility, runtime modes and data size compatibility, and finally verifies that the current value of the database transaction count is the same as that stored in the log.  If all is in order, <code><a href="../../Programming/C/TL_Functions/apply.htm">mco_translog_apply()</a></code> proceeds to  apply all transactions stored in the log file, after which <code><a href="../../Programming/C/TL_Functions/start.htm">mco_translog_start()</a></code>is called to begin transaction logging for the new database session. </p>
                </blockquote>
                <h2>Database Recovery</h2>
                <p>The sequence to recover a database from a save-point or an empty database as the starting point, and two or more consecutive log files is shown here:</p>
                <p><b style="font-style: italic;">Transaction Logging:</b>
                </p>
                <div class="code-block"><pre>    &#160;
    char buff[64];
    mco_TL_start_data_t log_parms;
    log_parms.flags = 0;
    sprintf(buff, "transactions_%d.log", 0);
    CHECK(mco_translog_start (db, buff, &amp;log_parms));
    log_parms.flags |= MCO_TRANSLOG_RESTART;
    &#160;
    for (i = 1; i &lt; NPARTS; i++)
    {
        /* do database activity here */
        use_database();
        /* under some condition, e.g. log file size, restart log with new file */
        if( /* some condition */ )
        {
            sprintf(buff, "transactions_%d.log", i);
            CHECK(mco_translog_start (db, buff, &amp;log_parms));
        }
    }
    CHECK(mco_translog_stop(db));
    &#160;</pre>
                </div>
                <p><b style="font-style: italic;">Database Recovery:</b>
                </p>
                <div class="code-block"><pre>    &#160;
    for (i = 0; i &lt; NPARTS; i++)
    {
        char buff[64];
        mco_TL_log_info_t info;
        &#160;
        /* load next log file */
        sprintf(buff, "transactions_%d.log", i);
        CHECK(mco_translog_query_info(db, buff, 0, 0, &amp;info));
        ASSERT(info.transaction_apply_compat, MCO_YES);
        CHECK(mco_translog_apply(db, buff, MCO_TRANSLOG_ALL_LABELS));
    }
    &#160;</pre>
                </div>
                <p>This sequence fully recovers the database.  In the normal course of events, the database is restored from the last save-point image that was saved during an orderly shutdown, and there is no transaction log(s).  In the case of an abnormal termination, transactions from the log file will be recovered but, because the application terminated without calling <code><a href="../../Programming/C/TL_Functions/stop.htm">mco_translog_stop()</a></code>, there is no proper end of file mark at the end of the (last) log file and <code><a href="../../Programming/C/TL_Functions/apply.htm">mco_translog_apply()</a></code> will return <code>MCO_S_TL_INVDATA</code>.  In this case, you can call <code><a href="../../Programming/C/TL_Functions/query_info.htm">mco_translog_query_info()</a></code> (which will also return <code>MCO_S_TL_INVDATA</code>) and the count of transactions actually restored by <code><a href="../../Programming/C/TL_Functions/apply.htm">mco_translog_apply()</a></code> will be returned in <code>info.stored_trans_count</code>. (Whether the last restored transaction is the last transaction actually performed before the application crashed will depend on the flushing policy employed, and, if any policy other than synchronous logging, then also luck).</p>
                <p>When the application has finished, transaction logging is halted by calling <code><a href="../../Programming/C/TL_Functions/stop.htm">mco_translog_stop()</a></code>.  Then normal application termination is affected by calling <code><a href="../../Programming/C/Core_Functions/Static/Database_Control/disconnect.htm">mco_db_disconnect()</a></code> and <code><a href="../../Programming/C/Core_Functions/Static/Database_Control/close.htm">mco_db_close()</a></code>.  The following pseudo-code snippet illustrates how an application might perform a “restore and proceed” scenario (see <a href="../../Programming/C/SDK_Samples/TL/Basic.htm">samples/tl/tlogbasic</a> for a complete implementation:</p>
                <div class="code-block"><pre>    &#160;
    mco_runtime_start();
    mco_translog_init();
    ...
    mco_db_load();
    mco_db_connect();
    mco_translog_query_info(&amp;info);
    if (info.stored_transactions &gt; 0)
    {
        mco_translog_apply();
&#160;
        /* Create initial save-point */
        mco_db_save();
    }
    &#160;
    mco_translog_start();
    while (run) /* Normal database usage */
    {
        ...
        if (some_condition ) /* periodically create save-point */
        { 
            mco_db_save();
&#160;
            /* Truncate the log file */
            mco_translog_truncate();
        }
    }
    mco_db_save(); /* create the last save-point */
    mco_translog_stop();
    &#160;
    /* delete the log file here; it’s no longer needed */
    mco_db_disconnect();
    &#160;</pre>
                </div>
                <h2>Tips</h2>
                <p>There are three cases when using TL is warranted:</p>
                <blockquote>
                    <p>1.	When the database consists of only transient (in-memory) objects or when it consists of both transient and persistent objects (a so-called ‘hybrid’ database) and you need durability for both the persistent and the transient data.</p>
                    <p>2.	To export transactions to an external system (e.g. another DBMS), which we refer to as “Data Relay”.</p>
                    <p>3.	To create a persistent queue of events, for more robust event handling than is possible through the ‘event’ DDL notation and associated synchronous and asynchronous event handlers.</p>
                </blockquote>
                <p>Do not use TL to add persistence for persistent-only databases; <i>e</i>X<i>treme</i>DB runtime has its own robust and efficient database recovery facilities for persistent databases. It is important not to confuse the use of <i>e</i>X<i>treme</i>DB<i> Transaction Logging</i> APIs with the normal <i>e</i>X<i>treme</i>DB runtime logging for persistent databases.</p>
                <p>Due to the fact that applying a log to a database is slower than loading the database from a save-point (via function <code><a href="../../Programming/C/Core_Functions/Static/Database_Control/load.htm">mco_db_load()</a></code>), you should use TL&#160;function <code><a href="../../Programming/C/TL_Functions/apply.htm">mco_translog_apply()</a></code> only in case of an application crash or if a log needs to be applied up to specific label.  So create database save-points regularly, then when the application finishes normally, a ‘restore and proceed’ scenario like that shown above can be applied.</p>
                <p>&#160;</p>
                <h2>DDL Requirements</h2>
                <p>The schema for a database that uses transaction logging must include the <code>auto_oid</code> declaration.</p>
                <div class="code-block"><pre>    &#160;
    declare auto_oid [ESTIMATED_NUMBER_OF_OBJECTS];
    &#160;</pre>
                </div>
                <p>Whether the database actually uses transaction logging is determined at run-time. When the data definition is compiled for transaction logging, the <i>e</i>X<i>treme</i>DB DDL compiler inserts an 8-byte unique identifier (called <code>auto_OID</code>, not to be confused with the field type <code><a name="kanchor300"></a>autoid</code>) into each object.</p>
            </blockquote>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>