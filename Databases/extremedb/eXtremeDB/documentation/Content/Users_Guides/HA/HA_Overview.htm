<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="[%=System.LinkedTitle%]|High Availability User's Guide">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>eXtremeDB HA Overview</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <h1><i>e</i>X<i>treme</i>DB HA Overview</h1>
            <blockquote>
                <p>When employing synchronous replication, <i>e</i>X<i>treme</i>DB<i> High Availability</i> implements a time-cognizant two-phase commit replication protocol (synchronous replication) that provides the means to instantiate one or more standby database instances and bring the standby to a state of synchronization with the main database instance. From the point that a standby database is synchronized, and as long as the connection between the main and standby instance is maintained, the two-phase commit protocol ensures that the standby database is always an exact copy of the main database instance.</p>
                <p>The <i>e</i>X<i>treme</i>DB<i> High Availability</i><a name="kanchor99"></a> runtime is a context-less library; it does not create any tasks or run any processes. Instead it provides an API for applications to implement database high availability through both synchronous and asynchronous replication. Synchronous replication is implemented via a time-cognizant two-phase commit replication protocol that causes the master application to block at the transaction commit until the transaction has been propagated to, and committed by, the replica.</p>
                <p>A simplified description of a transaction using time-cognizant synchronous replication follows.</p>
                <ul>
                    <li value="1">	The application instance running as <code>Master</code> begins a transaction <code>T</code><a name="kanchor100"></a> and the transaction manager assigns a timestamp to it.</li>
                    <li value="2">	One or more application instances running as <code>Replicas</code>with a local copy of the database wait for notification from the <code>Master</code> of transactions to replicate on their local copies.</li>
                    <li value="3"> The <code>Master</code> performs all reads and writes locally within transaction <code>T</code> and calls <code><a href="../../Programming/C/Core_Functions/Static/Transaction_Control/commit.htm">mco_trans_commit()</a></code> which combines the updates into a single message called the “write set.”</li>
                    <li value="4">	The <code>Master</code> sends a “transaction availability” message and transaction data together in one <code>send()</code> operation to all <code>Replicas</code></li>
                    <li value="5">	Upon receiving the “availability” message, each <code>Replica</code> opens a transaction and assigns a timestamp to it.</li>
                    <li value="6">	If the entire write set is not received within a specified timeout, the <code>Replica</code> considers the communication failed, and attempts to send a notification back to the <code>Master</code>.</li>
                    <li value="7">	When the entire write set is received in time, the transaction manager in each <code>Replica</code> performs updates and tests the set for conflicts. It then sends the result of the commit back to the <code>Master</code>.</li>
                    <li value="8">	The transaction <code>T</code> only waits for the commit acknowledgments for a specified time period. Any result received after the timeout is not considered, and the node responsible for this late response is excluded from further processing. Thus, either a <code>Replica</code> is correctly updated in sync with the <code>Master</code> or it is dropped.</li>
                </ul>
                <p>Alternatively, replication can be achieved via asynchronous replication.  Whereas synchronous replication causes the master application to block at the transaction commit call until the transaction has also been committed by the replica(s), asynchronous replication does not block at the transaction commit, and thus update transactions process faster.  Replica databases are available to the replica applications for read-only access; the consequence of asynchronous replication is that replica applications may read ‘stale’ data if transactions were committed at the master but not yet propagated to the replica.</p>
                <p>It is possible to run the master and the replica within the same process against the same database. If replica mode is enabled (regardless of the fact that the master mode is enabled), database modifications are not allowed. For example, a “cascading replication” scenario might be implemented with the following three applications:</p>
                <blockquote>
                    <p>1.	<code>master</code>: acts as master only; can perform database modifications</p>
                    <p>2.	<code>rplmst</code>: acts as first level replica connected to master and also the <code>master</code> for the <code>replica</code></p>
                    <p>3.	<code>replica</code>: second level replica connected to <code>rplmst</code></p>
                </blockquote>
                <p><b>Note</b>: After an HA system has been running, if it is necessary to shut it down for any reason, an in-memory database can be saved via the C/C++ function <code><a href="../../Programming/C/Core_Functions/Static/Database_Control/save.htm">mco_db_save()</a></code> or the C# or Java <i>MasterConnection</i> or <i>ReplicaConnection</i> class <code>SaveSnapshot()</code> method, and subsequently loaded via <code><a href="../../Programming/C/Core_Functions/Static/Database_Control/load.htm">mco_db_load()</a></code>, or the C#/Java <code>Database.Open()</code> method, by the master and each of the replicas.  The databases will contain a transaction sequencer that will be examined by the HA runtimes and, if the sequencer is identical, the synchronization step will be bypassed.  This significantly accelerates the restart process, since the master and replicas will load their databases in parallel, versus the inherently serial nature of the synchronization step.</p>
                <h2>Communication Channel</h2>
                <p>One of the main challenges in the design of an efficient high availability embedded database management system is to enable the HA interface to be integrated into a wide variety of embedded real-time applications. Embedded applications require considerably different qualities of service in terms of expected throughput and delay, acceptable error levels, and the ability to adjust resource requirements. Embedded systems use a great variety of media access protocols and transports. While some high-end embedded systems communicate over a VME backplane or similar architecture, there are many that use multiple physical CPUs and require a LAN-based communications bus. A variety of industry-standard and proprietary media access protocols serve as foundations for LANs.</p>
                <p>The <i>e</i>X<i>treme</i>DB<i> High Availability</i> replication protocol adopts the communication protocol used by any given embedded application. To achieve this, <i>e</i>X<i>treme</i>DB<i> High Availability</i> utilizes a network (transport) level abstraction called a communication channel to support the requirements of real-time and embedded applications. The channel represents a simple end-to-end communication between a master and a replica. The channel is configured by a set of specific performance and other parameters. The required performance characteristics of a channel are specified in terms of timeouts, thus the primary attribute of the channel is its on-time reliability.</p>
                <p>The communication channel abstraction allows <i>e</i>X<i>treme</i>DB<i> High Availability</i> to be independent of the underlying media and the operating environment. This generic approach, however, requires the application to implement its communication layer. The <i>e</i>X<i>treme</i>DB<i> High Availability</i> distribution includes communication channel implementations for <code>TCP</code>, <code>UDP</code>, Named Pipes and <code>QNX</code> Messaging.</p>
                <h2>HA performance</h2>
                <p><i>e</i>X<i>treme</i>DB transactions are optimized for commits.  <i>e</i>X<i>treme</i>DB keeps “before image” pages during the transaction.  In the event the transaction is aborted, the “before image” pages will be returned to their original location, restoring the database to its state at the start of the transaction. In the case of a commit, the before images are simply discarded (returned to the free database memory pool), thus making commits much more efficient than aborts.</p>
                <p>So, as an application is modifying an <i>e</i>X<i>treme</i>DB database (adding, deleting, updating), the data is effectively committed as the transaction progresses.  When the transaction is committed, the indexes are updated.  If there are no errors (e.g. uniqueness violations) then the “before image” pages are returned to the free memory pool and the transaction is complete.  In essence, then, a transaction commit involves updating the indexes.</p>
                <p>In eager replication mode, an additional step is inserted in the process. When the transaction is committed (i.e. when the C/C++ function <code><a href="../../Programming/C/Core_Functions/Static/Transaction_Control/commit.htm">mco_trans_commit()</a></code> or the C# or Java <code>MasterConnection.CommitTransaction()</code> method, is called by a master) the commit data (the write set) is sent to the replicas.  In parallel, the master updates the indexes.  When the indexes are updated and the replica has returned the result code of the replica commit, the master runtime returns from the transaction commit call.</p>
                <p>
                    <img src="../../Resources/Images/note.png" />Note that	updating the indexes can cause a uniqueness constraint violation.  But, since the transaction has already been forwarded to the replica(s), the commit will fail on the master and each replica.  This is okay because, just as is reasonable to assume that an aborted transaction is a rare occurrence, it is reasonable to assume that uniqueness constraint violations are also a rare occurrence and the benefit obtained from updating the indexes in parallel with the replication outweighs the occasional inefficiency of transmitting a transaction that is certain to fail.</p>
                <p>&#160;</p>
                <p>The duration of the <code>synchronous</code> transaction commit in HA operation will be <code>T+C(d)+C(i)+R+C(d)</code> where:</p>
                <p><code>T</code> = the time to transmit the commit data to the replica application</p>
                <p><code>C(d)</code> = the time to commit the data in the master and replica database</p>
                <p><code>C(i)</code> = the time to commit the indexes in the master and replica database</p>
                <p><code>R</code> = the time for the replica runtime to transmit the return code to the master</p>
                <p>And the difference in transaction commit time in HA <code>synchronous</code> replication mode versus non-HA mode will be <code>T+C(d)+R</code>.  In any database, the majority of time is spent updating indexes, so because the index updates execute in parallel in the master and replica, the incremental increase in transaction commit time is mostly <code>T+R</code>, which puts a premium on very fast communication, such as over a high-speed bus.</p>
                <p><b>Note</b>: Explicit transaction rollbacks (e.g. the C/C++ function <code><a href="../../Programming/C/Core_Functions/Static/Transaction_Control/rollback.htm">mco_trans_rollback()</a></code> or the C# or Java <code>RollbackTransaction</code> method) are always handled locally by the master runtime.  Because the updates are never committed, there is never any commit data transmitted to the replica, so HA operation has no impact on the performance of aborted transaction.</p>
                <h2>Read-only Transactions and Load-balancing</h2>
                <p><i>e</i>X<i>treme</i>DB<i> High Availability</i> replica databases may be used for concurrent read-only access by other processes and/or threads.  This makes it possible for application developers to implement a load-balancing scheme, distributing database read requests across the master and standby instances.  Any MCO_READ_ONLY database transactions performed on the master will not be affected by HA operation, i.e. no write-set is sent to replicas when a read-only transaction is executed.</p>
                <p>It is important to note that the replica commit phase will wait for all read-only transactions to complete before processing commit data from the master when using the <code><a name="kanchor101"></a>MURSIW</code> transaction manager (not with <code><a name="kanchor102"></a>MVCC</code>. See the <a href="../Core/Concurrency_Transaction_Managers.htm"><i>e</i>X<i>treme</i>DB Concurrency Management</a> topic<span style="color: #f08080;"> </span>for a complete discussion of <i>e</i>X<i>treme</i>DB Transaction Managers).  This could adversely impact the duration of the two-phase commit.  In an extreme case, it could exceed the timeout specified for replication  To mitigate this, the replica transaction commit has a higher priority than any read request, so the maximum wait time will be the time it takes for the longest currently running read-only transaction to complete.  For this reason, it is best to keep read transactions short.</p>
                <h2>What can and cannot be done</h2>
                <p><i>e</i>X<i>treme</i>DB<i> High Availability</i> can replicate between persistent and transient databases, between different schema layouts (using the <code>Binary Schema Evolution</code> feature), and between different operating systems, even between a little-endian and a big-endian machines (for example x86 to PowerPC), as long as the hardware architecture on the master and the replica nodes are the same or binary compatible (for example Linux / x86 and VxWorks / x86).   However <i>e</i>X<i>treme</i>DB<i> High Availability</i> does not support replication between architectures with different integer sizes (x32 to x64) .</p>
                <p>&#160;</p>
            </blockquote>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>