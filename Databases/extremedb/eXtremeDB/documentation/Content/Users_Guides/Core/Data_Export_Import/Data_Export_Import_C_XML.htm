<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="[%=System.LinkedTitle%]|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>The  eXtremeDB XML C API </title>
        <link href="../../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <script src="../../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <h1>The  <i>e</i>X<i>treme</i>DB XML C API </h1>
            <blockquote>
                <p>For C applications, the <i>e</i>X<i>treme</i>DB schema compiler  option “<code>–x</code>” causes <code><a href="../../../Getting_Started/Package_Contents/mcocomp.htm">mcocomp</a></code> to generate interface functions to retrieve, create and replace (update) the contents of an object with the content of an XML string. Usage of the static and generated XML APIs are explained in the following sections.</p>
                <h2>XML export and import</h2>
                <p>The XML export and import functions are used in conjunction with user-defined file I/O helper functions to stream <i>e</i>X<i>treme</i>DB database contents to and from persistent media files:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET mco_db_xml_export(mco_trans_h t, void* stream_handle, mco_stream_write output_stream_writer);
    &#160;
    MCO_RET mco_db_xml_import(mco_trans_h t, void* stream_handle, mco_stream_read input_stream_reader);
    &#160;</pre>
                </div>
                <p>When <code><a href="../../../Programming/C/Core_Functions/Static/XML/export.htm">mco_db_xml_export()</a></code><a name="kanchor362"></a> is called the internal runtime implementation calls the user-defined handler <code><a href="../../../Programming/C/Structures/Stream_Writer.htm">output_stream_writer</a></code> to manage the output stream. And likewise <code><a href="../../../Programming/C/Core_Functions/Static/XML/import.htm">mco_db_xml_import()</a></code> causes the handler <code><a href="../../../Programming/C/Structures/Stream_Reader.htm">input_stream_reader</a></code> to be called. Simple file I/O handlers look like the following:</p>
                <div class="code-block"><pre>    &#160;
    mco_size_sig_t file_writer(void* stream_handle /* FILE*  */, const void* from, mco_size_t nbytes)
    {
        return (mco_size_t) fwrite(from, 1, nbytes, (FILE*) stream_handle);
    }
    &#160;
    mco_size_sig_t file_reader(void* stream_handle /* FILE*  */, void* to, mco_size_t max_nbytes)
    {
        return (mco_size_t) fread(to, 1, max_nbytes, (FILE*) stream_handle);
    }
    &#160;</pre>
                </div>
                <p>Function <code>mco_db_xml_export()</code> may be called within a <code>READ_ONLY</code> transaction but, as expected,  <code>mco_db_xml_import()</code> must be called within a <code>READ_WRITE</code> transaction. When importing data into an existing database, new data will be added into the database and no existing data will be lost.</p>
                <p><code>mco_db_xml_import()</code> calls the internal function <code>mco_w_xml_create_object()</code> to create a new object in the database for each object loaded from the <span class="Param">XML</span> stream. Since the import procedure runs in the context of a single transaction, there are only two possible results: either the whole data set will be imported successfully or no data will be imported. For example, if an object being imported creates a duplicate for any unique index, the entire transaction will be rolled back.</p>
                <h2><a name="kanchor363"></a>Unique identifiers oid, autoid and autooid</h2>
                <p>It is necessary to explain how <i>e</i>X<i>treme</i>DB handles unique identifiers, i.e. fields of the types <code>oid</code>, <code>autoid</code> and <code>autooid</code>. As explained above, the import procedure only creates new objects and never updates existing objects. So if a class contains an <code><a href="../../../Programming/C/DDL/Declare.htm">oid</a></code> field, the <code>oid</code> value from the <span class="Param">XML</span> stream is used in the newly created object. Care must be taken to assure that imported <code>oid</code> values do not duplicate values in existing database objects.</p>
                <p>In the case of “automatic id” fields of type <code><a href="../../../Programming/C/DDL/Declare.htm">autoid</a></code> and  <code><a href="../../../Programming/C/DDL/Declare.htm">autooid</a></code>, the import procedure behaves according to the current XML policy settings. The policy switches <code>ignore_autoid</code> and <code>ignore_autooid</code>, when set to value <code>MCO_YES</code>, cause the procedure to ignore values for fields of this type in the XML stream and  <code>mco_w_xml_create_object()</code> will generate the id values for the newly created objects just as if they were created by calling the <code>classname_new()</code> function.  The default setting of the XML policy is <code>MCO_YES</code> for both switches as the safest setting to preserve database integrity.</p>
                <h2>XML Policy</h2>
                <p>The XML <a href="../../../Programming/C/Structures/XML_Policy.htm">policy structure</a> defines behavior options of the XML interface, such as string / blob encoding, XML indentation, etc.  It can be set by the application at compile time and also at runtime via the policy APIs.  These APIs and <a href="../../../Programming/C/Structures/XML_Policy.htm">available options</a> are defined in the <i>e</i>X<i>treme</i>DB header file <code>include/mcoxml.h</code>.</p>
                <p>The <a href="../../../Programming/C/Structures/XML_Policy.htm">default policy</a> can be retrieved by calling the following function:</p>
                <div class="code-block"><pre>&#160;
    void mco_xml_get_default_policy( /*OUT*/ mco_xml_policy_t * p);
    &#160;</pre>
                </div>
                <p>To get and set the current policy the following functions are used:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET mco_xml_get_policy( /*IN*/ mco_trans_h t, /*OUT*/ mco_xml_policy_t * p);
    &#160;
    MCO_RET mco_xml_set_policy( /*IN*/ mco_trans_h t, /*IN*/ const mco_xml_policy_t * p);
    &#160;</pre>
                </div>
                <p>To set the current policy requires a <code>READ_WRITE</code> transaction and the policy changes become effective immediately on calling <code><a href="../../../Programming/C/Core_Functions/Static/XML/set_policy.htm">mco_xml_set_policy()</a></code>, <i style="font-weight: bold;">not</i> when the transaction is committed.</p>
                <p>For example:</p>
                <div class="code-block"><pre>    &#160;
    void ChangeXMLOutput(void)
    {
        mco_xml_policy_t policy;
        mco_trans_h   t ;
        &#160;
        mco_trans_start(db,MCO_READ_WRITE,MCO_TRANS_FOREGROUND,&amp;t);
        mco_xml_get_policy(t, &amp;policy);
        policy.text_coding = MCO_TEXT_BASE64; //BASE64;
        policy.blob_coding = MCO_TEXT_BASE64; //BASE64;
        policy.ignore_field = MCO_YES;
        mco_xml_set_policy(t, &amp;policy);
        &#160;
        // Do xml processing that depends on policy settings
        ...
        mco_trans_commit(t);
    }
    &#160;</pre>
                </div>
                <p>
                    <img src="../../../Resources/Images/note.png" /><b>Note on using alternative XML representation with attributes</b>:  Attributes are used to provide additional information about elements.  In essence, XML elements can have attributes in the start tags, just like HTML.  (See the web site <a href="http://www.w3.org/TR/2008/REC-xml-20081126/" title="XML Standards" alt="XML Standards">http://www.w3.org/TR/2008/REC-xml-20081126/</a> for details.)  To enable the XML representation using attributes, set the <code>use_xml_attrs</code>  field of the <code><a href="../../../Programming/C/Structures/XML_Policy.htm">mco_xml_policy_t</a></code> structure to <code>MCO_YES</code>:</p>
                <div class="code-block"><pre>&#160;
    rc = mco_trans_start(db, MCO_READ_WRITE, MCO_TRANS_FOREGROUND, &amp;t);
    policy.use_xml_attrs = MCO_YES;
    mco_xml_set_policy(t, &amp;policy);
    rc = mco_trans_commit(t);
    &#160;</pre>
                </div>
                <h2>Generated XML Interfaces</h2>
                <p>As with all <i>e</i>X<i>treme</i>DB <a href="../../../Programming/C/Generated.htm">generated interface</a> functions, the XML functions are generated based on the <a href="../../../Programming/C/DDL.htm">DDL</a> schema definition. Consider the following schema fragment:</p>
                <div class="code-block"><pre>&#160;
    struct Country
    {
        char&lt;3&gt; c_code;
        string  name;
    };
    struct Date
    {
        uint1   day;
        char&lt;3&gt; month;
        uint2   year;
    };
    struct Passport
    {
        char&lt;8&gt; series;
        uint8    number;
    };
    struct Address
    {
        Country  country;
        string   city;
        string   street;
    };
    struct Phone
    {
        int2    country;
        char&lt;5&gt; area;
        char&lt;7&gt; number;
    };
    struct Residence
    {
        Address where;
        Date    since;
        optional Phone   phone;
    };
    struct Office
    {
        Address         where;
        string          organization;
        string          position;
        vector&lt;Phone&gt;   phone;
    };
    class Person
    {
        string    name;
        Residence residence[3];
        optional Office    office;
        optional Phone     mobile;
        blob      description;
        &#160;
        oid;
        autoid[100];
        &#160;
        list;
    };
    &#160;</pre>
                </div>
                <h3>_xml_get()</h3>
                <p>For each class declared in the schema, the DDL compiler generates an <code>_xml_get()</code> function that is generally used (contrary to the implication of “get”) to <i>write</i> the XML representation of a database object to an output stream:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET &lt;classname&gt;_xml_get( /*IN*/ classname *handle, /*IN*/ void * stream_handle, /*INOUT*/ mco_stream_write o_stream);
    &#160;</pre>
                </div>
                <p>The following code snippet demonstrates how the <code>_xml_get()</code> function would be called within a <code>READ_ONLY</code> transaction to <i>write</i> database objects in XML format to the output stream:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET output_data (mco_db_h db)
    {
        mco_trans_h  t;
        Person       p_obj;
        MCO_RET      rc;
        mco_cursor_t c;
        FILE * f = fopen(xml_name, "w");
        &#160;
        rc = mco_trans_start(db, MCO_READ_ONLY, MCO_TRANS_FOREGROUND, &amp;t);
        if(rc) return rc;
        &#160;
        // instantiate a 'list' cursor for Person class
        rc = Person_list_cursor(t, &amp;c);
        if(rc) return rc;
        &#160;
        // iterate over the Person objects
        rc = mco_cursor_first(t, &amp;c);
        if(rc) return rc;
        &#160;
        for(;;)
        {
            // get Person object handle from the cursor
            rc = Person_from_cursor ( t, &amp;c, &amp;p_obj);
            if(rc) return rc;
            &#160;
            // write Person object as XML through the 'doprint' function
            rc = Person_xml_get(&amp;p_obj, f, &amp;do_print);
            if(rc) return rc;
            &#160;
            // advance the cursor, break loop if end of list
            if ( mco_cursor_next(t, &amp;c) != MCO_S_OK )
                break;
        }
        rc = mco_trans_commit(t);
        return rc;
    }
    &#160;
    int do_print( /*IN*/ void *stream_handle, /*IN*/ const void * from, /*IN*/ unsigned nbytes)
    {
        // this simple example just writes the bytes to a FILE
        // another example could write the bytes to a
        // pipe to another process, a socket, etc.
        FILE * f = (FILE*)stream_handle;
        return fwritef( from, sizeof(char), nbytes, f );
    }
    &#160;</pre>
                </div>
                <p>In this example, the stream is a file handle. It could have been a pipe to another process or any other type of stream. <code>Person_xml_get()</code> encodes the person object referenced by the handle, and calls the helper function <code>do_print()</code> passing the stream handle, a pointer to the XML string, and the length of the XML string.</p>
                <p>Note that the <code>classname_xml_get()</code> does not create any XML header.  If an application is going to create a monolithic document with multiple XML objects, possibly of different XML tags, the application must create the appropriate XML header and footer entries to make it a legal XML document.</p>
                <h3>_xml_put() and _xml_create()</h3>
                <p>For each class declared in the schema, the DDL compiler also generates an <code>_xml_put()</code> function that is used to update existing database objects, and an <code>_xml_create()</code> function to add new database objects:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_xml_put( /*IN*/ classname *handle, /*IN*/ const char * xml );
    &#160;
    MCO_RET  classname_xml_create( /*IN*/ mco_trans_h t, /*IN*/ const char * xml, /*OUT*/ classname * handle);
    &#160;</pre>
                </div>
                <p>The <code>_xml_put()</code> function updates an existing object from the XML description. The entire object is updated; it is not possible to selectively update fields.  (Note that the class handle will have been established from, for example, a cursor, and carries the transaction context with it - hence, it is not necessary to pass a transaction handle to this function).</p>
                <p>The <code>_xml_create()</code> function creates an object from the XML description.  The first parameter is the transaction context, the second parameter is the XML description and the output parameter is a handle to the new object.  The following code snippet demonstrates how an XML input file could be parsed to obtain an object’s XML description, then call <code>_xml_create()</code> to insert the new object into the database:</p>
                <div class="code-block"><pre>&#160;
    static int insert(mco_db_h db, FILE *file)
    {
        MCO_RET     rc;
        mco_trans_h t;
        Person      p_obj;
        int         c;
        &#160;
        for (;;) /* loop on xml-objects */
        {
            /* start the transaction */
            rc = mco_trans_start(db, MCO_READ_WRITE, MCO_TRANS_FOREGROUND, &amp;t);
            if(rc) return rc;
            &#160;
            /* skip everything before a class tag */
            do c = getc(file);
            while ( c != '&lt;'  &amp;&amp;  c != EOF )
                ;
            if ( c == EOF )
                break; /* end-of-file, thus finished */
            &#160;
            ptr = 1;
            xml[0] = '&lt;';
            /* read the class name */
            do
            {
                c = getc(file);
                xml[ptr++] = c;
            } while ( c != '&gt;'  &amp;&amp;  c != EOF );
            &#160;
            if ( c == EOF )
                break; /* finished */
&#160;
            xml[ptr] = 0;
            if ( strcmp(xml, "&lt;Person&gt;") != 0 )
                exit(1);
&#160;
            /* read xml-object */
            for (;;)
            {
                c = getc(file);
                if ( c == EOF )
                {
                    xml[ptr] = 0;
                    printf("\n Error - unexpected end of file: %s\n",
                        &amp;xml[(ptr&gt;50)?ptr-50:0]);
                    exit(4);
                }
                xml[ptr++] = c;
                if ( c == '&gt;' )
                {
                    xml[ptr] = 0;
                    /* closing tag, the object is complete */
                    if ( strcmp("&lt;/Person&gt;", &amp;xml[ptr-9]) == 0 )
                        break;
                }
            }
&#160;
            /* write database.. */
            rc = Person_xml_create(t, xml, &amp;p_obj);
            if ( rc != MCO_S_OK )
                exit(0);
&#160;
            rc = mco_trans_commit(t);
            &#160;
            /* ... and start over */
            ptr = 0;
        } /* loop on xml-objects */
&#160;
        return rc;
    }
    &#160;</pre>
                </div>
                <p>In the above example, an XML string is parsed to find the class tag.  This example only deals with <code>Person</code> objects, so if class tag is for any other type of object, the procedure terminates.  Otherwise, the XML is read up to the closing <code>Person</code> tag (“&lt;/Person&gt;”).  Then <code>Person_xml_create()</code> is called, passing a transaction handle, the XML string, and the handle of a <code>Person</code> object that will reference the newly created object.</p>
                <p>Note that if an XML document was created by <i>e</i>X<i>treme</i>DB and contains just a single XML object, there is no need to parse the opening and closing tags; just read the entire XML into a buffer and pass it to <code>_xml_create()</code>.</p>
                <p>If the <code>Person</code> object represented in the XML string already existed in the database (i.e. an attempt was made to violate a unique key constraint), <code>Person_xml_create()</code> would fail with code <code>MCO_S_DUPLICATE</code>.  If this is a possibility, the application should be written to find the key values within the XML string and attempt to locate the object first, and then call the <code>_xml_put()</code> or <code>_xml_create()</code> function accordingly.  This process is illustrated in the following pseudo-code:</p>
                <div class="code-block"><pre>&#160;
    for (;;) /* loop on xml-objects */
    {
        /* start the transaction */
        /* skip everything before a class tag */
        /* read the class name */
        if ( strcmp(xml, "&lt;classname&gt;") != 0 )
            exit(1);
&#160;
        /* read xml-object */
        /* extract key fields */
        /* write database.. */
        if((rc = classname_fieldname_search(. . .)) == MCO_S_OK)
            rc = classname_xml_put(. . .);
        else
            rc = classname_xml_create(. . .);
        if ( rc != MCO_S_OK )
            exit(0);
            &#160;
        rc = mco_trans_commit(t);
        /* ... and start over */
    } /* loop on xml-objects */
    &#160;</pre>
                </div>
                <h3>_xml_schema()</h3>
                <p>The last generated function for each class declared in the schema is the <code>_xml_schema()</code> function used to write the XML description of this class to the output stream.</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_xml_schema( /*IN*/ mco_trans_h t, /*IN*/ void * stream_handle, 
                        /*INOUT*/ mco_stream_write o_stream );
    &#160;</pre>
                </div>
                <p>The <code>_xml_schema()</code> function must be called in the context of either a <code>READ_ONLY</code> or a <code>READ_WRITE</code> transaction.  The output schema format is compliant with the W3C specifications, which can be found in the following documents: <a href="http://www.w3.org/TR/xmlschema-0">http://www.w3.org/TR/xmlschema-0</a> and <a href="http://www.w3.org/TR/xmlschema-1">http://www.w3.org/TR/xmlschema-1</a></p>
                <p>(The current implementation of this function only supports the default <span class="Param">XML</span> policy.)</p>
                <p>Example:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET output_schema (mco_db_h db )
    {
        mco_trans_h t;
        FILE * f = 0;
        MCO_RET rc;
        &#160;
        mco_trans_start(db, MCO_READ_ONLY, MCO_TRANS_FOREGROUND, &amp;t);
        f = fopen("person.xsd", "w");
        Person_xml_schema( t, f, &amp;do_print );
        fclose(f);
        rc = mco_trans_commit(t);
        &#160;
        return rc;
    }
    &#160;</pre>
                </div>
                <p>The XML schema can be used in conjunction with tools, such as <i>XMLSpy</i>, to validate the content of XML documents, which you can do prior to attempting to import the XML document into <i>e</i>X<i>treme</i>DB.</p>
                <p>The XML document can also be used with <i>XSLT</i>, which is a language for transforming XML documents into other XML documents.  This might be a necessary step to exchange data between <i>e</i>X<i>treme</i>DB and an external system if they don’t have identical representations for the data being exchanged.  For further information on <i>XSLT</i>, please refer to <a href="http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a></p>
                <h2>Output Data Format</h2>
                <p>Whether using <code>mco_db_xml_export()</code> or a generated <code>_xml_get()</code> function to export data, the XML output always starts with the &lt;<code>classname</code>&gt;.  If the value of the indent field in the policy is 1, a new line is started and <code>indent_element</code> spaces are added. The <code>indent_element</code> constant is defined as two spaces.  Every time it is necessary to step down one level in the hierarchy, this process is repeated.  A new level is started when a structure, a vector or an array is processed.</p>
                <ul>
                    <li value="1"><code>uint1, uint2, uint4, int1, int2, int4</code> are written as the appropriate integers (unsigned or signed). The base is defined in the policy field <code>int_base</code>, which could be 8, 10 (default) and 16.</li>
                    <li value="2"><code>uint8, int8</code> are written similar to the other integers, but decimal format is not allowed.</li>
                    <li value="3"><code>autoid</code> is formatted as <code>uint8</code></li>
                    <li value="4"><code>date, time</code> are formatted as <code>uint4</code></li>
                    <li value="5">output for <code>float</code> and <code>double</code> depend on the policy’s <code>float_format</code> field value. <code>MCO_FLOAT_FIXED</code> means <code>floats</code> are formatted as fixed-point numbers (eg. <code>0.0025</code>); <code>MCO_FLOAT_EXPONENT</code> means floats are represented in exponent form: i.e. integer part, fractional part and exponent (eg, <code>2.5e-3</code>)</li>
                    <li value="6"><code>oid, ref</code> are coded into hexadecimal format</li>
                    <li value="7"><code>blob</code> depends on the <code>blob_coding</code> value: <code>MCO_TEXT_ASCII</code> means <span class="Param">ASCII</span> as defined by the <span class="Param">XML</span> specifications, <code>MCO_TEXT_BINHEX</code> means <span class="Param">BINHEX</span> (2 hexadecimal digits / byte), <code>MCO_TEXT_BASE64</code> (Base64: this is a non-standard <span class="Param">XML</span> enhancement specific to <i>e</i>X<i>treme</i>DB)</li>
                    <li value="8"><code>char, string</code> formatted in accordance to the policy’s text_coding field: <code>MCO_TEXT_ASCII</code>  means <span class="Param">ASCII</span> as defined by the <span class="Param">XML</span> specifications (default), <code>MCO_TEXT_BINHEX</code> means BINHEX, <code>MCO_TEXT_BASE64</code> (Base64: this is a non-standard XML enhancement specific to <i>e</i>X<i>treme</i>DB)</li>
                </ul>
                <h2>Input Data Format</h2>
                <p>Whether using <code>mco_db_xml_import()</code> to import data or a generated <code>_xml_put()</code> or <code>_xml_create()</code> function to convert the XML description to <i>e</i>X<i>treme</i>DB data format, the XML input will be converted according to the following rules:</p>
                <ul>
                    <li value="1"><code>uint1, uint2, uint4, int1, int2, int4</code> are decoded from the incoming XML natively. The numeric base is determined based on the first characters; 0 for octal, 0x – for hex, otherwise the number is considered decimal. For example, <code>0643</code> – octal, <code>419</code> – decimal, <code>0x1A3</code> – hex; hexadecimal notation allows using capital or low-case letters (<code>0x1a3</code> is okay)</li>
                    <li value="2">The number taken from the XML string is converted to the database type according to the dictionary. If the conversion is not possible without data loss, the appropriate error is emitted (for example, <code>MCO_E_XML_INVINT</code>, <code>MCO_E_XML_INTOVF</code>)</li>
                    <li value="3"><code>uint8, int8</code> are decoded similar to other integers, but the base must be 8 or 16. If the base is 10 the error code <code>MCO_E_XML_INVBASE</code> is returned</li>
                    <li value="4"><code>date, time</code> are considered <code>uint4</code></li>
                    <li value="5"><code>float, double</code> could be in exponential form or with the decimal point (i.e. <code>1.23e4</code> or <code>11.222</code>), otherwise the error <code>MCO_E_XML_INVFLT</code> is returned</li>
                    <li value="6"><code>ref</code> should be written as hex value with 2 hexadecimal digits per byte</li>
                    <li value="7"><code>blob</code> is decoded in accordance with the <code>blob_coding</code> value: <code>MCO_TEXT_ASCII</code> – ASCII as defined by the XML specifications, <code>MCO_TEXT_BINHEX</code> – BINHEX (2 hexadecimal digits / byte), <code>MCO_TEXT_BASE64</code> – Base64 (default: this is a non-standard XML enhancement specific to <i>e</i>X<i>treme</i>DB)</li>
                    <li value="8"><code>char, string</code> are decoded according to the text_coding value: <code>MCO_TEXT_ASCII</code> – ASCII (default), <code>MCO_TEXT_BINHEX</code> – BINHEX with two hex digits/per byte, <code>MCO_TEXT_BASE64</code> – Base64. If the resulting string length is longer than the size indicated by the dictionary, the string is truncated. If it is shorter, it is padded with zeros (‘\0’).</li>
                </ul>
            </blockquote>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../../../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>