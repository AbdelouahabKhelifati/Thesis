<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="Programming with eXtremeDB|Native APIs|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Creating and Modifying Database Objects in C</title>
        <link href="../../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <link href="../../../Resources/TableStyles/FunctionReference.css" rel="stylesheet" />
        <script src="../../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <h1>Creating and Modifying Database Objects   in C</h1>
            <blockquote>
                <p>As explained in the following links, the static application-independent functions  are used for <i>e</i>X<i>treme</i>DB <a href="../Runtime_Environment.htm" name="kanchor25">runtime control</a>, <a href="../Database_Control.htm">database control</a> (opening, connecting to and closing databases), <a href="../Transaction_Control.htm">transaction management</a> and <a href="../Indexes_Cursors.htm">cursor navigation</a>. But to create and modify individual database objects, C applications use the strongly typed object interfaces generated by the <code><a href="../../../Getting_Started/Package_Contents/mcocomp.htm">mcocomp</a></code> schema compiler.</p>
                <p>The schema compiler generates the following  types of C interface functions depending on the specific <a href="../../../Programming/C/DDL.htm">DDL</a> class definitions: <b>new</b> and <b>delete</b> object creation and removal methods, <b>put</b> and <b>get</b> methods for storing and retrieving object field data, <code>oid</code> and <code><a name="kanchor26"></a>autoid</code> access methods, <b>find</b> and <b>search</b> methods for looking up objects by indexes, and <b>event</b> methods for responding to database events.</p>
                <p>Some functions operate on entire database objects, while others on fields within the object. To generate function names for object-action functions,  the compiler uses the class name followed by <code>_new()</code>, <code>_delete()</code> or <code>_delete_all()</code>. To generate function names for field-action functions the compiler uses the class or structure name, followed by the field name and then the action word, all separated by underscores.  Action words can be any of the following: <code>put, get, at, put_range, get_range, alloc, erase, pack</code> and <code>size</code>.</p>
                <h2>New and Delete</h2>
                <p>In C applications, creating and deleting objects are accomplished by calling the generated <code>_new()</code> and <code>_delete()</code> functions.  The <code>_new()</code> function reserves initial space for an object and returns a reference (handle) to the freshly created data object. These functions are generated only for classes; no <code>_new()</code> or <code>_delete()</code> functions are generated for structures because <i>structures are never instantiated</i> by themselves in the database; they always belong to some class.</p>
                <p>For classes declared without an <code>oid</code>:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_new ( /*IN*/ mco_trans_h t, /*OUT*/ classname *handle);
    &#160;</pre>
                </div>
                <p>For classes declared with an <code>oid</code>, the <code>oid</code> must be passed:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_new ( /*IN*/ mco_trans_h t, /*IN*/ databasename_oid * oid, /*OUT*/ classname *handle);
    &#160;</pre>
                </div>
                <p>The <code>_delete()</code> function permanently removes the object whose handle is passed while the <code>_delete_all()</code> function removes all objects of the class from the database.  Storage pages occupied by the object(s) are also returned back to the storage manager for reuse.</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_delete (/*IN*/ classname *handle);
    &#160;
    MCO_RET classname_delete_all ( /*IN*/ mco_trans_h t );
    &#160;</pre>
                </div>
                <h2>Put and Get</h2>
                <p>For each field of an object and for each element of a structure declared in the schema file, <code>_put()</code> and <code>_get()</code> functions are generated. The <code>_put()</code> functions are called to update specific field values.  Depending on the type of field, the generated <code>_put()</code> function will be one of the following forms.</p>
                <p>For scalar type fields it will be of the form:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET  classname_fieldname_put( /*IN*/ classname *handle, /*IN*/ &lt;type&gt; value);
    &#160;</pre>
                </div>
                <p>For <code>char</code> and <code>string</code> fields a pointer and length argument are required:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_put( /*IN*/ classname *handle, /*IN*/ const char *value,
                        /*IN*/ uint2 len);
                        &#160;</pre>
                </div>
                <p>It is important to understand how the <code>_put()</code> operation copies data to the database field and any associated indexes. Consider the following schema:</p>
                <div class="code-block"><pre>&#160;
    persistent class MyClass
    {
        char&lt;10&gt; buf;
        tree&lt;buf&gt; idx;
    }
    &#160;</pre>
                </div>
                <p>Now the following code snippet puts “abc” into the <code>char&lt;10&gt;</code> field <code>buf</code>:</p>
                <div class="code-block"><pre>&#160;
    MyClass cls;
    char buf[10] = "abc"
    ...
    MyClass_new(t, &amp;cls);
    MyClass_buf_put(&amp;cls, buf, strlen(buf));
    &#160;</pre>
                </div>
                <p>The <i>e</i>X<i>treme</i>DB runtime will copy the specified number of characters (3) into the field and fill the remaining 7 bytes with the <code>MCO_SPACE_CHAR</code>. The default value of <code>MCO_SPACE_CHAR</code> is <code>\0</code>. This normalizes the value of the unused part of the field for later sort operations. The runtime will not copy the extra null terminator from the input string.</p>
                <p>If there is an index on this field, the index node is handled differently depending on whether this class is <i>transient</i> or <i>persistent</i>. For transient classes, no data is copied to the index node. For persistent classes, the entire contents of the field are copied from the field value (not from the input variable) to the index node. So for the example above the bytes <code>[abc\0\0\0\0\0\0\0]</code> will be copied into the field <code>buf</code> first, and then (when the transaction is committed) from the field <code>buf</code> to the index node (because this is a persistent class).</p>
                <p>Note that if a character array of length 10 is copied into field <code>buf</code>, there is no null terminator in the field. If a character array of more than 10 characters is used as the argument to <code>_put()</code>, only the specified number of characters (obviously &lt;= 10) is copied.</p>
                <p>The <code>_get()</code> functions are called to bind a field of an object to an application variable and the function will be one of the following forms depending on the type of field.</p>
                <p>For scalar type fields it will be of the form:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_get( /*IN*/ classname *handle, /*OUT*/ &lt;type&gt; *value);
    &#160;</pre>
                </div>
                <p>For fixed length char fields the length must be specified:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_get( /*IN*/ classname *handle, /*OUT*/ char *dest,
                        /*IN*/ uint2 dest_size);
                        &#160;</pre>
                </div>
                <p>If the field is a string then the function takes two extra parameters: the <code>size</code> of the buffer to receive the string, and an OUT parameter to receive the actual number of bytes returned.  So the generated function will have the form:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_get( /*IN*/ classname *handle, /*OUT*/ char *dest, 
                        /*IN*/ uint2 dest_size, /*OUT*/ uint2 *len);
                        &#160;</pre>
                </div>
                <p>Some things to note about the behavior of <code>_get()</code> on character and string fields (using the example of field) :</p>
                <ul>
                    <li value="1">	it puts the entire value of the <code>char</code> or <code>string</code> field plus a null terminator <i>if the destination buffer is big enough</i>.</li>
                    <li value="2">for a field value of "<code>1234567890</code>" the call of <code>_get(..., buf, sizeof(buf), ... )</code> into a <code>char buf[100]</code> variable will extract "<code>1234567890\0</code>";</li>
                    <li value="3">it puts the whole value of  the <code>char</code> or <code>string</code> field without the null terminator if the destination buffer is exactly the size to fit the whole value. For example, for the value "<code>1234567890</code>" the call of <code>_get(..., buf, sizeof(buf), ... )</code> into the <code>char buf[10]</code> variable will extract "<code>1234567890</code>" (no null terminator);</li>
                    <li value="4">	it puts as much as will fit of the value of the <code>char</code> or <code>string</code> field without the null terminator if the destination buffer is smaller than the whole value. For example, for the value "<code>1234567890</code>" the call of <code>_get(..., buf, sizeof(buf), ... )</code> into a <code>char buf[5]</code> variable will extract "<code>12345</code>" (no null terminator).</li>
                </ul>
                <h2>Numeric and Decimal generated functions</h2>
                <p>As stated in the <a href="../../../Programming/C/DDL/Base_Data_Types.htm">Base Data Types</a> page, the values for database fields of type <code>decimal</code> or <code>numeric</code> are stored internally as integers of a size determined by the specified width:</p>
                <table class="TableStyle-FunctionReference" style="mc-table-style: url('../../../Resources/TableStyles/FunctionReference.css');margin-left: 0;margin-right: auto;" cellspacing="0">
                    <col class="TableStyle-FunctionReference-Column-Column2" />
                    <col class="TableStyle-FunctionReference-Column-Column2" />
                    <thead>
                        <tr class="TableStyle-FunctionReference-Head-Header1">
                            <th class="TableStyle-FunctionReference-HeadE-Column2-Header1">Width</th>
                            <th class="TableStyle-FunctionReference-HeadD-Column2-Header1">Storage type</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">1-2</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">signed&lt;1&gt;</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">3-4</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">signed&lt;2&gt;</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">5-9</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">signed&lt;4&gt;</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyB-Column2-Body1">10-19</td>
                            <td class="TableStyle-FunctionReference-BodyA-Column2-Body1">signed&lt;8&gt;</td>
                        </tr>
                    </tbody>
                </table>
                <p>For these fields, the standard <code>_put()</code> and <code>_get()</code> functions described above are generated and the argument passed to <code>_put()</code> and <code>_get()</code> will be an integer pointer or value of the corresponding size.</p>
                <p>In addition to the <code>_put()</code> and <code>_get()</code>, the following functions are generated to allow specifying the field value as a character string:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET  CLASS_FIELD_put_chars( CLASS *handle, char const* buf);
    &#160;
    MCO_RET  CLASS_FIELD_get_chars( CLASS *handle, char* buf, int buf_size);
    &#160;</pre>
                </div>
                <p>The <code>_put_chars()</code> function converts the input string of characters to an  integer value and stores it in the database field. The <code>_get_chars()</code> function extracts the value from the database field and represents it as a string of characters. To facilitate conversion of integer values to character string and vice versa, two helper functions are also generated:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET  CLASS_FIELD_to_chars( TYPE scaled_num, char* buf, int buf_size);
    &#160;
    MCO_RET  CLASS_FIELD_from_chars( TYPE* scaled_num, char const* buf);
    &#160;</pre>
                </div>
                <p>Consider a schema defining a decimal like:</p>
                <div class="code-block"><pre>&#160;
    class A {
        ...
        decimal&lt;10,3&gt; dec;
        ...
    };
    &#160;</pre>
                </div>
                <p>The following code snippet demonstrates how these functions might be used in practice:</p>
                <div class="code-block"><pre>&#160;
    A     a;
    int8  i8;
    &#160;
    /* Allocate an object */
    A_new ( t, &amp;a );
    ...
&#160;
    /* put int8 value to numeric field */
    A_dec_from_chars( &amp;i8, "123456");
    A_dec_put( &amp;a, i8 );
    ...
    &#160;
    /* put char array value to decimal field */
    A_dec_to_chars( 987654321, buf, sizeof(buf));
    A_dec_put_chars( &amp;a, buf );
    ...
    &#160;
    /* put char array value to decimal field */
    A_dec_to_chars( 987654321, buf, sizeof(buf));
    A_dec_put_chars( &amp;a, buf );
    ...
    &#160;
    A_from_cursor(t, &amp;csr, &amp;a);
    printf("\n\tContents of first record A: \n");
    ...
    &#160;
    /* get values from numeric/decimal fields */
    A_dec_get( &amp;a, &amp;i8);
    A_dec_get_chars( &amp;a, buf, sizeof(buf));
    printf("\t\tdec=%lld, chars(%s)\n", i8, buf );
    &#160;</pre>
                </div>
                <h2>Fixed _put() and _get()</h2>
                <p>Often database classes will contain many fields with the consequence that fetching and storing these objects require a long series of <code>_get()</code> and <code>_put()</code> function calls for each individual field.  To simplify this work of coding, the schema compiler generates a C-language structure for all scalar fields and arrays of fixed length and additional <code>&lt;classname&gt;_fixed_get()</code> and <code>&lt;classname&gt;_fixed_put()</code> functions are generated that can significantly reduce the number of function calls required.  But, as the name indicates, these functions can only be generated for the <i>fixed size fields</i> of a given class.  If a class contains fields of variable length (e.g. string, vector or blob fields) then these fields must be accessed with their individual <code>_get()</code> and <code>_put()</code> functions.</p>
                <p>For example, the following schema:</p>
                <div class="code-block"><pre>&#160;
    struct B 
    {
        signed&lt;1&gt; i1;
        signed&lt;2&gt; i2;
        signed&lt;4&gt; i4;
&#160;
        char&lt;10&gt;  c10;
&#160;
        float  f;
    };
    &#160;
    class A 
    {
        unsigned&lt;1&gt; ui1;
        unsigned&lt;2&gt; ui2;
        unsigned&lt;4&gt; ui4;
        double         d;
        string  s;
&#160;
        B       b;
&#160;
        list;
    };
    &#160;</pre>
                </div>
                <p>would cause the following “C” structures to be generated:</p>
                <div class="code-block"><pre>&#160;
    /* Structures for fixed part of the classes */
    typedef struct B_fixed_ {
        int1 i1;
        int2 i2;
        int4 i4;
        char c10[10];
        float f;
    } B_fixed;
    &#160;
    typedef struct A_fixed_ {
        uint1 ui1;
        uint2 ui2;
        uint4 ui4;
        double d;
        B_fixed b;
    } A_fixed;
    &#160;</pre>
                </div>
                <p>with the following access functions:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET  B_fixed_get( B *handle_, B_fixed* dst_ );
    &#160;
    MCO_RET  B_fixed_put( B *handle_, B_fixed const* src_ );
    &#160;
    MCO_RET  A_fixed_get( A *handle_, A_fixed* dst_ );
    &#160;
    MCO_RET  A_fixed_put( A *handle_, A_fixed const* src_ );
    &#160;</pre>
                </div>
                <p>Using these functions, objects of the A class can be written with two function calls: <code>A_fixed_put()</code> for the fixed size portion and <code>A_s_put()</code> for the variable length field of type string <code>s</code>.  Similarly, the objects of this class can be read with two function calls: <code>A_fixed_get()</code> and <code>A_s_get()</code>.</p>
                <p>The following code snippet illustrates the  use of the fixed length structures and the <code>fixed_get()</code> function:</p>
                <div class="code-block"><pre>&#160;
    int main(int argc, char* argv[])
    {
        MCO_RET rc;
        ...
        mco_trans_h t;
        mco_cursor_t csr; /* cursor to navigate database contents */
        A        a;   /* object handle */
        A_fixed _a;   /* fixed size part of class A */
        B        b;   /* struct handle */
        B_fixed _b;   /* fixed size part of class B */
        uint1  ui1;   /* value place holders */
        uint2  ui2;
        ...
    &#160;
        /* Open a READ_ONLY transaction, read object A and display its contents */
        rc = mco_trans_start(connection, MCO_READ_ONLY, MCO_TRANS_FOREGROUND, &amp;t);
        if ( MCO_S_OK == rc ) 
        {
            rc = A_list_cursor(t, &amp;csr);
            if ( MCO_S_OK == rc ) 
            {
                A_from_cursor(t, &amp;csr, &amp;a);
                A_fixed_get(&amp;a, &amp;_a);
                A_s_get( &amp;a, buf, sizeof(buf), &amp;ui2 );
                printf("\n\tContents of record A: s (%s), ui1 = %d, b.i1 = %d\n",
                    buf, _a.ui1, _a.b.i1 );
            }
        }
        rc = mco_trans_commit( t );
    }
    &#160;</pre>
                </div>
                <h2>Nullable Fields</h2>
                <p>If a scalar class element (<code>int, float, double</code>) has been declared <code>nullable</code> in the database schema, the following interfaces are generated:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_indicator_get( classname *handle, uint1 *result );
    &#160;</pre>
                </div>
                <p>The argument <code>result</code> will have a value of 1 upon return if the field is <code>null</code>, otherwise <code>result</code> will be 0.</p>
                <div class="code-block"><pre>    &#160;
    MCO_RET  classname_fieldname_indicator_put( classname *handle, uint1 value);
    &#160;</pre>
                </div>
                <p>Pass a <code>value</code> of 1 to set the null indicator, 0 to clear the null indicator.</p>
                <blockquote>
                    <p>
                        <img src="../../../Resources/Images/note.png" /> Note	that setting or clearing the null indicator has no effect on the underlying field’s value.  In other words, if a <code>nullable uint2</code> field has a value of 5 and <code>&lt;classname_fieldname&gt;_indicator_put( h, 1 )</code> is called for the field, it will still have a value of 5 after the call.</p>
                </blockquote>
                <p>&#160;</p>
                <p>For fields of all types, the respective forms of <code>&lt;classname_fieldname&gt;_get()</code> can return <code>MCO_S_NULL_VALUE</code>. <code>&lt;classname&gt;_fixed_get()</code> can also return <code>MCO_S_NULL_VALUE</code>, indicating that one or more constituent fields are null; a further examination with <code>&lt;classname_fieldname&gt;_indicator_get()</code> will be necessary to determine which field(s) are null.</p>
                <p>Please see the <a href="Nullable_Fields_And_Indexes.htm">Nullable Fields and Indexes</a> page for an explanation of the behavior of nullable fields included in indexes.</p>
                <h2>Checkpoint and Size</h2>
                <p>When an indexed field is modified by a transaction, the object is removed from all indexes defined for that class. Regardless of the whether the modified field is present in other indexes. Once the object is removed from indexes, there is no way to locate the object based on any search function. The object is put back into the indexes upon the transaction commit.</p>
                <p>The <code>_checkpoint()</code> API is the only way to put the object back into indexes within the transaction and thus make it visible through search functions.</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_checkpoint ( /*IN*/ classname *handle);
    &#160;</pre>
                </div>
                <p>If a unique index constraint is violated, <code>_checkpoint()</code> will return status code <code>MCO_S_DUPLICATE</code>. </p>
                <p>For fields of type <code>string</code> and <code>vector</code>, an additional <code>_size()</code> function is generated to return the actual length of the string value or the number of elements in the vector, so that you can allocate space for it:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_size( /*IN*/ classname *handle, /*OUT*/ uint2 *size);
    &#160;</pre>
                </div>
                <h2>Autocompaction of dynamic objects</h2>
                <p>If a class contains dynamically extended components (fields of type <code>vector</code> or <code>string</code>), an object of this class that is frequently updated can develop memory holes. To prevent this kind of fragmentation, an <i>autocompaction</i> feature is provided. To enable autocompaction, specify a non-zero value for the database parameter <code>autocompact_threshold</code> in the <code><a href="../../../Programming/C/Structures/Database_Parameters.htm">mco_db_params_t</a></code> passed into <code><a href="../../../Programming/C/Core_Functions/Static/Database_Control/open_dev.htm">mco_db_open_dev()</a></code>.</p>
                <p>If the size of an object exceeds this <code>autocompact_threshold</code> value, then the autocompaction algorithm reallocates objects, eliminating any internal fragmentation. However, note that object compaction is not a cheap operation, and should not be performed frequently. So a recommended value for this threshold is a number of bytes several kilobytes larger than a normal object’s expected size.</p>
                <h2>Vectors and Fixed-length Arrays</h2>
                <p><i>e</i>X<i>treme</i>DB <code>vectors</code> are by definition of variable length, whereas <code>arrays</code> are fixed length. For C applications, vectors and fixed-length arrays require a number of special functions. Fixed-length <code>arrays</code> are given the specified number of bytes of static memory in the record layout, but <code>vector</code> fields are initially just references that must be allocated storage at runtime. The <code>_alloc()</code> function reserves space for the <code>vector</code> field’s elements within a data layout. The application must call the <code>_alloc()</code> function to supply the size of the <code>vector</code> before values can be stored in the <code>vector</code> field.  Otherwise the <code>vector</code> reference will remain <code>null</code>. Invoking the <code>_alloc()</code> function for a <code>vector</code> field of an existing object will resize the <code>vector</code>.  If the new size is less than the current size the <code>vector</code> is truncated to the new size.</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_alloc( /*IN*/ classname *handle, /*IN*/ uint2 size);
    &#160;</pre>
                </div>
                <p>The  functions that operate on <code>vector</code> and <code>array</code> fields require an index argument but are otherwise functionally equivalent to their scalar counterparts. The <code>_put()</code> function for fields declared as <code>vector</code> or fixed-size <code>array</code> have the form:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_put( /*IN*/ classname *handle, /*IN*/ uint2 index, /*IN*/ &lt;type&gt; value);
    &#160;</pre>
                </div>
                <p>Fields declared as <i>vectors of strings</i> have the form:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_put( /*IN*/ classname *handle, /*IN*/ uint2 index,
                        /*IN*/ const char * value, /*IN*/ uint2 len);
                        &#160;</pre>
                </div>
                <p>For convenience, <code>_put_range()</code> methods are generated to assign an array of values to a <code>vector</code> or <code>array</code>. (Note that the size of the IN array should be less than or equal to the size of the <code>vector</code> as specified in the vector’s <code>_alloc()</code> function call, or the size of the <code>array</code> as defined in the <code>&lt;classname_fieldname&gt;_size</code> constant in the generated header file.</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_put_range( /*IN*/ classname *handle, /*IN*/ uint2 start_index,
                            /*IN*/ uint2 num, /*IN*/ const &lt;type&gt; *src );
                            &#160;</pre>
                </div>
                <p>Note that <code>_put_range()</code> methods are only generated for <code>vectors</code> that consist of simple scalar elements. For <i>vectors of structures</i> and <i>vectors of strings</i> this method is not generated. The reason is that for simple type <code>vector</code> elements the schema compiler can generate optimized methods to assign values to them. This optimization is only possible if the size of the vector element is known at compile time. Also note that it is never necessary to use a <code>_put_range()</code> method to set the <code>vector</code>; the <code>_put()</code> function can always be iterated to assign individual <code>vector</code> element values for the desired range.</p>
                <p>To access a specific element of a vector  the <code>_at()</code> function is generated.  The form of the <code>_at()</code> function will vary depending on the type of elements stored in the <code>vector</code>.  For <code>vectors</code> of fixed-length fields it will have the form:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_at( /*IN*/ classname *handle, /*IN*/ uint2 index, /*OUT*/ &lt;type&gt; *result );
    &#160;</pre>
                </div>
                <p>If the vector consists of <code>strings</code> or <i>fixed length byte-arrays</i> (<code>char&lt;n&gt;</code>), the <code>_at()</code>  function takes two extra parameters: the maximum size of the buffer to receive the string and the actual length of the string returned:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_at( /*IN*/ classname *handle, /*IN*/ uint2 index,
                        /*OUT*/ char *result, /*IN*/ uint2 bufsize,
                        /*OUT*/ uint2 *len);
                        &#160;</pre>
                </div>
                <p>When allocating memory (for host variables) for <code>vectors</code> of variable length elements, it may be necessary to first determine the actual size of the vector element.  The <code>_at_len()</code> functions are generated for vectors of strings for this purpose:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_at_len( /*IN*/ classname, /*IN*/ uint2 pos, /*OUT*/ uint2 *retlen);
    &#160;</pre>
                </div>
                <p>The <code>_get_range()</code> function returns a range of <code>vector</code> elements, for <i>vectors of scalar elements</i>:</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_get_range( /*IN*/ classname, /*IN*/ uint2 startIndex,
                            /*IN*/ uint2 num, /*OUT*/ const &lt;type&gt; *dest);
                            &#160;</pre>
                </div>
                <p>The <code>_erase()</code> function is generated for <i>vectors of structures</i>, <i>vectors of strings</i>, as well as for <i>optional struct</i> fields. The <code>_erase()</code> function removes an element of a <code>vector</code> from the layout and from all indexes the element is included in. Note that the <code>vector</code> size remains unchanged. If an attempt is made to get the erased element, the runtime returns a <code>null</code> pointer and <code>MCO_S_OK</code>. (Also note that the <code>_erase()</code> function is only generated for <i>vectors of structures</i>, not for <code>vectors</code> of basic types.  For <code>vectors</code> of basic types, the application should <code>_put()</code> a recognizable value in the <code>vector</code> element that it can interpret as <code>null</code>.)</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_erase( /*IN*/ classname *handle, /*IN*/ uint2 index);
    &#160;</pre>
                </div>
                <p>The use of the <code>_erase()</code> function can leave unused elements (“holes”) in <code>vector</code> fields.  For this reason, the <code>_pack()</code> function is generated for <code>vector</code> fields to remove “holes” so that the space occupied by the deleted element is returned to the free database memory pool.</p>
                <p>Likewise, if an application had a non-empty <code>string</code> allocated and then modified the <code>string</code> value to <code>null</code>, the <code>_size()</code> function would return 0, but the actual space for the string would not be automatically reclaimed. The application needs to call the generated <code>_pack()</code> function to return that space to the storage pool.</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_pack ( /*IN*/ classname *handle, /*OUT*/ uint4 pages_released );
    &#160;</pre>
                </div>
                <h2><a name="kanchor27"></a>Character string collation</h2>
                <p>The <i>e</i>X<i>treme</i>DB<a name="kanchor28"></a> core and UDA programming interfaces for C applications include support for collations.  A collation, as defined in Wikipedia, “is the assembly of written information into a standard order. One common type of collation is called alphabetization, though collation is not limited to ordering letters of the alphabet.”  </p>
                <p>Collation is implemented as a set of rules for comparing characters in a character set. A character set is a set of symbols with assigned ordinals that determine precise ordering.  For example, in the segment of the Italian alphabet consisting of the letters “a, a`, b, c, d, e, e`, f” the letters could be assigned the following ordinals: a=0, a`=1, b=2, c=3, d=4, e=5, e`=6, f=7.  This mapping will assure that the letter “a`” (“accented a”) will be sorted after “a” but before “b”, and “e`” will follow “e” but precede “f”.</p>
                <p>In some character sets, multiple-character combinations like “AE” (“labor lapsus” in the Danish and Norwegian alphabets or “ash” in Old-English) and “OE” (an alternate form of “Ö” or “O-umlaut” in the German alphabet) are treated as single letters.  This poses a collation problem when strings containing these character combinations need to be ordered.  Clearly, a collation algorithm to sort strings of these character sets must compare more than a single character at a time.</p>
                <p>“Capitalization” is also a collation issue.  In some cases strings will be compared in a “case sensitive” manner where for example the letters “a-z” will follow the (uppercase) letter “Z”, while more often strings will be compared in a “case insensitive” manner where “a” follows “A”, “b” follows “B”, etc.  This can be easily accomplished by treating uppercase and lowercase versions of each letter as equivalent, by converting upper to lower or vice versa before comparing strings, or by assigning them the same ordinal in a case-insensitive character set.</p>
                <p><i>e</i>X<i>treme</i>DB enables comparison of strings using a variety of collations, and to mix strings and character arrays with different character sets or collations in the same database; character sets and collations are specified at the application level.</p>
                <h3>Collation Data Definition Language and API function definitions</h3>
                <p>As explained in page <a href="../Features/Collations.htm">Custom Collations</a>, <i>e</i>X<i>treme</i>DB <a href="../../../Programming/C/DDL.htm">DDL</a> language provides a collation declaration for <code>tree</code> and <code>hash</code> indexes on string-type fields as follows:</p>
                <div class="code-block"><pre>&#160;
    [unique] tree&lt;string_field_name_1 [collate C1] 
            [, string_field_name_2 [collate C2]], …&gt; index_name;
&#160;
    hash&lt;string_field_name_1 [collate C1]
            [, string_field_name_2 [collate C2]], …&gt; index_name;
            &#160;</pre>
                </div>
                <p>If a collation is not explicitly specified for an index component, the default collation is used.  Based on the <a href="../../../Programming/C/DDL.htm">DDL</a> declaration, for each collation the <a href="../../../Programming/C/DDL.htm">DDL</a> compiler will generate the following compare function placeholders for tree indexes and/or hash indexes using this collation:</p>
                <div class="code-block"><pre>&#160;
    int2  collation_name_collation_compare( mco_collate_h c1, uint2 len1,
                            mco_collate_h c2, uint2 len2 );
    {
        /* TODO: add your implementation here */
        return 0;
    }
    &#160;
    uint4 collation_name_collation_hash (mco_collate_h c, uint2 len)
    {
        /* TODO: add your implementation here */
        return 0;
    }
    &#160;</pre>
                </div>
                <p>For each defined collation, a separate API is generated. The actual implementation of the compare functions, including the definition of character sets, is the application’s responsibility.  To facilitate compare function implementation, <i>e</i>X<i>treme</i>DB provides the following set of functions:</p>
                <div class="code-block"><pre>&#160;
    mco_collate_get_char(mco_collate_h s, char *buf, uint2 len);
    mco_collate_get_nchar(mco_collate_h s, nchar_t *buf, uint2 len);
    mco_collate_get_wchar(mco_collate_h s, wchar_t *buf, uint2 len);
    mco_collate_get_char_range(mco_collate_h s, char *buf,
    uint2 from, uint2 len);
    mco_collate_get_nchar_range(mco_collate_h s, nchar_t *buf,
        uint2 from, uint2 len);
    mco_collate_get_wchar_range(mco_collate_h s, wchar_t *buf,
        uint2 from, uint2 len);
        &#160;</pre>
                </div>
                <p>Note that three different versions of the <code>mco_collate_get_*char()</code> and <code>mco_collate_get_*char_range()</code> functions are required because, in order to use the same collation, the arguments must be of the corresponding type for the field being accessed.  In other words:  for fields of type <code>string</code> and <code>char&lt;n&gt;</code>, the *char version (<code>mco_collate_get_char()</code>) will be called; for fields of type <code>nstring</code> and <code>nchar&lt;n&gt;</code>, the <code>*nchar</code> version; and for fields of type <code>wstring</code> and <code>wchar&lt;n&gt;</code>, the <code>*wchar()</code> version.</p>
                <p>The C application registers user-defined collations via the following function:</p>
                <div class="code-block"><pre>&#160;
    mco_db_register_collations(dbname, mydb_get_collations());
    &#160;</pre>
                </div>
                <p>This function must be called prior to <code>mco_db_connect()</code> or <code>mco_db_connect_ctx()</code> and must be called once for each process that accesses a shared memory database.  The second argument <code>mydb_get_collations()</code> is a database specific function similar to <code>mydb_get_dictionary()</code> that is generated by the <a href="../../../Programming/C/DDL.htm">DDL</a> compiler in the files <code>mydb.h</code> and <code>mydb.c</code>.  In addition, the <a href="../../../Programming/C/DDL.htm">DDL</a> compiler generates the collation compare function stubs in <code>mydb_coll.c</code>.  (Note that if the file <code>mydb_coll.c</code> already exists, the <a href="../../../Programming/C/DDL.htm">DDL</a> compiler will display a warning and generate <code>mydb_coll.c.new</code> instead.)</p>
                <p>Please see page <a href="../Features/Collations.htm">Custom Collations</a> for further details and examples using custom collations.</p>
                <h2>Blob Support</h2>
                <p>BLOB fields are useful when it is necessary to keep streaming data, with no known size limits. C applications use the generated <code>_get()</code> function to copy BLOB data to an application’s buffer; it allows specification of a starting offset within the BLOB.</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_get( /*IN*/ classname *handle, /*IN*/ uint4 startOffset,
                        /*OUT*/ char *buf, /*IN*/ uint4 bufsz,
                        /*OUT*/ uint4 *len);
                        &#160;</pre>
                </div>
                <p>The <code>bufsz</code> parameter is the size of the buffer passed by the application in the <code>buf</code> parameter. The <code>len</code> output parameter is the actual number of bytes copied to the buffer (which will be <code>&lt;= bufsz</code>).</p>
                <p>The <code>_size()</code> function returns the size of a BLOB field. This value can be used to allocate sufficient memory to hold the BLOB, prior to calling the <code>_get()</code> function.</p>
                <div class="code-block"><pre>    &#160;
    MCO_RET classname_fieldname_size( /*IN*/ classname *handle, /*OUT*/ uint4 * result);
    &#160;</pre>
                </div>
                <p>The <code>_put()</code> function populates a BLOB field, possibly overwriting prior contents. It allocates space and copies data from the application’s buffer; the size of the BLOB must be specified.</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_put( /*IN*/ classname *handle, /*IN*/ const void *from,
                        /*IN*/ uint4 nbytes);
                        &#160;</pre>
                </div>
                <p>The <code>_append()</code> function is used to append data to an existing BLOB. This method is provided so an application does not have to allocate a single buffer large enough to hold the entire BLOB, but rather can conserve memory by writing the BLOB in manageable pieces.</p>
                <div class="code-block"><pre>&#160;
    MCO_RET classname_fieldname_append(/*IN*/ classname *handle, /*IN*/ const void * from,
                        /*IN*/ uint4 nbytes );
                        &#160;</pre>
                </div>
                <p>To erase (truncate) a BLOB, pass a size of 0 to the <code>_put()</code> method.</p>
                <h2>Binary Data</h2>
                <p>While <code>blob</code> fields are useful for large binary data, they are intended only for large data fields (greater than 1 Kb). It is recommended to use <code>string</code> fields for character or binary data (less than 64 Kb). <code>String</code> fields can hold arbitrary binary data when not used for indexes (because index comparisons require a null terminator). Bu unlike&#160;<code>blob</code>&#160;fields,&#160;<code>binary</code>&#160;and&#160;<code>varbinary</code>&#160;fields can be added to both simple and compound indexes.</p>
                <h2>Date, Time and Datetime Fields</h2>
                <p>Please refer to the <a href="../Datetime_Fields.htm">Datetime FIelds</a> page for a detailed description of the <i>e</i>X<i>treme</i>DB <code>date</code>, <code>time</code> and <code>datetime</code> database field types. The C APIs for determining precision and accessing <code>date</code>, <code>time</code> and <code>datetime</code> fields are described in the <a href="../Datetime_Fields/Datetime_C.htm">Managing Datetime Fields in C</a> page.</p>
            </blockquote>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../../../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>