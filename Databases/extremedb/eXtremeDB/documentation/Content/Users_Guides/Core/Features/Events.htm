<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="[%=System.LinkedTitle%]|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Database Events</title>
        <link href="../../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <script src="../../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <div class="TopicContent">
                <h1>Database Events</h1>
                <blockquote>
                    <p>Event statements declare the events that the application will be notified of, such as: adding a <b>new</b> object, <b>deleting</b> an object, <b>updating</b> an object or a specified field of an object (with the exception of array, <code>vector</code> and <code>blob</code> fields and elements of inner structures), and <b>checkpoint</b> events. (Checkpoint events are triggered only by explicitly calling a checkpoint API.) Events are specific to classes, so only those classes that have events defined will cause notifications to be fired.</p>
                    <p>Database events can be handled synchronously or asynchronously by the application.</p>
                    <h2>Asynchronous Event Handling</h2>
                    <p>In asynchronous event handling, the application spawns a separate thread to handle each type of event.  In C and C++ applications this event thread calls function <code><a href="../../../Programming/C/Core_Functions/Static/Events/wait.htm">mco_async_event_wait(</a>)</code> to wait for the specified event. Java, Python and C# applications call the <i>Connection</i> method <code>WaitEvent()</code>. When the event occurs, the <i>e</i>X<i>treme</i>DB<a name="kanchor7"></a> runtime releases the thread. Upon releasing the thread, the runtime continues normal processing, so the handler thread runs in parallel with other threads, until it completes its processing and again calls <code><a href="../../../Programming/C/Core_Functions/Static/Events/wait.htm">mco_async_event_wait()</a></code> or <code>WaitEvent()</code>.</p>
                    <p>There is a small window of possibility for another instance of  the event to occur before the event handler has completed its task and calls <code>WaitEvent()</code> or <a href="../../../Programming/C/Core_Functions/Static/Events/wait.htm"><code>mco_async_event_wait()</code></a> again to wait on the event (events are not queued). This window can be minimized if the handler delegates the processing of the event to yet another thread, allowing the handler thread to immediately wait on the event again.  If this risk of an unhandled event cannot be tolerated, either a <i>synchronous</i> event handler can be used, the application can maintain a separate table of unhandled events, or the <code>mco_trans_play()</code> function of the <a href="../../Transaction_Logging.htm"><i>e</i>X<i>treme</i>DB<i> Transaction Logging</i> feature</a> can be employed.  Asynchronous events are activated after the transaction commits.  If, within the scope of a single transaction, several objects are added, or deleted, or several fields are updated which have event handlers waiting, all the handlers will be activated simultaneously.</p>
                    <p>A C or C++ application will define event handlers like the following:</p>
                    <div class="code-block"><pre>&#160;
    /* Thread function that handles the &lt;new&gt; event. */
    void NewEventHandler( sample_task_t * descriptor )
    {
        mco_db_h db = descriptor-&gt;db_connection;
        while ( MCO_S_OK == mco_async_event_wait(db, MCO_EVENT_newEvent) ) 
        {
            /* Process the event. */
            ...
        }
    }
&#160;
    /* Thread function that handles the &lt;update&gt; event. */
    void UpdateEventHandler( sample_task_t * descriptor )
    {
        mco_db_h db = descriptor-&gt;db_connection;
        while ( MCO_S_OK == mco_async_event_wait(db, MCO_EVENT_updateEvent) ) 
        {
            /* Process the event. */
            ...
        }
    }
&#160;
    /* Thread function that handles the &lt;delete&gt; event. */
    void DeleteEventHandler( sample_task_t * descriptor )
    {
        mco_db_h db = descriptor-&gt;db_connection;
        while ( MCO_S_OK == mco_async_event_wait(db, MCO_EVENT_deleteEvent) ) 
        {
            /* Process the event. */
            ...
        }
    }
&#160;
    /* Thread function that handles the &lt;update&gt; event. */
    void CheckpointEventHandler( sample_task_t * descriptor )
    {
        mco_db_h db = descriptor-&gt;db_connection;
&#160;
        while ( MCO_S_OK == mco_async_event_wait(db, MCO_EVENT_checkpointEvent) ) 
        {
            /* Process the event. */
            ...
        }
    }
    &#160;</pre>
                    </div>
                    <p>Then the C/C++ application will start the event handler threads and cause the main application thread to sleep for some milliseconds (100 is usually adequate) in order for the event handler threads to start listening (waiting). Then the main application thread will proceed with normal database processing. When terminating, the C/C++ application will call <code>mco_async_event_release_all()</code> to release all events and then stop the event handler threads. (See the SDK sample <a href="../../../Programming/C/SDK_Samples/Core_Samples/10-Events_Asynch.htm">samples/native/core/10-events/asynch</a> for implementation details.)</p>
                    <p>Java and C# applications will similarly start individual threads to handle each event with a <i>ThreadProc</i> like the following:</p>
                    <div class="code-block"><pre>&#160;
    private class ThreadParams
    {
        public Connection con;
        public string event_name;
        &#160;
        public ThreadParams(Connection con, string EventName)
        {
            this.con = con;
            this.event_name = EventName;
        }
    }
&#160;
    private static void ThreadProc(object param)
    {
        ThreadParams tp = (ThreadParams)param;
        try
        {
            while (!exit)
            {
                tp.con.WaitEvent(tp.event_name);
            }
        }
        catch (DatabaseError x)
        {
            if (x.errorCode &gt;= 50)
            {
                // Errors
            }
            else
            {
                // Normal return codes including MCO_S_EVENT_RELEASED
            }
        }
    }
    &#160;</pre>
                    </div>
                    <p>C# and Java applications will then cause the main application thread to sleep for some milliseconds as explained above, then proceed with normal database processing. When terminating, the application will call the <i>Connection</i> method <code>ReleaseAllEvents()</code> and then stop the event handler threads. (See the SDK sample <a href="../../../Programming/Java/SDK_Samples/Core/events_asyncbasic.htm">samples/java/events/asyncbasic</a> or <a href="../../../Programming/Csharp/SDK_Samples/Core_Samples/AsyncEvent.htm">samples/csharp/AsyncEvent</a> for further implementation details.) C# applications can also handle asynchronous events through the <i>Delegates</i> mechanism by adding handlers to the <i>Connection</i> properties <code>AsynchEvent</code> and <code>AsyncEventError</code> and then calling method <code>StartEventListeners()</code>. (See the SDK sample <a href="../../../Programming/Csharp/SDK_Samples/Core_Samples/AsyncDelegate.htm">samples/csharp/events/AsyncDelegate</a> for further implementation details.)</p>
                    <h2>Synchronous Event Handling</h2>
                    <p>C and C++ applications can also respond to <i>e</i>X<i>treme</i>DB events synchronously, however this capability is not available for Java and C# applications. Synchronous event handlers are called within the context of the same thread that caused the event.  Care should be taken in event handlers not to cause extraordinary delays because the handler has control of a transaction that, by definition, is a <code>READ_WRITE</code> transaction and thus could block access to the database. Specifically, the handler should not wait on an indeterminate external event such as user input.</p>
                    <p>A synchronous handler returns <code>MCO_S_OK</code> to indicate successful completion; any other value (one of <code>MCO_S_*</code> or <code>MCO_E_*</code> constants defined in <code>mco.h</code>, or a user-defined value) indicates success or failure with additional information. <i>e</i>X<i>treme</i>DB returns this value to the application, which can act on it accordingly (rolling back the transaction if necessary).</p>
                    <p>Synchronous handlers are registered by calling the generated <code><a href="../../../Programming/C/Core_Functions/Generated/Event/register_handler_add_delete.htm">mco_register_<i>&lt;eventname</i>&gt;_handler()</a></code> function for each event handler. Any number of handlers can be registered for a single event type, but the order in which they are called cannot be predicted.  At registration, the application can pass a user-defined parameter that will be, in turn, passed to the event handler when it is invoked.  This parameter is a void pointer that can reference a simple scalar value or a complex data structure depending on the application requirements.</p>
                    <p>For <b>new</b> events, synchronous handlers are called by the <code><i><a href="../../../Programming/C/Core_Functions/Generated/Class/new.htm"><i>classname</i>_new()</a></i></code> or <code><i><a href="../../../Programming/C/Core_Functions/Generated/Class/new_oid.htm"><i>classname</i>_oid_new()</a></i></code>method immediately after the object is instantiated (so the object handle is guaranteed to be valid).  For <b>checkpoint</b> events, synchronous handlers are called by the <code><a href="../../../Programming/C/Core_Functions/Generated/Class/checkpoint.htm">classname_checkpoint()</a></code> method immediately before or after the object is inserted into indexes – the application specifies whether the handler will be invoked before or after inserting into indexes through the handler registration interface.  Checkpoint events are not fired by <code><a href="../../../Programming/C/Core_Functions/Static/Transaction_Control/commit.htm">mco_trans_commit()</a></code>, though this function also updates the index(es). For <b>delete</b> events, synchronous handlers are called by the <code><i>c<a href="../../../Programming/C/Core_Functions/Generated/Class/delete.htm"><i>lassname</i>_delete()</a></i></code> method before the object is deleted (while the object handle is still valid).</p>
                    <p>
                        <img src="../../../Resources/Images/note.png" />Note that	<b>delete</b> events are not invoked by the <code><i><a href="../../../Programming/C/Core_Functions/Generated/Class/delete_all.htm"><i>classname</i>_delete_all()</a></i></code> method. Only <code><i><a href="../../../Programming/C/Core_Functions/Generated/Class/delete.htm"><i>classname</i>_delete()</a></i></code> will invoke these events.</p>
                    <p><b>Update</b> events can be defined for a class (i.e. all fields of that class) or for a specific field of a class by specifying the field name in the event declaration.  As with checkpoint events, the application must specify through the handler registration interface whether the handler will be invoked before or after a field is updated.  Update handlers are activated by the interface methods that cause a field’s contents to change, for example <code><i><a href="../../../Programming/C/Core_Functions/Generated/Field/Scalar/put.htm"><i>classname_fieldname</i>_put()</a></i></code>.  If the event handler is called before the update and the handler invokes <code><i><a href="../../../Programming/C/Core_Functions/Generated/Field/Scalar/get.htm"><code><i>classname_fieldname</i>_get()</code></a></i></code> on the field, it will retrieve the current value in the database. Conversely, if the event is called after the update, the handler will retrieve the value the application just put in the database.  The user-defined parameter can be used to provide additional information to the handler such as the incoming value for a before-event handler or the old value for an after-event handler.</p>
                    <p>
                        <img src="../../../Resources/Images/note.png" />Note that both synchronous and asynchronous events can be applied to any given event. When using eXtremeDB in Shared Memory, Synchronous event handlers must belong to the same process that caused the event. So do not register a synchronous event handler for class Alpha in process A if it is possible that process B will insert/update/delete Alpha objects. Use an asynchronous event handler, instead.</p>
                    <p>
                        <img src="../../../Resources/Images/note.png" />Note that for <b>update</b> events, a class-wide event cannot be combined with field update events for the same class.</p>
                    <h2>Example</h2>
                    <p>The following code fragments illustrate event handling.  Consider the following schema DDL definition for a class with event notifications:</p>
                    <div class="code-block"><pre><a name="kanchor8"></a>&#160;
    class dropped_call
    {
        uint4 trunk_id;
        ...
&#160;
        autoid[10000];
        event &lt; trunk_id update &gt; upd_trunk; // any name will do
        event &lt; new &gt; add_trunk;
        event &lt; checkpoint &gt; checkpoint_trunk;
        event &lt; delete &gt; del_trunk;
    };
    &#160;</pre>
                    </div>
                    <p>The schema compiler will generate the following definitions in the interface header file:</p>
                    <div class="code-block"><pre>&#160;
    #define MCO_EVENT_upd_trunk 15
    // 15 is only illustrative; the actual value is not important
    typedef MCO_RET (*mco_upd_trunk_handler)( /*IN*/ mco_trans_h *t,
                /*IN*/ dropped_call *handle,
                /*IN*/ MCO_EVENT_TYPE et,
                /*INOUT*/ void *param );
    MCO_RET mco_register_upd_trunk_handler( /*IN*/ mco_trans_h *t,
                /*IN*/ mco_upd_trunk_handler handler,
                /*IN*/ void *param,
                /*IN*/ MCO_HANDLING_ORDER when);
    MCO_RET mco_unregister_upd_trunk_handler( /*IN*/ mco_trans_h *t,
                /*IN*/ mco_upd_trunk_handler handler);
                &#160;
    #define MCO_EVENT_add_trunk 16
    typedef MCO_RET (*mco_add_trunk_handler)( /*IN*/ mco_trans_h *t,
                /*IN*/ dropped_call *handle,
                /*IN*/ MCO_EVENT_TYPE et,
                /*INOUT*/ void *param );
    MCO_RET mco_register_add_trunk_handler( /*IN*/ mco_trans_h *t,
                /*IN*/ mco_add_trunk_handler handler,
                /*IN*/ void *param);
    MCO_RET mco_unregister_add_trunk_handler( /*IN*/ mco_trans_h *t,
                /*IN*/ mco_add_trunk_handler handler);
    &#160;
    #define MCO_EVENT_checkpoint_trunk 17
    typedef MCO_RET (*mco_checkpoint_trunk_handler)( /*IN*/ mco_trans_h *t,
                /*IN*/ dropped_call *handle,
                /*IN*/ MCO_EVENT_TYPE et,
                /*INOUT*/ void *param );
    MCO_RET mco_register_checkpoint_trunk_handler( /*IN*/ mco_trans_h *t,
                /*IN*/ mco_checkpoint_trunk_handler handler,
                /*IN*/ void *param,
                /*IN*/ MCO_HANDLING_ORDER when);
    MCO_RET mco_unregister_checkpoint_trunk_handler(/*IN*/ mco_trans_h *t,
                /*IN*/ mco_checkpoint_trunk_handler handler);
                &#160;
    #define MCO_EVENT_del_trunk 18
    typedef MCO_RET (*mco_del_trunk_handler)( /*IN*/ mco_trans_h *t,
                /*IN*/ dropped_call *handle,
                /*IN*/ MCO_EVENT_TYPE et,
                /*INOUT*/ void *param );
    MCO_RET mco_register_del_trunk_handler( /*IN*/ mco_trans_h *t,
                /*IN*/ mco_del_trunk_handler handler,
                /*IN*/ void *param);
    MCO_RET mco_unregister_del_trunk_handler( /*IN*/ mco_trans_h *t,
                /*IN*/ mco_del_trunk_handler handler);
&#160;</pre>
                    </div>
                    <p>To employ an asynchronous handler for one of the events above, the C/C++ application would start a thread and, within the thread function, call:</p>
                    <div class="code-block"><pre>&#160;
    mco_async_event_wait( dbh, MCO_EVENT_upd_trunk );
    &#160;</pre>
                    </div>
                    <p>Where <code>dbh</code> is the database handle from the <code><a href="../../../Programming/C/Core_Functions/Static/Database_Control/connect.htm">mco_db_connect()</a></code> call and <code>upd_trunk</code> is the value defined in the generated interface file to reference the event of interest. Java and C# applications will start a thread and call the <i>Connection</i> method <code>WaitEvent()</code>.</p>
                    <p>As previously mentioned, this thread will block (wait) until released by the <i>e</i>X<i>treme</i>DB runtime.  It can be released either by an occurrence of the event, or the C/C++ application can release it forcibly by calling one of the following:</p>
                    <div class="code-block"><pre>&#160;
    mco_async_event_release( dbh, upd_trunk );
    &#160;
    mco_async_event_release_all_( dbh );
    &#160;</pre>
                    </div>
                    <p>A C/C++ event handler will know if it was released by an occurrence of the event or by a <code>release()</code> function by the return value of <code><a href="../../../Programming/C/Core_Functions/Static/Events/wait.htm">mco_async_event_wait()</a></code>. <code>MCO_S_OK</code> means the event happened; <code>MCO_S_EVENT_RELEASED</code> means the event was released. Java and C# event handlers will catch an exception with error code <code>MCO_S_EVENT_RELEASED</code> when the event is released.</p>
                    <p>For the preceding class definition and its generated interfaces, the following code fragments illustrate synchronous event handling. First, the C/C++ application must register its synchronous event handler functions with code like the following:</p>
                    <div class="code-block"><pre>&#160;
    int register_events(mco_db_h db)
    {
        MCO_RET rc;
        mco_trans_h t;
        &#160;
        mco_trans_start(db, MCO_READ_WRITE, MCO_TRANS_FOREGROUND, &amp;t);
        mco_register_add_trunk_handler(t, &amp;new_handler, (void*) 0);
        mco_register_checkpoint_trunk_handler(t, &amp;checkpoint_handler,
                    (void*) 0, MCO_BEFORE_UPDATE );
        mco_register_del_trunk_handler(t, &amp;delete_handler, (void *) 0);
        mco_register_upd_trunk_handler( t, &amp;update_handler1, 
                    (void *) 0, MCO_BEFORE_UPDATE );
        rc = mco_trans_commit(t);
    &#160;
        return rc;
    }
    &#160;</pre>
                    </div>
                    <p>The bodies of the C/C++ handler functions would look like the following:</p>
                    <div class="code-block"><pre>&#160;
    /* Handler for the "&lt;new&gt;" event. Reads the autoid and prints it out */
    MCO_RET new_handler( /*IN*/ mco_trans_h t,
                /*IN*/ dropped_call * obj,
                /*IN*/ MCO_EVENT_TYPE et,
                /*INOUT*/ void *param)
    {
        int8 u8;
        param = (int *)1;
        &#160;
        dropped_call_autoid_get( obj, &amp;u8 );
        printf( "Event \"Object New\" : object (%llu) is created\n", u8 );
        &#160;
        return MCO_S_OK;
    }
    &#160;
    /* Handler for the "&lt;checkpoint&gt;" event. Reads the autoid and prints it out */
    MCO_RET checkpoint_handler( /*IN*/ mco_trans_h t,
                    /*IN*/ dropped_call * obj,
                    /*IN*/ MCO_EVENT_TYPE et,
                    /*INOUT*/ void *param)
    {
        int8 u8;
        param = (int *)1;
        &#160;
        dropped_call_autoid_get( obj, &amp;u8 );
        printf( "Event \"Object Checkpoint\" : object (%ld,%ld) is about to be created\n", u8.lo, u8.hi );
&#160;
        return MCO_S_OK;
    }
    &#160;
    /* Handler for the "&lt;delete&gt;" event. Note that the handler
    * is called before the current transaction is committed.
    * Therefore, the object is still valid; the object handle
    * is passed to the handler and is used to obtain the
    * autoid of the object. The event's handler return value
    * is passed into the "delete" function and is later
    * examined by the mco_trans_commit(). If the value is
    * anything but MCO_S_OK, the transaction is rolled back.
    * In this sample every other delete transaction is
    * committed.
    */
    MCO_RET delete_handler(	/*IN*/ mco_trans_h t,
                /*IN*/ dropped_call * obj,
                /*IN*/ MCO_EVENT_TYPE et,
                /*INOUT*/ void *user_param)
    {
        int8 u8;
        &#160;
        dropped_call_autoid_get( obj, &amp;u8);
        printf( "Event \"Object Delete\": object (%ld,%ld) is being deleted...", u8.lo, u8.hi );
&#160;
        return (((u8.lo + u8.hi) %2) ? 1: MCO_S_OK);
    }
    &#160;
    /* Handler for the "update" event. This handler is called
    * before the update transaction is committed - hence the
    * value of the field being changed is reported unchanged
    * yet.
    */
    MCO_RET update_handler1( /*IN*/ mco_trans_h t,
                /*IN*/ dropped_call * obj,
                /*IN*/ MCO_EVENT_TYPE et,
                /*INOUT*/ void *param)
    {
        uint4 u4;
        int8 u8;
&#160;
        dropped_call_autoid_get( obj, &amp;u8);
        dropped_call_trunk_id_get(obj, &amp;u4);
        printf( "Event \"Object Update\" (before commit): object (%ld,%ld) value %d\n", u8.lo, u8.hi, u4 );
&#160;
        return MCO_S_OK;
    }
    &#160;</pre>
                    </div>
                    <p>When the C/C++ application is finished handling events, the events are unregistered by code like the following:</p>
                    <div class="code-block"><pre>&#160;
    int unregister_events(mco_db_h db)
    {
        MCO_RET rc;
        mco_trans_h t;
        &#160;
        mco_trans_start(db, MCO_READ_WRITE, MCO_TRANS_FOREGROUND, &amp;t);
        mco_unregister_add_trunk_handler( t, &amp; new_handler);
        mco_unregister_del_trunk_handler( t, &amp; delete_handler);
        mco_unregister_update_handler( t, &amp; update_handler1);
        rc = mco_trans_commit(t);
        &#160;
        return rc;
    }
    &#160;</pre>
                    </div>
                    <p>(See the SDK sample <a href="../../../Programming/C/SDK_Samples/Core_Samples/10-Events_Synch.htm">samples/native/core/10-events/synch</a> for further implementation details.)</p>
                </blockquote>
            </div>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../../../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>