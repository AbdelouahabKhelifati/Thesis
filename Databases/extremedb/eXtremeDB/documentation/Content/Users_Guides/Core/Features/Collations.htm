<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="[%=System.LinkedTitle%]|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Custom Collations</title>
        <link href="../../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <script src="../../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <div class="TopicContent">
                <h1>Custom Collations</h1>
                <blockquote>
                    <p>C and C++ applications include support for custom collations. In some character sets, multiple-character combinations like “AE” (“labor lapsus” in the Danish and Norwegian alphabets or “ash” in Old-English) and “OE” (an alternate form of “Ö” or “O-umlaut” in the German alphabet) are treated as single letters.  This poses a collation problem when strings containing these character combinations need to be ordered.  Clearly, a collation algorithm to sort strings of these character sets must compare more than a single character at a time. </p>
                    <p>“Capitalization” is also a collation issue.  In some cases strings will be compared in a “case sensitive” manner where for example the letters “a-z” will follow the (uppercase) letter “Z”, while more often strings will be compared in a “case insensitive” manner where “a” follows “A”, “b” follows “B”, etc.  This can be easily accomplished by treating uppercase and lowercase versions of each letter as equivalent, by converting upper to lower or vice versa before comparing strings, or by assigning them the same ordinal in a case-insensitive character set. (See page <a href="Case_Sensitivity.htm">Case Sensitivity</a> for an alternative method.)</p>
                    <p><i>e</i>X<i>treme</i>DB enables comparison of strings using a variety of collations, and to mix strings and character arrays with different character sets or collations in the same database; character sets and collations are specified at the application level.</p>
                    <p>The <i>e</i>X<i>treme</i>DB <a href="../../../Programming/C/DDL.htm">DDL</a> provides a <code>collation</code> declaration for  indexes on string-type fields as follows:</p>
                    <div class="code-block"><pre>&#160;
    [unique] tree&lt;string_field_name_1 [collate C1]
            [, string_field_name_2 [collate C2]], …&gt; index_name;
            &#160;
    hash&lt;string_field_name_1 [collate C1]
            [, string_field_name_2 [collate C2]], …&gt; index_name;
            &#160;</pre>
                    </div>
                    <p>If a collation is not explicitly specified for an index component, the default collation is used.  Based on the DDL declaration, for each collation the DDL compiler will generate the following compare function placeholders for tree indexes and/or hash indexes using this collation:</p>
                    <div class="code-block"><pre>&#160;
    int2  collation_name_collation_compare ( mco_collate_h c1, uint2 len1,
                    mco_collate_h c2, uint2 len2 );
    {
        /* TODO: add your implementation here */
        return 0;
    }
&#160;
    mco_hash_counter_t collation_name_collation_hash (mco_collate_h c, uint2 len)
    {
        /* TODO: add your implementation here */
        return (mco_hash_counter_t)0;
    }
    &#160;</pre>
                    </div>
                    <p>For each defined collation, a separate API is generated. The actual implementation of the compare functions, including the definition of character sets, is the application’s responsibility.  To facilitate compare function implementation, <i>e</i>X<i>treme</i>DB provides the following set of functions:</p>
                    <div class="code-block"><pre>&#160;
    mco_collate_get_char(mco_collate_h s, char *buf, uint2 len);
    mco_collate_get_nchar(mco_collate_h s, nchar_t *buf, uint2 len);
    mco_collate_get_wchar(mco_collate_h s, wchar_t *buf, uint2 len);
    mco_collate_get_char_range(mco_collate_h s, char *buf,
                uint2 from, uint2 len);
    mco_collate_get_nchar_range(mco_collate_h s, nchar_t *buf,
                uint2 from, uint2 len);
    mco_collate_get_wchar_range(mco_collate_h s, wchar_t *buf,
                uint2 from, uint2 len);
                &#160;</pre>
                    </div>
                    <p>Note that three different versions of the <code>mco_collate_get_*char()</code> and <code>mco_collate_get_*char_range()</code> functions are required because, in order to use the same collation, the arguments must be of the corresponding type for the field being accessed.  In other words:  for fields of type string and <code>char&lt;n&gt;</code>, the <code>*char</code> version <code>mco_collate_get_char()</code> will be called; for fields of type <code>nstring</code> and <code>nchar&lt;n&gt;</code>, the <code>*nchar</code> version; and for fields of type <code>wstring</code> and <code>wchar&lt;n&gt;</code>, the <code>*wchar()</code> version.</p>
                    <p>The C/C++ application registers user-defined collations via the following function:</p>
                    <div class="code-block"><pre>&#160;
    mco_db_register_collations(dbname, mydb_get_collations());
    &#160;</pre>
                    </div>
                    <p>This function must be called prior to <code><a href="../../../Programming/C/Core_Functions/Static/Database_Control/connect.htm">mco_db_connect()</a></code> or <code><a href="../../../Programming/C/Core_Functions/Static/Database_Control/connect_ctx.htm">mco_db_connect_ctx()</a></code> and must be called once for each process that accesses a shared memory database.  The second argument <code><i>mydb</i>_get_collations()</code> is a database specific function similar to <code><i>mydb</i>_get_dictionary()</code> that is generated by the DDL compiler in the files <code>mydb.h</code> and <code>mydb.c</code>.  In addition, the DDL compiler generates the collation compare function stubs in <code>mydb_coll.c</code>.  (Note that if the file <code>mydb_coll.c</code> already exists, the DDL compiler will display a warning and generate <code>mydb_coll.c.new</code> instead.)</p>
                    <p>
                        <img src="../../../Resources/Images/note.png" />Note: What is the difference between user-defined indexes and collations?</p>
                    <blockquote>
                        <p>User–defined indexes are implemented through user-defined compare and hash functions that are passed objects and can compare key fields any way they like.  However, collations can only be defined for character fields (<code>string, char&lt;&gt;, nstring, nchar&lt;&gt;, wstring and wchar&lt;&gt;</code>) and the key segments are compared in the sequence defined in the schema.</p>
                        <p>But collations are much simpler to implement.  Whereas user-defined indexes require object-to-object and object-to-key function implementations for tree indexes, and <i>hash_object</i> and <i>hash_external_key</i> function implementations for hash indexes, collations require a single compare function for each collation. Furthermore the same collation can be used in different classes and indexes. For example, for the case-insensitive collation it is necessary to implement a single function.</p>
                        <p>To summarize: collations are a better choice when the application needs to simply change how strings are sorted (compared) and user-defined indexes are appropriate for more complex user-defined data sort algorithms.</p>
                    </blockquote>
                </blockquote>
                <h2>Collation examples</h2>
                <blockquote>
                    <h3>Example 1</h3>
                    <p>File <code>schema1.mco</code>:</p>
                    <div class="code-block"><pre>    &#160;
    declare database mydb;
    &#160;
    class A 
    {
        string   name;
&#160;
        tree &lt;name collate Cname&gt; tname;
    };
    &#160;</pre>
                    </div>
                    <p>The key word <code>collate</code> declares that the tree index <code>tname</code> is to be generated on string field <code>name</code>, using collation <code>Cname</code><a name="kanchor1040"></a>.  This DDL instructs the database runtime to use a custom rule named <code>Cname</code> to compare the string field <code>name</code>. Note that the same collation (rule) can be used multiple times in the same index, in different indexes within the same class, or in different classes.</p>
                    <h3>Example 2</h3>
                    <p>File <code>schema2.mco</code>:</p>
                    <div class="code-block"><pre>&#160;
    declare database mydb;
    &#160;
    class A 
    {
        string   s;
        char&lt;20&gt; c;
&#160;
        tree &lt;s collate C1&gt; sidx;
        hash &lt;c collate C1&gt; cidx[1000]; /* CORRECT: string and char&lt;20&gt; can be
                                    used with the same collation C1 */
    };
&#160;
    class B 
    {
        string    s;
        nchar&lt;20&gt; nc;
&#160;
        tree&lt;s collate C1&gt; sidx;
        //  tree&lt;nc collate C1&gt; ncidx;     /* INCORRECT: string and nchar&lt;N&gt; can’t
                                be used with the same collation */
        tree&lt;nc collate C2&gt; ncidx2;    /* CORRECT – different collation, C2 */
    }
    &#160;</pre>
                    </div>
                    <p>Note that in class <i>A</i> the same collation (<code>C1</code>) can be used in a tree and hash index, and in class <i>B</i> a new collation (<code>C2</code>) must be defined because its base field <code>nc</code> is of type <code>nchar</code>.  To use the collation <code>C1</code> in the tree indexes, the application must implement a compare function with the following signature:</p>
                    <div class="code-block"><pre>    &#160;
    typedef int2 (*mco_compare_collation_f) ( mco_collate_h c1, uint2 len1, 
                mco_collate_h c2, uint2 len2);
                &#160;</pre>
                    </div>
                    <p>The parameters are collation descriptors (as strings) <code>c1</code> and <code>c2</code> and their lengths (number of symbols) <code>len1</code> and <code>len2</code>. The compare function must return an integer value indicating how the strings are compared: negative if <code>c1 &lt; c2</code>, zero if <code>c1 == c2</code> and positive if <code>c1 &gt; c2</code>.  This function is called by the runtime to compare field values in two objects as well as to compare the field value with an external key value.</p>
                    <p>If a collation is used in a hash index, as is <code>C1</code> in class <i>A</i>, the application must implement a hash function with the following signature:</p>
                    <div class="code-block"><pre>&#160;
    typedef uint4 (*mco_hash_collation_f) ( mco_collate_h c, uint2 len);
    &#160;</pre>
                    </div>
                    <p>The parameters are a descriptor <code>c</code> (as a string) and its length (number of symbols) <code>len</code>. The function must return an integer hash code for the string.  (Note that if the compare function returns zero for two strings X and Y, i.e. X is equal to Y, the hash function must generate the same hash code for X and Y.)</p>
                    <p>For the sample <code>schema2.mco</code>, the DDL compiler generates these compare function stubs in <code>mydb_coll.c</code>:</p>
                    <div class="code-block"><pre>&#160;
    /* collation compare function */
    int2  C1_collation_compare ( mco_collate_h c1, uint2 len1,
                mco_collate_h c2, uint2 len2)
    {
        /* TODO: add your implementation here */
        return 0;
    }
&#160;
    uint4 C1_collation_hash (mco_collate_h c, uint2 len)
    {
        /* TODO: add your implementation here */
        return 0;
    }
&#160;
    /* collation compare function */
    int2  C2_collation_compare ( mco_collate_h c1, uint2 len1,
                mco_collate_h c2, uint2 len2)
    {
        /* TODO: add your implementation here */
        return 0;
    }
    &#160;</pre>
                    </div>
                    <p>The DDL compiler also generates the function applications will use to register the specified collations with the <i>e</i>X<i>treme</i>DB database runtime in <code>mydb.h</code> and <code>mydb.c</code>:</p>
                    <div class="code-block"><pre>&#160;
    mco_collation_funcs_h mydb_get_collations(void);
    &#160;</pre>
                    </div>
                    <h3>Example 3</h3>
                    <p>C/C++ example using a “case-insensitive” collation tree index:</p>
                    <p>File <code>schema3.mco</code>:</p>
                    <div class="code-block"><pre>&#160;
    declare database colldb;
&#160;
    class Record
    {
        string name;
        unsigned&lt;4&gt; value;
&#160;
        unique tree &lt;name&gt; tstd;
        unique tree &lt;name collate C1&gt; tcoll;
    };
    &#160;</pre>
                    </div>
                    <p>Application code snippets:</p>
                    <div class="code-block"><pre>&#160;
    char * fruits[] = {
        "banana", "PEAR", "plum", "Peach", "apricot", "Kiwi", 
        "QUINCE", "pineapple", "Lemon", "orange", "apple",
        "pawpaw", "Fig", "mango", "MANDARIN", "Persimmon", 
        "Grapefruit", 0
    };
    &#160;
    /* collation compare function */
    int2  C1_collation_compare ( mco_collate_h c1, uint2 len1,
                mco_collate_h c2, uint2 len2)
    {
        char buf1[16], buf2[16];
        mco_collate_get_char(c1, buf1, sizeof(buf1));
        mco_collate_get_char(c2, buf2, sizeof(buf2));
        &#160;
        // perform case-insensitive compare
        return stricmp(buf1, buf2);
    }
&#160;
    int main(void)
    {
        MCO_RET rc;
        mco_db_h db = 0;
        mco_trans_h t;
        mco_cursor_t c;
        uint2 len;
        char buf[16];
        &#160;
        ...
        /* open the database */
        &#160;
        /* register the custom compare &amp; hash functions */
        mco_db_register_collations(db_name, colldb_get_collations());
&#160;
        /* connect to database */
        rc = mco_db_connect(db_name, &amp;db);
        if ( MCO_S_OK == rc ) 
        {
            /* fill database with records setting field s to fruit names */
            &#160;
            rc = mco_trans_start(db, MCO_READ_ONLY, MCO_TRANS_FOREGROUND,&amp;t);
            if (rc == MCO_S_OK) 
            {
                /* using custom collate tree index iterate through the cursor */
                rc = Record_tcoll_index_cursor(t, &amp;c);
                if (rc == MCO_S_OK) 
                {
                    for (rc = mco_cursor_first(t, &amp;c);
                            MCO_S_OK == rc;
                            rc = mco_cursor_next(t, &amp;c))
                    {
                        Record_from_cursor(t, &amp;c, &amp;rec);
                        Record_s_get(&amp;rec, buf, 11, &amp;len);
                        printf("\n\t%-15s", buf);
                    }
                    rc = mco_trans_commit(t);
                }
            }
        ...
        }
    }
    &#160;</pre>
                    </div>
                    <p>Note that the only additional step the main application needs to perform in order to implement a specialized string collation is to register the collation prior to connecting to the database.  The sorting logic is handled by the collation compare function.  In this case the compare logic simply returns the value returned by the case-insensitive C runtime function <code>stricmp()</code>.</p>
                </blockquote>
            </div>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../../../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>