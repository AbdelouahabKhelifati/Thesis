<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="Programming with eXtremeDB|Native APIs|C# API|[%=System.LinkedTitle%]">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Database Class Relationships in C#</title>
        <link href="../../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <script src="../../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <h1>Database Class Relationships in C#</h1>
            <blockquote>
                <p>As explained in the <a href="../Class_Relationships.htm">Class Relationships page</a>, <i>e</i>X<i>treme</i>DB provides a number of ways to implement relationships (joins) between tables, each having distinct advantages and costs in terms of memory overhead and performance. The different techniques available to C# developers are presented in the following sections.</p>
                <h2>Index join</h2>
                <p>A simple one-to-many relationship between two tables, <i>Department</i> and <i>Employee</i>, could be implemented in SQL as follows:</p>
                <div class="code-block"><pre>&#160;
    select e.name, d.name from Employee e 
    inner join Department d d.dept_no = d.dept_no;
    &#160;</pre>
                </div>
                <p>To implement a one-to-many relationship like the <i>Department</i> &gt; <i>Employee</i> example, we might define the two database classes as follows:</p>
                <div class="code-block"><pre>&#160;
    &#160;
    [Persistent]
    class Department
    {
        [Indexable(Type = Database.IndexType.BTree, Unique = true)]
        public String code;
        public String name;
        [Indexable(Type = Database.IndexType.Hashtable, Unique = true)]
        public int dept_no;
    }
&#160;
    [Index("byDept_EmployeeName", Keys = new string[] { "dept_no", "name" }, Unique = true)]
    [Persistent]
    class Employee
    {
        [Indexable(Type = Database.IndexType.BTree, Unique = false)]
        public String  name;
        public int  dept_no;
    }
    &#160;</pre>
                </div>
                <p>Here the unique hash index <code>dept_no</code> acts as the “primary key” on the <i>Department</i> class, and the unique B-Tree index <code>byDept_EmployeeName</code> acts as the “foreign key” in the <i>Employee</i> class. Note that <code>byDept_EmployeeName</code> is a compound index consisting of two field values in the <i>Employee</i> class: <code>dept_no</code> and <code>name</code>. It is not necessary that a “foreign key” be compound. A simple B-Tree index on field <code>dept_no</code> would be sufficient to form the join, but with the compound index we have the additional advantage that we are able to order all instances with the same <code>dept_no</code> value in alphabetical order by the <code>name</code> field.</p>
                <p>To demonstrate how the join is implemented, consider the following code snippets (taken from the SDK sample “csharp/Joins/Index_Join”) that manage <i>Department</i> and <i>Employee</i> objects. First we populate the <i>Department</i> class with some sample data:</p>
                <div class="code-block"><pre>&#160;
    // Create and insert Department objects
    con.StartTransaction(Database.TransactionType.ReadWrite);
    for (short i = 0; i &lt; N_DEPARTMENTS; i++)
    {
        Department dept = new Department();
        dept.code = DD[i].code;
        dept.name = DD[i].name;
        dept.dept_no = DD[i].dept_no;
        con.Insert(dept); // Insert object to eXtremeDB database
        Console.WriteLine("\t" + i + ") " + dept.code + ", " + dept.name +
            ", dept_no=" + dept.dept_no);
    }
    con.CommitTransaction();
    &#160;</pre>
                </div>
                <p>Then we insert <i>Employee</i> objects associating them with the appropriate <i>Department</i> object:</p>
                <div class="code-block"><pre>&#160;
    con.StartTransaction(Database.TransactionType.ReadWrite);
    // Find Department by code; extract dept_no; create Employee and assign name, dept_no
    Cursor&lt;Department&gt; cursor = new Cursor&lt;Department&gt;(con, "code");
    for (short i = 0; i &lt; N_EMPLOYEES; i++)
    {
        Department dept = cursor.Find(ED[i].deptCode);
        Employee emp = new Employee();
        emp.dept_no = dept.dept_no;
        emp.name = ED[i].name;
        con.Insert(emp);
        Console.WriteLine("\t" + i + ") " + emp.name + ", dept_no=" + emp.dept_no);
    }
    con.CommitTransaction();
    cursor.Close();
    &#160;</pre>
                </div>
                <p>Note that we instantiate a <i>Cursor</i> on index <code>Department.code</code> and call the <code>Cursor.find()</code> method to position to the <i>Department</i> object with the specified <code>deptCode</code>; then the <i>Department</i>’s <code>dept_no</code> is extracted to be stored in the new <i>Employee</i> object. This creates the association (relationship) between the <i>Department</i> object with the <i>Employee</i> object upon which the join is implemented during a subsequent query.</p>
                <p>Now to navigate the relationship between (i.e. “join”) these two classes we might use code like the following to display all of a given employee’s coworkers in their department:</p>
                <div class="code-block"><pre>&#160;
    // Search for all Employee objects from a specified Employee's Department
    String search_name = "William";
    Console.Write("\n\n" + search_name + "'s co-workers in ");
    con.StartTransaction(Database.TransactionType.ReadOnly);
    // 1. Find the Employee object by name
    Cursor&lt;Employee&gt; cursor1 = new Cursor&lt;Employee&gt;(con, "name");
    Employee emp1 = cursor1.Find(search_name);
    &#160;
    // 2. Find the Department object by its dept_no and display the Department name
    Cursor&lt;Department&gt; cursor2 = new Cursor&lt;Department&gt;(con, "dept_no");
    Department d = cursor2.Find(emp1.dept_no);
    Console.Write(d.name + " are:\n");
&#160;
    // 3. Position the cursor in the byDept_EmployeeName compound index to the
    // first object with this dept_no
    con.StartTransaction(Database.TransactionType.ReadWrite);
    Cursor&lt;Employee&gt; cursor3 = new Cursor&lt;Employee&gt;(con, "byDept_EmployeeName");
    {
        if (cursor3.Search(Operation.GreaterOrEquals, emp1.dept_no, ""))
        {
            foreach (Employee e in cursor3)
            {
                if(0 != e.dept_no.CompareTo(emp1.dept_no))  // Exit loop when Dept_no is
                                        // no longer equal
                {
                    break;
                }
                else if ( !String.Equals(e.name,search_name) )  // exclude serch_name
                                            // from results
                {
                    Console.WriteLine("\t" + e.name);
                }
            }
            cursor2.MoveNext();
        }
    }
    con.CommitTransaction();
    &#160;</pre>
                </div>
                <p>Note that we use a <i>Cursor</i> on index <code>Employee.name</code> to find the <i>Employee</i> object with the specified name; then a <i>Cursor</i> on index <code>Department.dept_no</code> to find the <i>Department</i> using the found <i>Employee</i>’s <code>dept_no</code>. Then we use a third <i>Cursor</i> on the compound index <code>Employee.byDept_EmployeeName</code> to position to the first object with this <code>dept_no</code> and scroll through the cursor until the <code>dept_no</code> is different. For each index node we get the <i>Employee</i> object from the cursor and check its name field. If this is not the name of the original employee we are searching coworkers for, we display the name and call the <code>Cursor.MoveNext()</code> method to go to the next node in the index tree.</p>
                <h3>Pros and Cons:</h3>
                <p>This is a typical “relational” style join familiar to many developers. While it is intuitive and straightforward to implement, it incurs significant overhead to manage several indexes. When an <b>insert</b> transaction is committed, a hash index and two B-Tree index nodes are created for each <i>Department</i> object, and two B-Tree index nodes are created for each <i>Employee</i> object. This results in memory consumption in addition to the space occupied by the database objects themselves and the B-Tree index structures require “balancing” which can incur significant processor cycles. Hence, the overall performance for inserting objects is not optimal.</p>
                <p>Lookup of <i>Department</i> objects by <code>dept_no</code> is efficient due to the hash index <code>Idept_no</code>. And the cursor created on the <i>Employee</i> objects through compound index <code>Employee.byDept_EmployeeName</code> facilitates “scrolling” through the index tree to list employees in alphabetical order by <code>name</code>.</p>
                <h2><a name="kanchor818"></a>Autoid reference</h2>
                <p>An alternative technique to the index-join example above is to implement the “foreign key” relationship with a direct <code>reference</code> from the <i>Employee</i> object to its <i>Department</i>. An <code>autoid</code> field can serve this purpose. For example, we might define the two database classes as follows:</p>
                <div class="code-block"><pre>&#160;
    [Persistent(AutoID = true)]
    class Department
    {
        [Indexable(Type=Database.IndexType.BTree, Unique=true)] // Declare unique tree index by "code" field
        public String code;
        public String name;
    }
&#160;
    [Persistent]
    [Index("byDept_EmployeeName", Keys=new string[]{"dept","name"}, Unique=true)]
    class Employee
    {
        [Indexable(Type = Database.IndexType.BTree, Unique = true)] // Declare unique tree index by "name" field
        public String name;
        [References(typeof(Department))]
        public long dept;
    }
    &#160;</pre>
                </div>
                <p>Note that the <i>Department</i> class no longer has the <code>dept_no</code> field and thus no index on field <code>dept_no</code>. Instead it has the annotation <code>(autoid=true)</code>. This actually causes a “hidden” hash index to be maintained for the <i>Department</i> object <code>autoid</code> values that are automatically incremented as new objects are created. And note the field <code>dept</code> is of type <code>long</code> - it will store the <code>autoid</code> of the associated <i>Department</i> object.</p>
                <p>To demonstrate how this join is implemented, consider the following code snippets (taken from the SDK sample “csharp/joins/Autoid_Ref”). We populate the <i>Department</i> class as in the Index_Join sample above, but note that to display the <code>autoid</code> for each <code>Department</code> object we retrieve it from the <code>Connection.insert()</code> method:</p>
                <div class="code-block"><pre>&#160;
    // Create and insert Department objects
    con.StartTransaction(Database.TransactionType.ReadWrite);
    Console.WriteLine("\nCreate Departments:\n");
    for (short i = 0; i &lt; N_DEPARTMENTS; i++)
    {
        Department dept = new Department();
        dept.code = DD[i].code;
        dept.name = DD[i].name;
        long autoid = con.Insert(dept);
        Console.WriteLine("\t" + i + ") " + dept.code + ", " + dept.name +", Autoid=" + autoid);
    }
    con.CommitTransaction();
    &#160;</pre>
                </div>
                <p>When inserting <i>Employee</i> objects we extract the <code>autoid</code> from the corresponding <i>Department</i> object using the <code>Cursor.GetAutoId()</code> method and assign it to the reference field <code>Employee.dept</code>:</p>
                <div class="code-block"><pre>&#160;
    // Create and insert Employee objects
    Console.WriteLine("\nCreate Employees and join each to a Department:\n");
    con.StartTransaction(Database.TransactionType.ReadWrite);
    Cursor&lt;Department&gt; cursor = new Cursor&lt;Department&gt;(con, "code");
    for (short i = 0; i &lt; N_EMPLOYEES; i++)
    {
        // Find the Department object for this Employee by the BTree index on
        // Department.code
        cursor.Find(ED[i].deptCode);
        Employee emp = new Employee();
        emp.name = ED[i].name;
        // Assign the Department autoid for this Department object and insert new
        // Employee object
        emp.dept = cursor.GetAutoId();  // Note that the method GetAutoId is of the
        // Cursor class
        con.Insert(emp);
        Console.WriteLine("\t" + i + ") " + emp.name + ", Department.Autoid=" + emp.dept);
    }
    con.CommitTransaction();
    cursor.Close();
    &#160;</pre>
                </div>
                <p>The code to display all of a given employee’s coworkers in their department would be nearly identical to that in the Index_Join sample above with the exception that we instantiate the <i>Cursor</i> on the class <i>Department</i> without specifying an index field. Then we call find with the <code>Employee.dept</code> value to lookup the <i>Department</i> object by its <code>autoid</code>. This is equivalent to the call of <code>Cursor.find()</code> on index  <code>Department.dept_no</code> which uses the hash index <code>dept_no</code>, the difference is that the <code>autoid</code> is automatically generated whereas a unique value must be specified for the <code>dept_no</code> field. The same technique of scrolling through a cursor on compound index <code>byDept_EmployeeName</code> is used to display the employee names in alphabetical order:</p>
                <div class="code-block"><pre>&#160;
&#160;
    // Search for all Employee objects from a specified Employee's Department
    String search_name = "William";
    Console.Write("\n\n" + search_name + "'s co-workers in ");
    con.StartTransaction(Database.TransactionType.ReadOnly);
    // 1. Find the Employee object by name
    Cursor&lt;Employee&gt; cursor1 = new Cursor&lt;Employee&gt;(con, "name");
    Employee emp1 = cursor1.Find(search_name);
&#160;
    // 2. Find the Department object by its autoid and display the Department name
    Cursor&lt;Department&gt; cursor2 = new Cursor&lt;Department&gt;(con);
    Department d = cursor2.Find(emp1.dept);
    Console.Write(d.name + " are:\n");
&#160;
    // 3. Position the cursor in the byDept_EmployeeName compound index to the
    // first object with this Department Autoid
    Cursor&lt;Employee&gt; cursor3 = new Cursor&lt;Employee&gt;(con, "byDept_EmployeeName");
    {
        if (cursor3.Search(Operation.GreaterOrEquals, emp1.dept, ""))
        {
            foreach (Employee e in cursor3)
            {
                if (0 != e.dept.CompareTo(emp1.dept))  // Exit loop when Department
                                        // autoid is no longer equal
                {
                    break;
                }
                else if (!String.Equals(e.name, search_name))  // exclude serch_name from results
                {
                    Console.WriteLine("\t" + e.name);
                }
            }
            cursor3.MoveNext();
        }
    }
    con.CommitTransaction();
    &#160;</pre>
                </div>
                <h3>Pros and Cons:</h3>
                <p>This implementation uses somewhat less memory by eliminating the field <code>dept_no</code> and the lookup of <i>Department</i> objects is likewise efficient due to the hash index generated for the <code>autoid</code>. But some optimization might be gained by relaxing the application requirements.</p>
                <p>Note that the major drawback for performance and memory consumption, both for this and the index_join relational approach, is incurred by the B-Tree indexes:<code> Employee.byDept_EmployeeName</code>, <code>Employee.name</code> and <code>Department.name</code>. For example, if it is not necessary to lookup a <i>Department</i> object by its name, the <code>Department.Name</code> index could be eliminated. And further, if it is not necessary to display the employees of a given department in alphabetical order, then we can eliminate the compound index  <code>Employee.byDept_EmployeeName</code>. The following example illustrates this approach.</p>
                <h2>Vector of autoids</h2>
                <p>Instead of storing the <code>autoid</code> of the <i>Employee</i> object’s <i>Department</i> in the <i>Employee</i> object, we could instead store an array or <code>vector</code> of <i>Employee</i> <code>autoids</code> in the <i>Department</i> object. For example (see the SDK sample “csharp/joins/Autoid_Vector”), we might define the database classes as follows:</p>
                <div class="code-block"><pre>&#160;
    [Persistent(AutoID = true)]
    class Department
    {
        [Indexable(Type=Database.IndexType.BTree, Unique=true)] // Declare unique tree index by "code" field
        public String code;
        public String name;
        [References(typeof(Employee))]
        public long[] employees;
    }
&#160;
    [Persistent(AutoID = true)]
    class Employee
    {
        [Indexable(Type = Database.IndexType.BTree, Unique = true)] // Declare unique tree index by "name" field
        public String name;
        [References(typeof(Department))]
        public long dept;
    }
    &#160;</pre>
                </div>
                <p>Note that both classes are defined with <code>[Persistent(autoid = true)]</code>. The <i>Employee</i> <code>autoid</code> will be stored in the <i>Department</i> class vector of references <code>employees</code>. We will use the <i>Department</i> <code>autoid</code> in the <i>Employee</i> reference field <code>dept</code>, as in the Autoid_Ref example above, to efficiently access the <i>Department</i> object from the <i>Employee</i>.</p>
                <p>The code to populate the database becomes a little more complicated as we need to allocate space for the dynamic vector of <code>autoid</code> values in the <i>Department</i> objects and assign these <code>autoids</code> when we insert the <i>Employee</i> objects. So for each <i>Employee</i> object we execute the following code to allocate space and insert an <i>Employee</i> <code>autoid</code> into the <i>Department</i> employees vector:</p>
                <div class="code-block"><pre>&#160;
    // Create and insert Department objects
    con.StartTransaction(Database.TransactionType.ReadWrite);
    Console.WriteLine("\nCreate Departments:\n");
    for (short i = 0; i &lt; N_DEPARTMENTS; i++)
    {
        Department dept = new Department();
        dept.code = DD[i].code;
        dept.name = DD[i].name;
        // Allocate space for Employee autoids and initialize to 0
        dept.employees = new long[VECTOR_SIZE];
        for (short j = 0; j &lt; VECTOR_SIZE; j++) dept.employees[j] = 0;
        long autoid = con.Insert(dept);
        Console.WriteLine("\t" + i + ") " + dept.code + ", " + dept.name +
                    ", Autoid=" + autoid);
    }
    con.CommitTransaction();
&#160;
    // Create and insert Employee objects
    Console.WriteLine("\nCreate Employees and join each to a Department:\n");
    for (short i = 0; i &lt; N_EMPLOYEES; i++)
    {
        // Find the Department object for this Employee by the BTree index on
        // Department.code
        con.StartTransaction(Database.TransactionType.ReadWrite);
        Cursor&lt;Department&gt; cursor = new Cursor&lt;Department&gt;(con, "code");
        Department d = cursor.Find(ED[i].deptCode);
        if (null != d)
        {
            // Find the first vacant Employee vector element
            for (short j = 0; j &lt; VECTOR_SIZE; j++)
            {
                if (0 == d.employees[j])
                {
            &#160;
                    // Create Employee object and store its autoid in vector
                    // Department.employees
                    Employee emp = new Employee();
                    emp.name = ED[i].name;
                    // Assign the Department autoid for this Department object and insert
                    // new Employee object
                    emp.dept = cursor.GetAutoId();    // Note that the method GetAutoId()
                    // is of the Cursor class
                    d.employees[j] = con.Insert(emp); // Note that Insert() returns the
                                        // Employee autoid
                    con.CurrentCursor.Update();       // Assure that the inserted autoid
                            // is made perminent
                    Console.WriteLine("\t" + i + ") " + emp.name + ", Department.Autoid="
                        + emp.dept);
                    break;
                }
            }
        }
        else
        {
            Console.WriteLine("\tDepartment.code (" + ED[i].deptCode +
                ") not found!");
        }
        con.CommitTransaction();
        cursor.Close();
    }
    &#160;</pre>
                </div>
                <p>Now the code to display all of a given employee’s coworkers in their department will simply find the <i>Department</i> object as in the Autoid_Ref sample above by instantiating the <i>Cursor</i> on class <i>Department</i> without specifying an index field. Then we call find with the <code>Employee.dept</code> value to lookup the <i>Department</i> object by its <code>autoid</code>. Then we simply list this department’s employees from the vector as follows:</p>
                <div class="code-block"><pre>&#160;
    // Search for all Employee objects from a specified Employee's Department
    String search_name = "William";
    Console.Write("\n\n" + search_name + "'s co-workers in ");
    con.StartTransaction(Database.TransactionType.ReadOnly);
    // 1. Find the Employee object by name
    Cursor&lt;Employee&gt; cursor1 = new Cursor&lt;Employee&gt;(con, "name");
    Employee emp1 = cursor1.Find(search_name);
    if ( null != emp1 )
    {
        // 2. Find the Department object by its autoid and display its name
        Cursor&lt;Department&gt; cursor2 = new Cursor&lt;Department&gt;(con);
        Department dept1 = cursor2.Find(emp1.dept);
        Console.Write(dept1.name + " are:\n");
&#160;
        // 3. Scroll through the vector of Employee autoids, find the Employee
        // object and display its name
        Cursor&lt;Employee&gt; cursor3 = new Cursor&lt;Employee&gt;(con);
        for (short j = 0; j &lt; VECTOR_SIZE &amp;&amp; 0 != dept1.employees[j]; j++)
        {
            // Skip if this is the autoid of the "search_name" object
            if (cursor1.GetAutoId() != dept1.employees[j])
            {
                Employee emp = cursor3.Find(dept1.employees[j]);
                Console.WriteLine("\t" + emp.name);
            }
        }
    }
    &#160;</pre>
                </div>
                <h3>Pros and Cons:</h3>
                <p>This implementation uses significantly less memory and reduces behind-the-scenes tree structure maintenance by eliminating two B-Tree indexes with the small sacrifice of not ordering the list of <code>Employees</code> in alphabetical order. However, it could be a simple matter to introduce a sorting algorithm into the application to address this; but it should be noted that this approach could become untenable if the number of <i>Employees</i> per <i>Department</i> is very large.</p>
            </blockquote>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../../../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>