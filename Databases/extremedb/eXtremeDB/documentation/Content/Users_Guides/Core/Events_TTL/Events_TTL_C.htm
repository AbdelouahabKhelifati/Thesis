<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="Programming with eXtremeDB|Native APIs|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Using eXtremeDB Events and Time-To-Live Features in C</title>
        <link href="../../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <script src="../../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <h1>Using <i>e</i>X<i>treme</i>DB Events and Time-To-Live Features in C</h1>
            <blockquote>
                <p>As explained in the <a href="../Events_TTL.htm">introduction</a> page, <i>e</i>X<i>treme</i>DB provides the capability to automatically delete obsolete database objects through the <i>Time-To-Live</i> feature, and to manage database object <b>new</b>, <b>delete</b>, <b>update</b> and <b>checkpoint</b> events. The C APIs for these features are explained in the sections below.</p>
                <h2>Time To Live</h2>
                <p>The <code>Time-To-Live</code> (TTL) mechanism facilitates automatic deletion of objects according to TTL policies. Two TTL policies are supported: <code>TTL_count</code> and <code>TTL_clock_time</code>. The former sets an object count threshold, while the latter sets an object age threshold. Both policies can be set for a single class at the same time.</p>
                <p>The time to live can be defined in seconds (sec), milliseconds (ms) and microseconds (us). The syntax is:</p>
                <div class="code-block"><pre>&#160;
    TTL_count &lt;max_object_count&gt;;
    &#160;
    TTL_clock_time &lt;max_object_age&gt; &lt;sec | ms | us&gt;;
    &#160;</pre>
                </div>
                <p>For example, the following schema definition sets both TTL policies for class <code>A</code>:</p>
                <div class="code-block"><pre>&#160;
    class A
    {
        unsigned&lt;4&gt; id;
        char&lt;256&gt; name;
        &#160;
        tree&lt;id&gt; idx_id;
        TTL_count 10;
        TTL_clock_time 5 sec;
    };
    &#160;</pre>
                </div>
                <p>With this schema, when more than 10 objects of class <code>A</code> are created, extra objects (those created previously) are deleted. Also, objects that had been stored for more than 5 seconds are deleted as well.</p>
                <p>The TTL mechanism implementation adds two hidden fields, <code>ttl_count@</code> and <code>ttl_timestamp@</code>, and two indexes, <code>ttl_count_idx@</code> and <code>ttl_timestamp_idx@</code>. These fields and indexes are only added when the corresponding TTL policy is set for the given class. These fields’ values are set when a new object of the given class is created.</p>
                <p>TTL policies are only checked and enforced when a <code>READ_WRITE</code> transaction is committed, before the commit’s first stage. </p>
                <p>(An important side effect of this is that the indexes for the newly created objects (i.e. the ones created within the current transaction) are not updated yet, and thus these objects are not checked against the TTL policies. To mitigate this effect, a transaction checkpoint may be added before the commit.)</p>
                <h3>Side effects in a distributed environment</h3>
                <p>For distributed databases in a network (using <i style="font-weight: normal;">e</i>X<i style="font-weight: normal;">treme</i>DB <i style="font-weight: normal;">Cluster</i>) it is important to note that clocks need to be carefully synchronized between machines participating in a cluster when the <code>TTL_clock_time</code> policy is used. Bear in mind the following:</p>
                <blockquote>
                    <p>1.	In the cluster environment, the TTL clock is verified on the transaction initiator side only in the beginning of the commit phase 1. On the remote side the clock time is not verified and the transaction is applied regardless of the actual clock on that node. If the transaction is applied successfully on the remote nodes, the notifications are sent back and the initiator commits the transaction. The databases are kept consistent regardless of the clock on each node (i.e. their content is the same on every node as long as the transactions are committed).</p>
                    <p>2.	It is possible that a node will have some data that violates the node’s TTL requirements — in the example above the clock on the remote node could be far ahead of the clock on the local node where the transaction had been initiated. By the remote node clock the record should’ve been removed, but it is going to be kept in the node’s database regardless.</p>
                    <p>3.	It is also possible that the object would be removed from the node’s database even if the TTL on that node is not expired, because it has expired on a different node. For example, suppose that node1 clock is set to 1 pm and node2 clock is set to 2 pm. The transaction is initiated on the node1 and gets successfully committed to both nodes despite the fact that the TTL for the record expired on the node2. Shortly after the transaction is committed, node2 initiates another transaction and after verifying the TTL condition by its own clock, removes the object just inserted, naturally propagating the delete to the entire cluster. The record is thus short-lived (shorter than expected).</p>
                </blockquote>
                <h2>Event Interfaces</h2>
                <p><i>e</i>X<i>treme</i>DB applications can respond to data events like creating, updating or deleting database objects.  For C applications the <a href="../../../Programming/C/DDL.htm">DDL</a> <code>event</code> declarations cause applications to receive notification of the following database event types: adding a <b>new</b> object, <b>deleting</b> an object or all objects of a class, <b>checkpoint</b> events and <b>updating</b> an object or a specified field of an object.  Events are specific to classes. In other words, a <code>new</code> event handler for class A will not receive a notification when an object of class B is added to the database.</p>
                <p>The event declaration in the  schema defines what events will trigger application notifications. How the application handles the events is determined at run-time by the event handlers. In C applications, events can be handled <i>synchronously</i> or <i>asynchronously</i>.</p>
                <h3>Asynchronous Event Handling</h3>
                <p>In asynchronous event handling, the application spawns a separate thread to handle each type of event.  This event thread calls function <code><a href="../../../Programming/C/Core_Functions/Static/Events/wait.htm">mco_async_event_wait()</a></code><a name="kanchor408"></a> to wait for the specified event.  When the event occurs, the runtime releases the thread. Upon releasing the thread, the runtime continues normal processing, so the handler thread runs in parallel with other threads, until it completes its processing and again calls <code><a href="../../../Programming/C/Core_Functions/Static/Events/wait.htm">mco_async_event_wait()</a></code>.</p>
                <p>There is a small window of possibility for another instance of  the event to occur before the event handler has completed its task and calls <code><a href="../../../Programming/C/Core_Functions/Static/Events/wait.htm">mco_async_event_wait()</a></code> again to wait on the event (events are not queued). This window can be minimized if the handler delegates the processing of the event to yet another thread, allowing the handler thread to immediately wait on the event again.  If this risk of an unhandled event cannot be tolerated, either a <i>synchronous</i> event handler can be used, the application can maintain a separate table of unhandled events, or the <code><a href="../../../Programming/C/TL_Functions/play.htm">mco_translog_play()</a></code> function of the <i>e</i>X<i>treme</i>DB<i> Transaction Logging</i> can be employed.  </p>
                <p>Asynchronous events are activated after the transaction commits.  If, within the scope of a single transaction, several objects are added, or deleted, or several fields are updated which have event handlers waiting, all the handlers will be activated simultaneously.</p>
                <p>A C application will define asynchronous event handlers in code like the following:</p>
                <div class="code-block"><pre>&#160;
    /* Thread function that handles the &lt;new&gt; event. */
    void NewEventHandler( sample_task_t * descriptor )
    {
        mco_db_h db = descriptor-&gt;db_connection;
        while ( MCO_S_OK == mco_async_event_wait(db, MCO_EVENT_newEvent) ) 
        {
            /* Process the event. */
            ...
        }
    }
    &#160;
    /* Thread function that handles the &lt;update&gt; event. */
    void UpdateEventHandler( sample_task_t * descriptor )
    {
        mco_db_h db = descriptor-&gt;db_connection;
        while ( MCO_S_OK == mco_async_event_wait(db, MCO_EVENT_updateEvent) ) 
        {
            /* Process the event. */
            ...
        }
    }
    &#160;
    /* Thread function that handles the &lt;delete&gt; event. */
    void DeleteEventHandler( sample_task_t * descriptor )
    {
        mco_db_h db = descriptor-&gt;db_connection;
        while ( MCO_S_OK == mco_async_event_wait(db, MCO_EVENT_deleteEvent) ) 
        {
            /* Process the event. */
            ...
        }
    }
&#160;
    /* Thread function that handles the &lt;update&gt; event. */
    void CheckpointEventHandler( sample_task_t * descriptor )
    {
        mco_db_h db = descriptor-&gt;db_connection;
&#160;
        while ( MCO_S_OK == mco_async_event_wait(db, MCO_EVENT_checkpointEvent) ) 
        {
            /* Process the event. */
            ...
        }
    }
    &#160;</pre>
                </div>
                <p>Then the C application will start the event handler threads and cause the main application thread to sleep for some milliseconds (100 is usually adequate) in order for the event handler threads to start listening (waiting). Then the main application thread will proceed with normal database processing. When terminating, the application will call <a href="../../../Programming/C/Core_Functions/Static/Events/release_all.htm"><code>mco_async_event_release_all()</code></a> to release all events and then stop the event handler threads. (See the SDK sample <code><a href="../../../Programming/C/SDK_Samples/Core_Samples/10-Events_Asynch.htm">samples/core/10-events/asynch</a></code> for implementation details.)</p>
                <h3>Synchronous Event Handling</h3>
                <p>C applications can also respond to events synchronously. Synchronous event handlers are called within the context of the same thread that caused the event.  Care should be taken in event handlers not to cause extraordinary delays because the handler has control of a transaction that, by definition, is a <code>READ_WRITE</code> transaction and thus could block access to the database. Specifically, the handler should not wait on an indeterminate external event such as user input.</p>
                <p>A synchronous handler returns <code>MCO_S_OK</code> to indicate successful completion; any other value (one of <code>MCO_S_*</code> or <code>MCO_E_*</code> constants defined in <code>mco.h</code>, or a user-defined value) indicates success or failure with additional information. The runtime returns this value to the application, which can act on it accordingly (rolling back the transaction if necessary).</p>
                <p>Synchronous handlers are registered by calling the generated <code>mco_register_event_handler()</code> function for each event handler. Any number of handlers can be registered for a single event type, but the order in which they are called cannot be predicted.  At registration, the application can pass a user-defined parameter that will be, in turn, passed to the event handler when it is invoked.  This parameter is a void pointer that can reference a simple scalar value or a complex data structure depending on the application requirements.</p>
                <p>For <b>new</b> events, synchronous handlers are called by the <a href="../../../Programming/C/Core_Functions/Generated/Class/new.htm"><code>classname_new()</code></a>or <a href="../../../Programming/C/Core_Functions/Generated/Class/new_oid.htm"><code>classname_oid_new()</code></a> function immediately after the object is instantiated (so the object handle is guaranteed to be valid).  For <b>checkpoint</b> events, synchronous handlers are called by the <a href="../../../Programming/C/Core_Functions/Generated/Class/checkpoint.htm"><code>classname_checkpoint()</code></a> method immediately before or after the object is inserted into indexes – the application specifies whether the handler will be invoked before or after inserting into indexes through the handler registration interface.  Checkpoint events are not fired by <code><a href="../../../Programming/C/Core_Functions/Static/Transaction_Control/commit.htm">mco_trans_commit()</a></code>, though this function also updates the index(es). For <b>delete</b> events, synchronous handlers are called by the <code><a href="../../../Programming/C/Core_Functions/Generated/Class/delete.htm">classname_delete()</a></code> method before the object is deleted (while the object handle is still valid).</p>
                <blockquote>
                    <p>
                        <img src="../../../Resources/Images/note.png" /> Note that	<code>delete</code> events are not invoked by the <code><a href="../../../Programming/C/Core_Functions/Generated/Class/delete_all.htm">classname_delete_all()</a></code> method. Only <code><a href="../../../Programming/C/Core_Functions/Generated/Class/delete.htm">classname_delete()</a></code> will invoke these events.</p>
                </blockquote>
                <p><b>Update</b> events can be defined for a class (i.e. all fields of that class) or for a specific field of a class by specifying the field name in the event declaration.  As with <b>checkpoint</b> events, the application must specify through the handler registration interface whether the handler will be invoked before or after a field is updated.  Update handlers are activated by any interface method that will cause a field’s contents to change, for example, <code><a href="../../../Programming/C/Core_Functions/Generated/Field/Scalar/put.htm">classname_fieldname_put()</a></code>, <code><a href="../../../Programming/C/Core_Functions/Generated/Field/Vector/erase_vector.htm">classname_fieldname_erase()</a></code>.  If the event handler is called before the update and the handler invokes <code><a href="../../../Programming/C/Core_Functions/Generated/Field/Scalar/get.htm">classname_fieldname_get()</a></code> on the field, it will retrieve the current value in the database. Conversely, if the event is called after the update, the handler will retrieve the value the application just put in the database.  The user-defined parameter can be used to provide additional information to the handler such as the incoming value for a before-event handler, the old value for an after-event handler, or a vector offset for an erase operation.</p>
                <blockquote>
                    <p>
                        <img src="../../../Resources/Images/note.png" /> Note that both synchronous and asynchronous events can be applied to any given event. When using shared memory, synchronous event handlers must belong to the same process that caused the event, or the results will be unpredictable (most likely, a crash, due to an attempt to call a function in another address space). In particular, do not register a synchronous event handler for class <i>Alpha</i> in process <code>A</code> if it is possible that process <code>B</code> will insert, update or delete <i>Alpha</i> objects. Use an asynchronous event handler, instead.</p>
                </blockquote>
                <blockquote>
                    <p>
                        <img src="../../../Resources/Images/note.png" /> Note that for update events, a class-wide event cannot be combined with field update events for the same class.</p>
                </blockquote>
                <p>The following code fragments illustrate event handling.  Consider the following schema DDL definition for a class with event notifications:</p>
                <div class="code-block"><pre><a name="kanchor409"></a>&#160;
    class dropped_call
    {
        uint4 trunk_id;
        ...
&#160;
        autoid;
&#160;
        event &lt; trunk_id update &gt; upd_trunk; // any name will do
        event &lt; new &gt; add_trunk;
        event &lt; checkpoint &gt; checkpoint_trunk;
        event &lt; delete &gt; del_trunk;
    };
    &#160;</pre>
                </div>
                <p>The schema compiler will generate the following definitions in the interface header file:</p>
                <div class="code-block"><pre>&#160;
    #define upd_trunk 15
    // 15 is only illustrative; the actual value is not important
    #define add_trunk 16
    #define checkpoint_trunk 17
    #define del_trunk 18
    typedef MCO_RET (*mco_upd_trunk_handler)( /*IN*/ mco_trans_h *t,
                /*IN*/ dropped_call *handle,
                /*IN*/ MCO_EVENT_TYPE et,
                /*INOUT*/ void *param );
&#160;
    typedef MCO_RET (*mco_add_trunk_handler)( /*IN*/ mco_trans_h *t,
                /*IN*/ dropped_call *handle,
                /*IN*/ MCO_EVENT_TYPE et,
                /*INOUT*/ void *param );
&#160;
    typedef MCO_RET (*mco_del_trunk_handler)( /*IN*/ mco_trans_h *t,
                /*IN*/ dropped_call *handle,
                /*IN*/ MCO_EVENT_TYPE et,
                /*INOUT*/ void *param );
&#160;
    MCO_RET mco_register_upd_trunk_handler( /*IN*/ mco_upd_trunk_handler,
                /*IN*/ void *param,
                /*IN*/ MCO_HANDLING_ORDER when);
&#160;
    MCO_RET mco_register_add_trunk_handler( /*IN*/ mco_add_trunk_handler,
                /*IN*/ void *param,
                /*IN*/ MCO_HANDLING_ORDER when);
                &#160;
    MCO_RET mco_register_checkpoint_trunk_handler( /*IN*/ mco_checkpoint_trunk_handler,
                /*IN*/ void *param);
&#160;
    MCO_RET mco_register_del_trunk_handler( /*IN*/ mco_del_trunk_handler,
                /*IN*/ void *param);
                &#160;
    MCO_RET mco_unregister_upd_trunk_handler( /*IN*/ mco_upd_trunk_handler);
&#160;
    MCO_RET mco_unregister_add_trunk_handler( /*IN*/ mco_add_trunk_handler);
&#160;
    MCO_RET mco_unregister_checkpoint_trunk_handler( /*IN*/ mco_checkpoint_trunk_handler);
&#160;
    MCO_RET mco_unregister_del_trunk_handler( /*IN*/ mco_del_trunk_handler);
    &#160;</pre>
                </div>
                <p>To employ an asynchronous handler for one of the events above, the  application would start a thread and, within the thread function, call:</p>
                <div class="code-block"><pre>&#160;
    mco_async_event_wait( dbh, upd_trunk );
    &#160;</pre>
                </div>
                <p>Where <code>dbh</code> is the database handle from the <code><a href="../../../Programming/C/Core_Functions/Static/Database_Control/connect.htm">mco_db_connect()</a></code> method and <code>upd_trunk</code> is the value defined in the generated interface file to reference the event of interest.</p>
                <p>As previously mentioned, this thread will block (wait) until released by the runtime.  It can be released either by an occurrence of the event, or the  application can release it forcibly by calling one of the following:</p>
                <div class="code-block"><pre>&#160;
    mco_async_event_release( dbh, upd_trunk );
    &#160;
    mco_async_event_release_all_( dbh );
    &#160;</pre>
                </div>
                <p>A C event handler will know if it was released by an occurrence of the event or by a <code>release()</code> function by the return value of <code><a href="../../../Programming/C/Core_Functions/Static/Events/wait.htm">mco_async_event_wait()</a></code>. <code>MCO_S_OK</code> means the event happened; <code>MCO_S_EVENT_RELEASED</code> means the event was released. </p>
                <p>For the preceding class definition and its generated interfaces, the following code fragments illustrate synchronous event handling. First, the application must register its synchronous event handler functions with code like the following:</p>
                <div class="code-block"><pre>&#160;
    int register_events(mco_db_h db)
    {
        MCO_RET rc;
        mco_trans_h t;
        &#160;
        mco_trans_start(db, MCO_READ_WRITE, MCO_TRANS_FOREGROUND, &amp;t);
&#160;
        mco_register_add_trunk_handler(t, &amp;new_handler, (void*) 0);
        mco_register_checkpoint_trunk_handler(t, &amp;checkpoint_handler, 
                            (void*) 0, MCO_BEFORE_UPDATE );
        mco_register_del_trunk_handler(t, &amp;delete_handler, (void *) 0);
        mco_register_upd_trunk_handler( t, &amp;update_handler1, 
                            (void *) 0, MCO_BEFORE_UPDATE );
        rc = mco_trans_commit(t);
        return rc;
    }
    &#160;</pre>
                </div>
                <p>The bodies of the handler functions would look like the following:</p>
                <div class="code-block"><pre>    &#160;
    /* Handler for the "&lt;new&gt;" event. Reads the autoid and prints it out */
    MCO_RET new_handler( /*IN*/ mco_trans_h t, /*IN*/ dropped_call * obj,
                /*IN*/ MCO_EVENT_TYPE et, /*INOUT*/ void *param)
    {
        int8 u8;
        param = (int *)1;
        &#160;
        dropped_call_autoid_get( obj, &amp;u8 );
        printf( "Event \"Object New\" : object (%ld,%ld) is created\n", u8.lo, u8.hi );
        return MCO_S_OK;
    }
    &#160;
    /* Handler for the "&lt;checkpoint&gt;" event. Reads the autoid and prints it out */
    MCO_RET checkpoint_handler( /*IN*/ mco_trans_h t, /*IN*/ dropped_call * obj,
                    /*IN*/ MCO_EVENT_TYPE et, /*INOUT*/ void *param)
    {
        int8 u8;
        param = (int *)1;
&#160;
        dropped_call_autoid_get( obj, &amp;u8 );
        printf( "Event \"Object Checkpoint\" : object (%ld,%ld) is about to be created\n", u8.lo, u8.hi );
        return MCO_S_OK;
    }
&#160;
    /* Handler for the "&lt;delete&gt;" event. Note that the handler
    * is called before the current transaction is committed.
    * Therefore, the object is still valid; the object handle
    * is passed to the handler and is used to obtain the
    * autoid of the object. The event's handler return value
    * is passed into the "delete" function and is later
    * examined by the mco_trans_commit(). If the value is
    * anything but MCO_S_OK, the transaction is rolled back.
    * In this sample every other delete transaction is
    * committed.
    */
    MCO_RET delete_handler(	/*IN*/ mco_trans_h t, /*IN*/ dropped_call * obj,
                /*IN*/ MCO_EVENT_TYPE et, /*INOUT*/ void *user_param)
    {
        int8 u8;
&#160;
        dropped_call_autoid_get( obj, &amp;u8);
        printf( "Event \"Object Delete\": object (%ld,%ld) is being deleted...", u8.lo, u8.hi );
        return (((u8.lo + u8.hi) %2) ? 1: MCO_S_OK);
    }
&#160;
    /* Handler for the "update" event. This handler is called
    * before the update transaction is committed - hence the
    * value of the field being changed is reported unchanged
    * yet.
    */
    MCO_RET update_handler1( /*IN*/ mco_trans_h t, /*IN*/ dropped_call * obj,
                /*IN*/ MCO_EVENT_TYPE et, /*INOUT*/ void *param)
    {
        uint4 u4;
        int8 u8;
&#160;
        dropped_call_autoid_get( obj, &amp;u8);
        dropped_call_trunk_id_get(obj, &amp;u4);
        printf( "Event \"Object Update\" (before commit): object (%ld,%ld) value %d\n", 
            u8.lo, u8.hi, u4 );
        return MCO_S_OK;
    }
    &#160;</pre>
                </div>
                <p>When the application is finished handling events, the events are unregistered by code like the following:</p>
                <div class="code-block"><pre>    &#160;
    int unregister_events(mco_db_h db)
    {
        MCO_RET rc;
        mco_trans_h t;
        &#160;
        mco_trans_start(db, MCO_READ_WRITE, MCO_TRANS_FOREGROUND, &amp;t);
        mco_unregister_add_trunk_handler( t, &amp; new_handler);
        mco_unregister_del_trunk_handler( t, &amp; delete_handler);
        mco_unregister_update_handler( t, &amp; update_handler1);
        rc = mco_trans_commit(t);
        return rc;
    }
    &#160;</pre>
                </div>
                <p>(See the SDK sample <code><a href="../../../Programming/C/SDK_Samples/Core_Samples/10-Events_Synch.htm">samples/core/10-events/synch</a></code> for further implementation details.)</p>
            </blockquote>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../../../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>