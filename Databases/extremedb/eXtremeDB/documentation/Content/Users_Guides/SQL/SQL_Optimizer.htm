<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="[%=System.LinkedTitle%]|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>eXtremeSQL Optimizer</title>
        <link href="../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <link href="../../Resources/TableStyles/FunctionReference.css" rel="stylesheet" />
        <script src="../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <h1><i>e</i>X<i>treme</i>SQL Optimizer</h1>
            <blockquote>
                <p> <i>e</i>X<i>treme</i>SQL uses a rule-based query optimizer to support goals of </p>
                <blockquote>
                    <p>1) predictable and fast execution of queries, and </p>
                    <p>2) maximum developer flexibility to tune the queries and indirectly specify the optimal execution plans by arranging the tables and filters according to simple rules. </p>
                </blockquote>
                <p>The <i>e</i>X<i>treme</i>SQL query optimization is based on a set of rules mostly using indexes, and avoiding sequential table scans whenever possible. </p>
                <p>The optimizer can push down predicates and can process any combination of ascending or descending indexes, order by clauses, comparison operators (&lt;=, &gt;, …) in search constrains, etc.</p>
                <p>Some operations are handled without using indexes; for example <code>BETWEEN</code> expressions are not processed through the index, but instead the engine does a lookup based on one of the boundaries of the range, and then simply checks the validity of the other boundary.</p>
                <p>Instead of using cost-based optimization, a smarter algorithm is used to choose the right index for a query. There are various criteria; the engine attempts to pick the index that supports the required order and replaces the maximum number of predicates in the query while keeping the index length to a minimum.</p>
                <p>For a simple example: assume the query clause “<code>x=1 AND y=2 AND z=3</code>”. Here the optimizer looks for an index that covers as many of the conditions as possible. So if there are indexes  <code>tree&lt;x&gt;, tree&lt;y&gt;, tree&lt;z,x&gt;</code>, then <code>tree&lt;z,x&gt;</code> index is chosen. But if there is also an index <code>tree&lt;x,y,a,b,c&gt;</code>, the optimizer would not pick it because it covers the same number of conditions (two), but includes more key components, hence supposedly its selectivity is less.</p>
                <p>Using the <code>explain</code> operator before a <code>select</code> statement displays the <i>execution plan</i>. The abbreviations in uppercase indicate the optimization algorithm (described in the table below); the indentations indicate the nesting level and an integer number in square brackets indicates a “data source id” (this is an internal identifier of a "data source").</p>
                <p>There are several ways to make the optimizer change the plan and there are some limitations. For example:</p>
                <ol>
                    <li value="1">Change the order in which the tables appear in <code>JOINs</code>. It pays to put a bigger table or a table with the predicate with higher selectivity up-front. The worst-case scenario for the nested look is when the larger table appears at the end of the query expression.</li>
                    <li value="2">Change the order of conjuncts (the parts of the query joined with an <code>AND</code>). Currently the optimizer, with all other conditions being equal, attempts to use an index for the far “left” key. However, if there is a compound index that covers multiple conjunct’s parts, that index is used. The optimizer also takes into account the existing index types and matches them into the query predicates. If ordering is required, (order by) a <code>tree</code> index must be used, etc.,</li>
                    <li value="3">It is sometimes beneficial to explicitly prohibit the use of an index for a given key. Specifically this is applicable when the application benefits from using another index or no index at all (sequential scan). To "turn off” an index a “dummy" expression can be added. For example:</li>
                </ol>
                <blockquote>
                    <div class="code-block"><pre>    &#160;
    XSQL&gt;explain select * from TTT where a=1;
    XSQL&gt;create table TTT(a int using index);
    Plan
    -------------------------------------------------------------
    INDEX-SCAN[1] using index TTT.a(a)
    &#160;
    Selected records: 1
    XSQL&gt;explain select * from TTT where a+0=1;
    XSQL&gt;create table TTT(a int using index);
    Plan
    -------------------------------------------------------------
    FILTER (Eq (IntAdd TTT.a 0) 1)
    .SEQ_SCAN[1] of table TTT
    &#160;
    Selected records: 1
    &#160;</pre>
                    </div>
                </blockquote>
                <blockquote>
                    <p>(Note that the optimizer does not currently support constant propagation (i.e. it does not substitute constant values with calculated constant expressions). So don’t use expressions like (2+2) in queries.)</p>
                </blockquote>
                <ol start="4">
                    <li value="4"> The optimizer is unable to convert (flatten) subqueries into normal joins. That must be done manually, for example rewrite:</li>
                </ol>
                <blockquote>
                    <div class="code-block"><pre>    &#160;
    select c1 from t1 where c1 in (select c1 from t2);
    &#160;</pre>
                    </div>
                    <p>as</p>
                    <div class="code-block"><pre>    &#160;
    select t1.c1 from t1, t2 where t1.c1=t2.c2;
    &#160;</pre>
                    </div>
                    <p>&#160;</p>
                </blockquote>
                <ol start="5">
                    <li value="5">	If a long calculation (a function) is included into the column list (for example a <code>sequence</code> aggregate) and the query includes a <code>sort</code> with the limit clause, it is advisable to separate the function into a subquery. The optimizer is currently unable to do it, so it must be done manually.</li>
                    <li value="6">It is possible to use a <code>shuffle join</code> instead of a <code>hash join</code>. Unlike <code>HashJoin</code>, <code>ShuffleJoin</code> does not materialize the entire inner table in memory. Instead the <code>ShuffleJoin</code> partitions both inner and outer table into N files based on a hash value of the join keys. The number of shuffle files is specified through the <code>nShuffleFiles</code> field of the <i>SqlOptimizerParameters</i>. The default value is 128. The number of partitions can be also changed for the current session using the <code>setShuffleFiles(n)</code> function, which returns the previous value of this parameter. The memory footprint of the <code>ShuffleJoin</code> can be estimated as <code>(sizeof(OuterTable) + sizeof(InnerTable)) / N</code>. Note that if the number of partitions N is high (such as <code>N &gt; 1000</code>), the system can run out of file descriptors. Currently the decision of whether to use the <code>shuffle join</code> instead of the <code>hash join</code> is up to the application. The keyword <code>shuffle</code> is added to SQL, which can be used together with the standard join qualifiers (<code>left, outer, natural</code>). For example:</li>
                </ol>
                <blockquote>
                    <div class="code-block"><pre>    &#160;
    select * from A shuffle join B on A.id = B.id;
    &#160;</pre>
                    </div>
                    <p>&#160;</p>
                </blockquote>
                <h2>Relational Operators and Execution Plans</h2>
                <p>The table below describes some of the implementation considerations for relational operators and explains the pros and cons of each operator:</p>
                <table class="TableStyle-FunctionReference" style="mc-table-style: url('../../Resources/TableStyles/FunctionReference.css');margin-left: 0;margin-right: auto;width: 921px;" cellspacing="0">
                    <col style="width: 10px;" class="TableStyle-FunctionReference-Column-Column2" />
                    <col style="width: 109px;" class="TableStyle-FunctionReference-Column-Column2" />
                    <col style="width: 189px;" class="TableStyle-FunctionReference-Column-Column2" />
                    <col style="width: 239px;" class="TableStyle-FunctionReference-Column-Column2" />
                    <col style="width: 159px;" class="TableStyle-FunctionReference-Column-Column2" />
                    <tbody>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><b>Relational operation</b>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><b>“explain” plan
abbreviation</b><![CDATA[
]]></td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><b>Used by the optimizer when</b>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><b>Pros</b>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1"><b>Cons</b>
                            </td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Sequential table scan</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>SEQ-SCAN</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">No indexes are available for the query</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Records are accessed in the
sequential order (in the order in which they were written to the database)
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Large per record access
overhead.
There is no separate tablespace
</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Index scan</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>INDEX-SCAN</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">The search predicate includes key
fields; 
The result set needs to be sorted by the key
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Fast</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Generally speaking random
access to storage to access.
That can be mitigated by presorting
tables in the order of the
index through the batch insert
</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Index scan within the range (both left and right
boundaries)
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>INDEX-RANGE-SCAN</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">When the BETWEEN clause is used;
A pair of comparison operators are used
for the key
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">This is more efficient than the combination of the INDEXSCAN and FILTER, because the scan is interrupted just as soon
as possible
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Doesn't support compound keys</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Merging results of several index scans</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>INDEX-MERGE</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">The key is used in the “IN” operator, or
in multiple “OR” predicates
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Fast</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">It is efficient only for indexes
with high selectivity
</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Nested loop join</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>NESTED-LOOP-JOIN</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Is used when neither the hash nor the
index joins are possible
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Very versatile — handles any
join condition including cross
joins (all records where each
row from the first table is
combined with each row from the second table
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Very slow</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Index join</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>INDEX-JOIN</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">An index exists for the inner table join
key
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">The fastest join algorithm</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Bad locality of references (hash is not ordered in any way)</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Hash join</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>HASH-JOIN</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">An index join is not applicable and the
join condition contains only equality
comparisons
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">It is faster than the merge (sort) join</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Requires a lot of memory as the hash table for the join is built in memory. Therefore could run out of quota (if defined)</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Filter</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>FILTER</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">The query contains a WHEN clause and
there are no indexes available
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Versatile</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Slow</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Project</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>SELECT</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">To select a subset of columns (fields)</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Reduces the size of the results
set (selected data set).
Sometimes dramatically
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Requires to populate temporary records instead of using direct references to objects leading to memory and performance overhead</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Hash aggregate</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>HASH-AGGREGATE</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Simple aggregation with the GROUP BY</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">The fastest way of aggregation
with a group by
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Builds hash table in memory —
sense the memory overhead and may run out of quota
</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Grand aggregate</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>GRAND-AGGREGATE</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Simple aggregation without the GROUP BY</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">The fastest way of aggregation
without group by
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">None</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Sort aggregate</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>SORT-AGGREGATE</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Aggregation that utilizes sort operation
by the group keys
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Versatile— handles arbitrary
expressions in aggregates
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Memory overhead: requires to materialize the result set and sort it there. Can run out of quota</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Sorting</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>ORDER-BY</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Used when the query order cannot be satisfied with the index scan</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Versatile: handles an arbitrary
order clause
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Memory overhead: sorting
requires to materialize the result set. Can run out of quota
</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Top-N sort</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>ORDER-BY.LIMIT</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Used when the query includes an
ORDER-BY clause followed by a LIMIT
clause
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Retains only N records in
memory
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Can be slower than the SORT
+LIMIT combination for a
large N
</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Intersect two result sets</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>INTERSECT</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">INTERSECT clause is used</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">None except to provide
functionality
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">The input result sets have to be sorted</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Eliminates duplicates</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>DISTINCT</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">DISTINCT clause is used</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">None except to provide
functionality
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">The input data set has to be
sorted
</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Union two result sets</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>UNION</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">UNION clause is used</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">None except to provide
functionality
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">The size of the result is unknown in advance</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Combine two result sets</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>UNION-ALL</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">UNION ALL clause is used</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Fast, no memory overhead</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">The size of the result is unknown
in advance
</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Subtract two result sets</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>EXCEPT</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">EXCEPT clause is used</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">None except to provide
functionality
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">The input data sets have to be
sorted
</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Sort, then group by columns marked as
distinct and retain only the first column for each
group
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>DISTINCT-GROUP</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">This is a special eXtremeDB SQL extension</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Compact, simple and efficient
way of getting first/last records
in the group
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">This is to substitute a standard SQL WINDOW clause</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Transpose sequences to rows (vertical to
horizontal representation)
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>FLATTEN</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Select with the FLATTENED qualifier</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Allows applying standard SQL
operators to vertical data
</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">Significantly increase the result
set size
</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Limit the result set: specify the offset and the
maximum number of records in the result set
</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>LIMIT</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">The LIMIT clause is present</td>
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1">Reduce size of the result set</td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1">No fast way to skip records</td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyB-Column2-Body1">Materialize result set in memory</td>
                            <td class="TableStyle-FunctionReference-BodyB-Column2-Body1"><code>MATERIALIZE</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyB-Column2-Body1">Subquery which doesn't depend on the
outer query
</td>
                            <td class="TableStyle-FunctionReference-BodyB-Column2-Body1">Avoid redundant calculation by
buffering the result set of the
intermediate query
</td>
                            <td class="TableStyle-FunctionReference-BodyA-Column2-Body1">Large memory footprint</td>
                        </tr>
                    </tbody>
                </table>
                <p>Following are some definitions that can help understand how the optimizer determines the execution plan for a query:</p>
                <h3>Indexable Expression</h3>
                <p>An expression is an indexable expression if:</p>
                <ul>
                    <li value="1">	it is a column of the table being inspected (while performing a table join) and there is an index defined in the database schema for this field or for a set of fields (compound key) where this field is the first.</li>
                    <li value="2">	the expression is a reference access expression (<code>pointer_field.referenced_expression</code>) where <code>pointer_field</code> is a reference field of the table being inspected and <code>referenced_expression</code> is an indexable expression and there is an index defined in the database schema for <code>pointer_field</code>. In this case, <i>e</i>X<i>treme</i>SQL will first perform an index search to select records matching <code>referenced_expression</code> and then perform an index search in this table using the index for <code>pointer_field</code>, locating records in which <code>pointer_field</code> refers to one of the records in this selection.</li>
                </ul>
                <blockquote>
                    <p>For example, suppose we have two tables, <i>Supplier</i> and <i>Order</i>, and the query:</p>
                    <div class="code-block"><pre>    &#160;
    select * from Order where supplier.location.city=’New York’;
    &#160;</pre>
                    </div>
                </blockquote>
                <blockquote>
                    <p>This query can be executed using an index search if:</p>
                    <ul>
                        <li value="1">	there is an index for the field<code> location.city</code> in the <i>Supplier</i> table.</li>
                        <li value="2">	there is an index for the field <code>supplier</code> in the table <i>Order</i> (where <code>supplier</code> is a reference field having type <code><a name="kanchor357"></a>autoid_t</code> and it references the <code>autoid</code> of a <i>Supplier</i> record).</li>
                        <li value="3"><![CDATA[	]]><code>AUTOID</code> is maintained for the table <i>Supplier</i>.</li>
                    </ul>
                </blockquote>
                <blockquote>
                    <p>If these conditions are true, then <i>e</i>X<i>treme</i>SQL will first perform an index search in the table <i>Supplier</i>, selecting suppliers located in New York, and for each selected record search its <code>AUTOID</code> in the index for field <code>supplier</code> in the table <i>Order</i>.</p>
                    <p>Note that when defining a table with SQL DDL, in order for the optimizer to utilize index-based optimizations, the index fields must be declared <code>not null</code>. For example:</p>
                    <div class="code-block"><pre>    &#160;
    XSQL&gt;create table t (i int not null, j int not null);
    XSQL&gt;create index idx on t (i, j);
    &#160;</pre>
                    </div>
                </blockquote>
                <h3>Known Value</h3>
                <p>An expression is a known value if it is a literal or a query parameter, and it is a field of a table with a smaller table number than the table being inspected.</p>
                <p>For example, consider two tables:</p>
                <div class="code-block"><pre>    &#160;
    Create table Person (pid integer primary key, name string using index);
    Create table Hobby (pid person key, description string);
    &#160;</pre>
                </div>
                <p>To select all hobbies of a <i>Person</i>, there are two possible formulations of the SQL:</p>
            </blockquote>
            <blockquote>
                <p>GOOD example:</p>
                <div class="code-block"><pre>    &#160;
    Select * from Person p, Hobby h where p.name=’John Smith’ and p.pid = h.pid;
    &#160;</pre>
                </div>
                <p>BAD example:</p>
                <div class="code-block"><pre>    &#160;
    Select * from Hobby h, Person p where p.name=’John Smith’ and p.pid = h.pid;
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>From the information given earlier we know that the conjuncts will be ordered as follows:</p>
                <table class="TableStyle-FunctionReference" style="mc-table-style: url('../../Resources/TableStyles/FunctionReference.css');margin-left: 0;margin-right: auto;" cellspacing="0">
                    <col class="TableStyle-FunctionReference-Column-Column2" />
                    <col class="TableStyle-FunctionReference-Column-Column2" />
                    <tbody>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><b>GOOD EXAMPLE</b>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1"><b>BAD EXAMPLE</b>
                            </td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyE-Column2-Body1"><code>p.name = “John Smith”</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyD-Column2-Body1"><code>p.pid = h.pid</code>
                            </td>
                        </tr>
                        <tr class="TableStyle-FunctionReference-Body-Body1">
                            <td class="TableStyle-FunctionReference-BodyB-Column2-Body1"><code>p.pid = h.pid</code>
                            </td>
                            <td class="TableStyle-FunctionReference-BodyA-Column2-Body1"><code>p.name = “John Smith”</code>
                            </td>
                        </tr>
                    </tbody>
                </table>
                <p>In the GOOD example, an index search for <code>p.name = “John Smith”</code> will be evaluated first, then an index join to select its <i>Hobby</i> (or hobbies).</p>
                <p>In the BAD example, a sequential scan of <i>Hobby</i> will be processed and for each record find the related <i>Person</i> using indexed join, and then check that the name of this person is "John Smith".</p>
                <h3>Distinct</h3>
                <p>When the <code>DISTINCT</code> qualifier is in the query, then after applying all possible optimizations, all selected tuples are sorted by all columns and duplicates are removed. If the <code>ORDER BY</code> or <code>GROUP BY</code> clause is present in the statement together with the <code>DISTINCT</code> qualifier, then the fields in the <code>ORDER BY</code> or <code>GROUP BY</code> are compared first during sorting, so the sort operation is performed only once.</p>
                <p><i>e</i>X<i>treme</i>SQL uses the <i>Quicksort</i> algorithm for sorting records. <i>e</i>X<i>treme</i>SQL first extracts the sort keys into a separate array (or part of the key in case of strings), then sorts this array, and finally refines the order by performing a comparison of all columns mentioned in the <code>ORDER BY</code> list.</p>
                <h3>Order By</h3>
                <p>When a <code>tree</code> index is used to select records, selection is automatically sorted by the key corresponding to this index. If there is an explicit <code>ORDER BY</code> clause in this statement, sorting records by this key, then <i>e</i>X<i>treme</i>SQL does not perform extra sorting, since the records selected are already in the requested order. The direction (ascending or descending) of the <code>ORDER BY</code> clause should be the same as the direction specified for this field in the index.</p>
                <h3>Subquery</h3>
                <p><i>e</i>X<i>treme</i>SQL optimizes the execution of subqueries by checking the dependencies of the subquery expression. The result returned by the subquery execution is saved and only recalculated if the subquery expression refers to the fields from the enclosing scope.</p>
                <p>&#160;</p>
                <h2>Show Plan</h2>
                <p>To view the query execution plan, invoke the <code>trace(true)</code> method of the <i>SqlEngine</i> class. Then, during execution of each statement you will see a dump of the query and execution of indexed and sequential searches. Please note that <i>e</i>X<i>treme</i>SQL doesn't store query execution plans and the decision whether to apply an index or not is taken when the query is executed. In other words, <i>e</i>X<i>treme</i>SQL has no precompiled queries. Making decisions about applying indexes during query execution time allows taking into account the actual values of searched operands.</p>
                <p>For example, use an index search in query:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    db.executeQuery("select * from T where name like %s", "John%");
&#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>and use a sequential search in query:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    db.executeQuery("select * from T where name like %s", "%John%");
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>A precompiled execution plan would have insufficient information to make this judgment.</p>
            </blockquote>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>