<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="Programming with eXtremeDB|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Using eXtremeSQL Structures, Arrays and Strings in C++</title>
        <link href="../../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <script src="../../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <h1>Using <i>e</i>X<i>treme</i>SQL Structures, Arrays and Strings in C++</h1>
            <blockquote>
                <p>The following <i>e</i>X<i>treme</i>SQL sample code snippets illustrate the use of the <i>Field</i>, <i>Struct</i> and <i>Array</i> classes to access elements of structures.  The sample code uses the following schema definition:</p>
                <div class="code-block"><pre><a name="kanchor203"></a>    &#160;
    declare database structuresdb;
    struct aPoint 
    {
        int4 x;
        int4 y;
    };
    &#160;
    struct aLine 
    {
        aPoint begin;
        aPoint end;
    };
    &#160;
    struct aPolygon 
    {
        vector&lt;aPoint&gt; points;
    };
    &#160;
    class aRecord 
    {
        string s;
        int2   i2;
        aPoint p;
        int1   i1;
        int8   i8;
        float  f;
        double d;
        aLine  l;
        int1   ai1[100];
        vector&lt;aPolygon&gt; vp;
        aLine  lines[10];
        int4   i4;
        hash&lt;i4&gt; by_i4[1000];
        list;
        autoid[1000];
    };
    &#160;</pre>
                </div>
                <p>Note the embedded structures <code>aPoint</code>, <code>aLine</code> and the vector or <code>aPolygon</code> structures defined in class <i>aRecord</i>.  These are mirrored by the C++ structure definitions at the head of the following code snippets.</p>
                <div class="code-block"><pre>    &#160;
    const char * db_name = "structuresdb";
    …
    // Define global SQL engine
    using namespace McoSql;
    McoSqlEngine engine;
    &#160;
    // Define the structure correponding to database tables
    struct _Point 
    {
        int x;
        int y;
    };
    &#160;
    struct _Line 
    {
        _Point begin;
        _Point end;
    };
    &#160;
    struct _Polygon 
    {
        Array* points;
    };
    &#160;
    struct _Record 
    {
        char* s;
        short i2;
        _Point p;
        char i1;
        int64_t i8;
        float f;
        double d;
        _Line l;
        Array* ai1;
        Array* vp;
        Array* lines;
        int i4;
    };
    …
    int main( int argc, char* argv[] )
    {
        …
        engine.open( db_name, structuresdb_get_dictionary(), DATABASE_SIZE, MEMORY_PAGE_SIZE);
        &#160;
        // Insert records
        insertRecords();
        &#160;
        // Show contents (without arrays)
        showRecords();
    &#160;
        // Add arrays of ints, Polygons and Lines to Records
        addArrays();
    &#160;
        // Show contents with arrays
        showRecordArrays();
        engine.close();
    &#160;
        sample_pause_end("\n\nPress any key to continue . . . ");
        return 0;
    }
    &#160;
    void insertRecords()
    {
        …
        for (int i = 1; i &lt;= nRecords; i++)
        {
            _Record r;
            char buf[256];
            sprintf(buf, "Record %d", i);
            r.s = buf;
            r.i2 = i * 10;
            r.p.x = i + 1;
            r.p.y = i + 2;
            r.i1 = i % 10;
            r.i8 = i * 100;
            r.f = (float)i / 10;
            r.d = (double)i / 100;
            r.l.begin.x = i + 2;
            r.l.begin.y = i + 2;
            r.l.end.x = i + 3;
            r.l.end.y = i + 4;
            r.i4 = i;
            r.ai1 = NULL;
            r.vp = NULL;
            r.lines = NULL;
            engine.executeStatement("insert into aRecord %r", &amp;r);
        }
    }
    &#160;</pre>
                </div>
                <p>Some programming points to note in the code snippet “insertRecords” above:</p>
                <ul>
                    <li value="1">	The <code>Array</code> elements of the <i>_Record</i> object are initialized <code>NULL</code>.  These are given values in the function <code>addArrays()</code> (following code snippet).</li>
                    <li value="2">	The begin and end points of the <code>_Line</code> element <code>l</code> are scalar integer values set by simple assignment</li>
                </ul>
                <div class="code-block"><pre>&#160;
    void addArrays()
    {
        int i,j, k;
        ...
        for ( i = 1; i &lt;= nRecords; i++ ) 
        {
            // Get record i for updating
            QueryResult result(engine.executeQuery( "select * from aRecord where i4=%i for update", i ) );
            Cursor* cursor = result-&gt;records();
            Record* rec = cursor-&gt;next();
        &#160;
            // Get field values into Field variables
            Field* vp = result-&gt;findField("vp");
            Field* points = vp-&gt;element()-&gt;findComponent("points");
            Field* x = points-&gt;element()-&gt;findComponent("x");
            Field* y = points-&gt;element()-&gt;findComponent("y");
            Field* lines = result-&gt;findField("lines");
            Field* beg = lines-&gt;element()-&gt;findComponent("begin");
            Field* end = lines-&gt;element()-&gt;findComponent("end");
    &#160;
            // Get current contents of record into struct _Record
            _Record r;
            result-&gt;extract(rec, &amp;r, sizeof(r));
    &#160;
            // Set values of Byte array
            memset( byteArray, 0, nBytes );
            for ( j=0; j &lt; nBytes; j++ )
            byteArray[j] = ( i * nBytes) + j;
    &#160;
            r.ai1-&gt;setBody( byteArray, 0, nBytes );
    &#160;
            // Set Polygons
            r.vp-&gt;setSize( nPolygons );
            for ( j = 0; j &lt; nPolygons; j++ ) 
            {
                Struct* poly = (Struct*)r.vp-&gt;updateAt( j );
                Array* pa = (Array*)points-&gt;update( poly );
                pa-&gt;setSize(nPoints);
                for ( k = 0; k &lt; nPoints; k++) 
                {
                    Struct* point = (Struct*)pa-&gt;updateAt(k);
                    x-&gt;set( point, new IntValue( (i * 100) + j + k + 1 ) );
                    y-&gt;set( point, new IntValue( (i * 100) - j - k - 1 ) );
                }
            }
        &#160;
            // Set lines
            for ( j = 0; j &lt; nLines; j++ ) 
            {
                Struct* line = (Struct*)r.lines-&gt;updateAt(j);
                Struct* bp = (Struct*)beg-&gt;update(line);
                Struct* ep = (Struct*)end-&gt;update(line);
                x-&gt;set( bp, new IntValue( (i * 100) + j + 1 ) );
                y-&gt;set( bp, new IntValue( (i * 100) - j - 1 ) );
                x-&gt;set( ep, new IntValue( (i * 100) + j + 3 ) );
                y-&gt;set( ep, new IntValue( (i * 100) - j - 3 ) );
            }
    &#160;
            // Update the database record
            rec-&gt;updateRecord();
            }
        }
    }
    &#160;</pre>
                </div>
                <p>Some programming points to note in the code snippet <code>addArray</code> above:</p>
                <ul>
                    <li value="1">	The <i>McoSql</i> class <i>Record</i> (variable <code>rec</code>) is used to position to each record in the cursor and then initialize its array fields.</li>
                    <li value="2">	The <i>McoSql</i> class <i>Field</i> is used to get pointers to each of the structure fields <code>vp</code>, <code>aPolygon.points</code>, and <code>lines</code> as well as the scalar fields <code>x</code>, <code>y</code>, <code>begin</code> and <code>end</code>. These pointers are then used to initialize the array and structure values.</li>
                    <li value="3">	The <code>Array</code> <code>ail</code> (a <code>byte</code> array in the database <code>schema</code>) is set by calling the <i>Array</i> class <code>setBody()</code> method.</li>
                    <li value="4">	The <i>McoSql</i> class <i>Struct</i> (variable <code>poly</code>) is initialized to point to the next <i>aPolygon</i> element of the vector of <i>aPolygons</i> <code>vp</code> then the <code>Array</code> variable <code>pa</code> is initialized to point to the array of <code>aPoints</code> in the <i>aPolygon</i> structure.</li>
                    <li value="5">	The Array method <code>setSize()</code> is called to dimension the array of <code>aPoints</code>.</li>
                    <li value="6">	The <i>Struct</i> class is used again (variable <code>point</code>) to point to each <code>aPoint</code> structure in the Array</li>
                    <li value="7">	The Field varibles <code>x</code> and <code>y</code> are used to set the <code>aPoint</code> values by calling method <code>set()</code> and instantiating the value argument with the <i>IntValue</i> constructor.</li>
                    <li value="8">	The <code>lines</code> <i>Array</i> field of <i>aRecord</i> is similarly set using the <i>Struct</i> and <i>Field</i> classes.</li>
                </ul>
                <div class="code-block"><pre>&#160;
    void showRecords()
    {
        printf("\n\tRecord table contents:" );
        for ( int i=1; i &lt;= nRecords; i++ )
        {
            _Record r;
            QueryResult result( engine.executeQuery( "select * from aRecord where i4=%i", i ) );
            Cursor* cursor = result-&gt;records();
            if ( cursor-&gt;hasNext() ) 
            {
                Record* rec = cursor-&gt;next();
                result-&gt;extract( rec, &amp;r, sizeof(r) );
                printf( "\n\t%d) %s: i2=%d, i4=%d, x=%d, y=%d, f=%f, d=%f, \n\t\t"
                    "line(x1,y1,x2,y2)=%d,%d,%d,%d",
                    i, r.s, r.i2, r.i4, r.p.x, r.p.y, r.f, r.d,
                    r.l.begin.x, r.l.begin.y, r.l.end.x, r.l.end.y );
            }
        }
    }
    &#160;
    void showRecordArrays()
    {
        int i,j,k;
        printf("\n\n\tRecord Array contents:" );
        for ( i=1; i &lt;= nRecords; i++ )
        {
    &#160;
            // Get record i
            QueryResult result(engine.executeQuery( "select * from aRecord where i4=%i", i ) );
            Cursor* cursor = result-&gt;records();
            Record* rec = cursor-&gt;next();
            _Record r;
            result-&gt;extract(rec, &amp;r, sizeof(r));
            printf( "\n\n\t%d) %s: ", i, r.s );
        &#160;
            // Display Byte Array
            printf( "\n\t\tArray of %d 'i1' values: ", nBytes );
                r.ai1-&gt;getBody( byteArray, 0, nBytes );
            for ( j=0; j &lt; nBytes; j++) 
            {
                printf( "%d%s", byteArray[j], ( j == nBytes-1 ? "" : ", " ) );
            }
    &#160;
            // Display Polygon points
            printf( "\n\t\tPoints for %d Polygons : ", nPolygons );
        &#160;
            for ( j=0; j &lt; nPolygons; j++ ) 
            {
                Struct* poly = (Struct*)r.vp-&gt;getAt(j);
                Array* points = (Array*)poly-&gt;get(0);
                printf( "\n\t\t\t Polygon %d:", j+1 );
        &#160;
                for ( k=0; k &lt; nPoints; k++ )
                {
                    Struct* point = (Struct*)points-&gt;getAt(k);
                    printf( "\n\t\t\t\t%d) x=%d, y=%d ", k+1, (int)point-&gt;get(0)-&gt;intValue(), (int)point-&gt;get(1)-&gt;intValue() );
                }
            }
    &#160;
            // Display Line end points
            printf( "\n\t\tEnd points for %d Lines : ", nLines );
    &#160;
            for ( j=0; j &lt; nLines; j++ ) 
            {
                Struct* line = (Struct*)r.lines-&gt;getAt(j);
                Struct* beg = (Struct*)line-&gt;get(0);
                Struct* end = (Struct*)line-&gt;get(1);
                printf( "\n\t\t\t\t%d) begin=(%d,%d) end=(%d,%d)", j+1, (int)beg-&gt;get(0)-&gt;intValue(), (int)beg-&gt;get(1)-&gt;intValue(),
                (int)end-&gt;get(0)-&gt;intValue(), (int)end-&gt;get(1)-&gt;intValue() );
            }
        }
    }
    &#160;</pre>
                </div>
                <p>Some programming points to note in the code snippets “<code>showRecor</code>d” and  “<code>showRecordArrays</code>” above:</p>
                <ul>
                    <li value="1">	The coordinates for element point “<code>p</code>” of <i>aRecord</i> objects can be accessed directly from the <i>aRecor</i>d structure as <code>r.p.x</code> and <code>r.p.y</code>.</li>
                    <li value="2">	The coordinates of points of the <i>aPolygon</i> structures within vector element <code>vp</code> must be accessed through the <i>Struct</i> and <i>Array</i> classes; the <i>Struct</i> object <code>poly</code> is first initialized to element <code>j</code> of <code>vp</code> by method <code>getAt()</code>, then the Array <code>points</code> is set to <code>aPolygons.points</code> by the <i>Struct</i> method <code>get(0)</code> and each <code>point</code> is initialized to point to element <code>k</code> of the Array <code>points</code> and the <i>Struct</i> method <code>get(0)-&gt;intValue()</code> is called to extract and convert to integer type the value of <code>point.x</code> and <code>get(1)-&gt;intValue()</code> for <code>point.y</code>.</li>
                    <li value="3">	Similarly, the coordinates <code>begin</code> and <code>end</code> for the <code>lines</code> array are accessed and converted to integer by the <i>Struct</i> method <code>get(n)-&gt;IntValue()</code>.</li>
                </ul>
                <div class="code-block"><pre>&#160;
    // Select a struct element and string field from aRecord
    void showStruct( int x )
    {
        printf("\n\n\tExtract p.y and s fields from aRecord with p.x=%d:", x );
        QueryResult result(engine.executeQuery( "select p.y, s from aRecord where p.x=%i", x ) );
        Cursor* cursor = result-&gt;records();
        Record* rec = cursor-&gt;next();
        &#160;
        // Use Struct::get(int index) method to refer to the result column by index (0-based)
        int2 y = (int2)rec-&gt;get(0)-&gt;intValue();
        printf( "\n\t\tUsing Struct::get(int index): y=%d, s='%s'", y, rec-&gt;get(1)-&gt;pointer() );
&#160;
        // Use field descriptors
        printf( "\n\t\tUsing QueryResult::Fields iterator:" );
        int iField = 0;
        Iterator &lt;Field&gt; * fields = result-&gt;fields();
        Field * f;
        while ( f = fields-&gt;next() )
        {
&#160;
            switch ( iField )
            {
                case 0:
                    printf( "\n\t\t\tField %s=%d", f-&gt;name()-&gt;cstr(), (int)f-&gt;get(rec)-&gt;intValue() );
                    break;
                case 1:
                    printf( "\n\t\t\tField %s='%s'", f-&gt;name()-&gt;cstr(), f-&gt;get(rec)-&gt;pointer() );
            }
            iField++;
        }
        &#160;
        // Use the DataSource.extract() method. NB: The structure used must have same number
        // of fields as specified in the select statement.
        struct 
        {
            int y;
            char * s;
        } row;
        result-&gt;extract( rec, &amp;row, sizeof( row ) );
        printf( "\n\t\tUsing DataSource::extract(): y=%d, s='%s'\n", row.y, row.s );
    }
    &#160;</pre>
                </div>
                <p>Some programming points to note in the code snippet “<code>showStruct()</code>” above:</p>
                <ul>
                    <li value="1">	The condition in the <code>select</code> statement specifies “<code>where p.x=%i</code>" to filter on the value of an element in the embedded <i>Point</i> struct.</li>
                    <li value="2">	Three different methods are used to extract the result set values. In particular, note how value of the <code>struct</code> element <code>p.y</code> is managed:<ol><li value="1">	Using the <code>Struct::get(int index)</code> method to refer to the columns in the result row by index;</li><li value="2">	Using the <code>QueryResult::Fields</code> iterator to iterate over the columns in the result row;</li><li value="3">	Using the <code>DataSource::extract()</code> method to extract a <code>struct</code> that exactly corresponds with the number of columns in the result row.</li></ol></li>
                </ul>
                <p>&#160;</p>
                <h2>Arrays and Their Usage</h2>
                <p><i>e</i>X<i>treme</i>SQL accepts <i>e</i>X<i>treme</i>DB arrays (fixed length) and vectors (dynamic length) as components of records.  As with <i>e</i>X<i>treme</i>DB, multidimensional arrays are not supported. <i>e</i>X<i>treme</i>SQL provides a set of special constructions for dealing with arrays and vectors (hereafter collectively referred to as ‘<code>array</code>’):</p>
                <ul>
                    <li value="1">	It is possible to get the number of elements in the array by using the <code>length()</code> function.</li>
                    <li value="2"><![CDATA[	]]><i>Array</i> elements can be retrieved by using the <code>[]</code> operator. If the index expression is out of the array range, then an exception will be raised.</li>
                    <li value="3">	The operator <code>in</code> can be used for checking if an array contains values specified by the left operand. This operation can be used only for arrays of atomic types; with <code>boolean</code>, <code>numeric</code>, <code>reference</code> or <code>string</code> components.</li>
                    <li value="4">	Iteration through array elements is performed by the <code>exists</code> operator. Variables specified after the <code>exists</code> keyword can be used as an index in the arrays for the expression preceded by the <code>exists</code> quantor. This index variable will iterate through all the possible array index values, until the value of expression becomes true or the index exceeds the array’s range.</li>
                </ul>
                <blockquote>
                    <p>For example, given the following database schema:</p>
                    <div class="code-block"><pre>    &#160;
    class Company 
    {
        string location;
        autoid[1000];
    };
    &#160;
    class Contract 
    {
        autoid_t&lt;Company&gt; company;
        unsigned&lt;8&gt; quantity;
        date        delivery;
        autoid[1000];
    };
    &#160;
    class Detail 
    {
        string name;
        vector&lt;autoid_t&gt; contract;
    };
    &#160;</pre>
                    </div>
                </blockquote>
                <blockquote>
                    <p>the query:</p>
                    <div class="code-block"><pre>    &#160;
    select * from Detail where exists i: (contract[i].company.location = 'US');
    &#160;</pre>
                    </div>
                    <p>selects all the <i>Detail</i> records of companies located in the US.</p>
                    <p>While the query:</p>
                    <div class="code-block"><pre>    &#160;
    not exists i: (contract[i].company.location = 'US')
    &#160;</pre>
                    </div>
                    <p>selects all the <i>Detail</i> records of companies outside the US.</p>
                </blockquote>
                <p>&#160;</p>
                <h2>Vectors and Arrays</h2>
                <p><i>e</i>X<i>treme</i>SQL supports all <i>e</i>X<i>treme</i>DB data types, including the <code>vector</code> (dynamic array) type. An <i>Array</i> is created by</p>
                <div class="code-block"><pre>    &#160;
    McoSql::Array *arr = McoSql::Array::create(allocator, McoSql::tpInt8, 0, nElem);
    &#160;</pre>
                </div>
                <p>Fixed size items can be assigned by means of a pointer to an internal buffer as follows</p>
                <div class="code-block"><pre>    &#160;
    McoSql::Array * arr = McoSql::Array::create(allocator,
                McoSql::tpInt8, 0, nElem);
    int64_t * carr = (int64_t *)arr-&gt;pointer();
    for (Py_ssize_t j = 0; j &lt; nelem; j++) 
    {
        int64_t v = PyInt_AsLong(pitem);
        carr[j] = v;
    }
    &#160;</pre>
                </div>
                <p>or, alternatively, a safer method for assigning values to individual elements is</p>
                <div class="code-block"><pre>    &#160;
    int64_t val = 0;
    arr-&gt;setAt(j, &amp;val);
    &#160;</pre>
                </div>
                <p><i>e</i>X<i>treme</i>DB also supports <i>nullable arrays</i>. A <i>nullable array</i> can be created by calling the <i>Array</i> method <code>makeNullable()</code>. For example:</p>
                <div class="code-block"><pre>&#160;
    McoSql::Array *someArray;
    ...
    McoSql::Array *nullableArray = someArray-&gt;makeNullable();
    &#160;</pre>
                </div>
                <p>The newly created <code>nullableArray</code> is an instance of <i><a href="../../../Programming/C++/Classes/NullableArray.htm">NullableArray</a></i> with the contents of the original array and corresponding <i>nullBitmap</i>. The <i>nullBitmap</i> is an instance of <i>McoSql::Array</i> with elements of type <code>uint64_t</code>, where each set bit indicates that the element at the corresponding position of the array is <i>null</i>. It is possible to retrieve this bitmap using the <code>getNullBitmap()</code> method. For example:</p>
                <div class="code-block"><pre>&#160;
    McoSql::Array *nullBitmap = nullableArray-&gt;getNullBitmap();
    &#160;</pre>
                </div>
                <p>Note that the application is not required to inspect or modify this <i>nullBitmap</i> directly. It is possible to set a <i>null</i> element by passing the pointer to the <code>McoSql::Null</code> object to method <code> setAt()</code>. For example:</p>
                <div class="code-block"><pre>&#160;
    nullableArray-&gt;setAt(0, &amp;McoSql::Null);
    &#160;</pre>
                </div>
                <p>Methods <code><a href="../../../Programming/C++/Classes/Array.htm">getAt()</a></code> and <a href="../../../Programming/C++/Classes/Array.htm"><code>getCopyAt()</code></a> will return a pointer to the <code>McoSql::Null</code> object for the <i>null</i> entries of the <i><a href="../../../Programming/C++/Classes/NullableArray.htm">NullableArray</a></i>.</p>
                <h2>Strings</h2>
                <p>All operations that are applicable to <code>arrays</code> are also applicable to <code>strings</code>, which also have their own set of operations. For example, strings can be compared with each other using the standard relational operators.</p>
                <p>The construction like can be used for matching a string with a pattern containing the special wildcard characters '<code>%</code>' and '<code>_</code>'. The character '<code>_</code>' matches any single character, while the character '<code>%</code>' matches any number of characters (including 0). The extended form of the <code>like</code> operator with an escape part can be used to handle characters '<code>%</code>' and '<code>_</code>' in the pattern as normal characters only if they are preceded by the special escape character, which is specified after the escape keyword.</p>
                <p>For example,</p>
                <div class="code-block"><pre>    &#160;
    select * from T where name like '#%x%' escape '#'
    &#160;</pre>
                </div>
                <p>will select all records where the name field starts with “<code>%x</code>”</p>
                <p>It is possible to search a substring within the string by using the <code>in</code> operator. So the expression '<code>blue</code>' in color will be true for all the records for which the color field contains the string '<code>blue</code>'. For example,</p>
                <div class="code-block"><pre>    &#160;
    select * from car where 'blue' in color;
    &#160;</pre>
                </div>
                <p>will select car objects with color "<code>dark-blue</code>", "<code>blue</code>", "<code>white-and-blue</code>", "<code>light-blue</code>"...</p>
                <p><code>Strings</code> can be concatenated by using the <code>+</code> or <code>||</code> operators (+ and || may be used interchangeably). <i>e</i>X<i>treme</i>SQL doesn't support implicit conversions to the <code>string</code> type in expressions, so the semantics of the operator + has been redefined for strings. In other words, in many SQL implementations it is possible to write:</p>
                <div class="code-block"><pre>    &#160;
    1+'1'
&#160;</pre>
                </div>
                <p>and the result will be 2 (here implicit conversion is performed from string to integer).</p>
                <p>The result of</p>
                <div class="code-block"><pre>    &#160;
    1||'1'
    &#160;</pre>
                </div>
                <p>will be '11'.</p>
                <p><i>e</i>X<i>treme</i>SQL doesn't allow implicit conversion from strings, so the result of 1+'1' will be '11', the same as 1||'1'.</p>
                <p>It should be noted that every class that is inherited from base class <i>Value</i> implements a method <code>String *stringValue</code>. In all implementations of this method (except for the class <i>String</i>) a new object of  type <code>*String</code> is created, and it should be deleted after its use. The class <i>String</i> method returns <code>this</code> instead. Thus if the application deletes the string object, and then also deletes the object that the current object was inherited from, the object is deleted twice! Also once deleted, it is not possible to use the parent object either.</p>
                <p>So, to avoid confusion, instead of using the <code>String *stringValue</code> method for converting the <i>Value</i> into the <code>string</code>, it is advisable to use the  <code>Ref&lt;String&gt; stringRef(Allocator* allocator)</code> method. This method watches over the lifecycle of the object and removes it when appropriate. There are two ways to use it:</p>
                <div class="code-block"><pre>    &#160;
    Ref&lt;String&gt; strval(v-&gt;stringRef(allocator));
    &#160;</pre>
                </div>
                <p>or</p>
                <div class="code-block"><pre>    &#160;
    Ref&lt;String&gt; str = v-&gt;stringRef(allocator);
    &#160;</pre>
                </div>
                <p>The scope and usage of the reference is illustrated as follows:</p>
                <div class="code-block"><pre>    &#160;
    {
        Ref&lt;String&gt; strval(v-&gt;stringRef(allocator));
        /* use a reference as a local object String */
        printf("%s", strval.cstr());
    } /* Ref is automatically deleted here */
&#160;</pre>
                </div>
                <p>or</p>
                <div class="code-block"><pre>    &#160;
    {
        Ref&lt;String&gt; str = v-&gt;stringRef(allocator);
        /* use reference as a pointer to the  String object*/
        printf("%s", str-&gt;cstr());
    } /* Ref is automatically deleted here */
    &#160;</pre>
                </div>
                <p>&#160;</p>
                <h2>StringLiteral</h2>
                <p>The <i>StringLiteral</i> constructor has a “<code>chars</code>” member variable with a size of 1. This illustrates the standard allocation of a structure with a variable size. When this structure is allocated, it is necessary to add the size of the fixed and the variable portions of the object. In C++, it can be done by using the operator <code>new</code> with an extra parameter. However, such an operator is not predefined, and you would need to define it yourself (as it is done in the <i>DynamicObject</i> class):</p>
                <div class="code-block"><pre>    &#160;
    inline void* operator new(size_t fixed, size_t var) 
    {
        return ::new char[fixed + var];
    }
    &#160;</pre>
                </div>
                <p>Now the <i>string</i> literal can be created in the following way:</p>
                <div class="code-block"><pre>    &#160;
    char const* str = "Hello World";
    size_t length = strlen(str);
    Value* value = ::new (length) StringLiteral(str, length);
    &#160;</pre>
                </div>
                <p>There are two alternatives:</p>
                <blockquote>
                    <p>1.	Use the <i>StringRef</i> class for which the constructor is given a pointer to the <code>string</code> and it is the responsibility of the programmer to de-allocate the <code>string</code> when it is not needed any longer.</p>
                    <p>2.	Define your own class extending the <i>String</i> class:</p>
                    <div class="code-block"><pre>    &#160;
    class UserString : public String 
    {
        public:
        virtual int size();
        virtual char* body();
        virtual char* cstr();
        &#160;
        private:
        const int length;
        char* chars;
        &#160;
        public:
        UserString(char const* s, int l);
        ~UserString();
    };
&#160;
    int UserString::size()
    {
        return length;
    }
&#160;
    UserString::UserString(char const* s, int l) : length(l)
    {
        chars = new char[l+1];
        memcpy(chars, s, l);
        chars[l] = '\0';
    }
    &#160;
    UserString::~UserString()
    {
        delete[] chars;
    }
&#160;
    char* UserString::body()
    {
        return chars;
    }
&#160;
    char* UserString::cstr()
    {
        return chars;
    }
    &#160;</pre>
                    </div>
                </blockquote>
                <p>&#160;</p>
                <h2>Binary Data</h2>
                <p><i>Binary</i> and <i>varbinary</i> data that may contain zeroes can be stored in an <i>e</i>X<i>treme</i>SQL <code>byte</code>-array or fields of type <code>binary</code> or <code>varbinary</code>. To insert binary data with embedded zeroes  into or  retrieve from a field of type <code>byte</code>-array, use the <i>Array</i> <code>putBody()</code> or getBody() methods.  For example, in the schema definition:</p>
                <div class="code-block"><pre>    &#160;
    class t
    {
        signed&lt;1&gt; b[16];
        list;
    };
    &#160;</pre>
                </div>
                <p>the field “<code>b</code>” is a <code>byte</code>-array and will be accessed within application code as an Array - use the <code>Array::getBody()</code> method to get the contents of the array.</p>
                <p>If an index is required on binary data, the field must be of type <code>binary</code> or <code>varbinary</code>. For example, in the schema definition:</p>
                <div class="code-block"><pre>    &#160;
    class bin_array 
    {
        unsigned&lt;4&gt;             idx;
        binary&lt;16&gt;              bin_array;
        &#160;
        userdef tree&lt;bin_array&gt; binkey;
        kdtree &lt;idx, bin_array&gt; binkey_kd;
        patricia&lt;bin_array&gt;     binkey_p;
    };
    &#160;
    class bin_vector 
    {
        unsigned&lt;4&gt;                     idx;
        varbinary                       bin_vector;
&#160;
        userdef tree&lt;idx, bin_vector&gt;   binkey;
        kdtree &lt;idx, bin_vector&gt;        binkey_kd;
        patricia&lt;bin_vector&gt;            binkey_p;
    };
    &#160;</pre>
                </div>
                <p>The C++ class Binary is used to access binary fields. The following code snippet demonstrates how binary data access might be implemented:</p>
                <div class="code-block"><pre>&#160;
    struct _bin_cls 
    {
        int             idx;
        Value       *bin;
    }
    ...
    _bin_cls bin_cls;
&#160;
    //
    // Put new data to a database
    //
    char buf_in[4096];
    ...
    // Assume buf_in contains valuable data
    // Create Binary object and copy
    Binary* b = Binary::create(engine.getAllocator(), sizeof(buf_in));
    memcpy(b-&gt;body(), buf_in, sizeof(buf_in));
    bin_cls.idx = 1;
    bin_cls.bin = (Value *)b;
    engine.executeStatement("insert into bin_cls %r", _bin_cls);
    DELETE_OBJ(engine.getAllocator(), b);
    ...
&#160;
    //
    // Get query result
    //
    QueryResult result( engine.executeQuery( "select * from bin_cls" ) );
    Cursor* cursor = result-&gt;records();
    Record* rec = cursor-&gt;next();
    &#160;
    McoSql::ValueRef eref(rec-&gt;get(1));
    McoSql::Binary *bin = eref.as&lt;McoSql::Binary&gt;(); // will be deleted automatically by resultSet's allocator
&#160;
    size_t len = bin-&gt;length;
    char buf_out[len];
    memcpy(buf_out, bin-&gt;body(), len);
    &#160;</pre>
                </div>
                <p>Alternatively, placeholder <code>%v</code> can be used to substitute a <code>binary</code> or <code>varbinary</code> value into an SQL string:</p>
                <div class="code-block"><pre>&#160;
    //
    // Put new data to a database
    //
    char buf_in[4096];
&#160;
    // Assume buf_in contains valuable data
    // Create Binary object and copy
    Binary* b = Binary::create(engine.getAllocator(), sizeof(buf_in));
    memcpy(b-&gt;body(), buf_in, sizeof(buf_in));
    engine.executeStatement("insert into bin_cls values (%i, %v)",  1, b);
    DELETE_OBJ(engine.getAllocator(), b);
    &#160;</pre>
                </div>
                <p>From the perspective of SQL there are two data types: <code>binary(n)</code> that maps to storage type <code>binary&lt;n&gt;</code>, and <code>varbinary</code> that maps to  storage type <code>varbinary</code>. (Both types are mapped internally to the <code>tpBinary</code> type from the perspective of the SQL C++ API class <code>Value</code>). Data for binary fields can be passed as a string in hex-format in SQL. For example:</p>
                <div class="code-block"><pre>&#160;
    create table t (idx int, bin binary(4));
    insert into t values(1, '0A0D0A0D' );
    &#160;</pre>
                </div>
                <p>Also it is possible to create arrays and vectors of <code>binary</code> and <code>varbinary</code> via SQL. For example:</p>
                <div class="code-block"><pre>&#160;
    create table t (idx int, bin array(binary(4), 10)); // Array of binary
    create table t (idx int, bin array(varbinary)); // Vector of varbinary
    &#160;</pre>
                </div>
                <h2>Dynamic objects</h2>
                <p>The <code>new</code> operator is now overloaded to use the static <i>StdAllocator</i> and all dynamic objects must pass the allocator as an argument to the <code>new</code> operator. Whereas in versions of <i>e</i>X<i>treme</i>SQL previous to 6.5, dynamic objects were created with code like the following:</p>
                <div class="code-block"><pre>    &#160;
    int val = 1;
    ...
    return new IntValue(val);
    &#160;</pre>
                </div>
                <p>Now dynamic objects must use the <i>StdAllocator</i> in code like the following:</p>
                <div class="code-block"><pre>    &#160;
    Allocator * allocator = engine.getAllocator();
    int val = 1;
    ...
    return new (allocator) IntValue(val);
    &#160;</pre>
                </div>
                <p>or alternatively use the static <code>create()</code> method in code like the following:</p>
                <div class="code-block"><pre>    &#160;
    Allocator * allocator = engine.getAllocator();
    int val = 1;
    ...
    return IntValue::create(allocator,val);
    &#160;</pre>
                </div>
                <p>(Note that in any API calls like <code>new</code> requiring the allocator, a pointer to the allocator can be obtained from the <i>McoSqlEngine</i> as in the example code above or from any of the Container subclasses such as <i>Record</i>, <i>DataSource</i>, <i>Array</i>, <i>Blob</i>. Any objects allocated with the <i>McoSqlEngine</i> allocator will not be implicitly deleted; i.e. they will remain in memory until the engine itself is destroyed unless explicitly destroyed (see below). However, if operating within a Query, the allocator can be obtained from the <i>QueryResult</i> object; and this allocator and all objects allocated with it will be destroyed when the query finishes.)</p>
                <p>To explicitly remove dynamic objects created with the <code>new</code> operator, use the macros <code>DELETE</code> or <code>DESTROY</code> (provided in the public header file <code>basedef.h</code>).</p>
                <h1>Using References</h1>
                <p>In <i>e</i>X<i>treme</i>SQL tables are often joined by using <code>references</code> to implement an SQL “foreign keys” relation between tables that provide fast and direct access to the record by <code>AUTOID</code>. Reference fields can also be indexed and used in the <code>ORDER BY</code> clause. References can be de-referenced using the same dot notation as used in accessing structure components.</p>
                <p>For example, the following database schema:</p>
                <div class="code-block"><pre>    &#160;
    class Address 
    {
        string city;
        autoid[1000];
        hash&lt;city&gt; city_index[1000];
    };
    &#160;
    class Company 
    {
        autoid_t&lt;Address&gt; address;
        autoid[10000];
        hash&lt;address&gt; address_index[10000];
    };
    &#160;
    class Contract 
    {
        autoid_t&lt;Company&gt; company;
        autoid[10000];
        hash&lt;company&gt; company_index[10000];
    };
    &#160;</pre>
                </div>
                <p>when queried with the statement</p>
                <div class="code-block"><pre>    &#160;
    select * from Contract where company.address.city = 'Chicago';
    &#160;</pre>
                </div>
                <p>will retrieve <i>Contract</i> records where the referenced <i>Company</i> references an <i>Address</i> with the <code>city</code> field equal to ‘Chicago’. The query execution plan for this request is the following:</p>
                <ol>
                    <li value="1">	Perform an index search of the <i>Address</i> table using <code>city_index (city = ‘Chicago’)</code></li>
                    <li value="2">	For all selected <i>Address</i> records, locate <i>Company</i> records referencing these addresses using <code>address_index</code></li>
                    <li value="3">	For all selected <i>Company</i> records, locate <i>Contract</i> records referencing these <i>Company</i> records using <code>company_index</code></li>
                </ol>
                <p>References can be checked for <code>null</code> by the <code>is null</code> or <code>is not null</code> predicates. They can also be compared for equality with each other, as well as with the special null keyword. When a null reference is de-referenced, an exception is raised by <i>e</i>X<i>treme</i>SQL.</p>
                <p>The following sample schema illustrates three tables that could be used to model a <i>Customer</i>-<i>Orders</i> application:</p>
                <div class="code-block"><pre>&#160;
    declare database referencesdb;
    class Address
    {
        int4   zipcode;
        string city;
        string street;
        hash&lt;zipcode&gt; iaddr[100000];
        autoid[100000];
        list;
    };
    &#160;
    class Company 
    {
        autoid_t&lt;Address&gt; location;
        string            name;
        hash&lt;name&gt; iname[100000];
        hash&lt;location&gt; iaddr[100000];
        autoid[100000];
        list;
    };
    &#160;
    class Orders 
    {
        autoid_t&lt;Company&gt; company;
        date              shipment;
        uint8             amount;
        string            description;
    &#160;
        hash&lt;company&gt; icomp[100000];
        list;
    };
    &#160;</pre>
                </div>
                <p>Note that there is a one-many relationship between the <i>Company</i> and <i>Orders</i> tables, i.e. many instances of the class <i>Order</i> might have the same value for the <code>autoid</code> field “<code>company</code>”.  This field <code>company</code> is a <code>reference</code> to exactly one <i>Company</i> object that results in optimal lookup time. Likewise the relationship between <i>Company</i> and <i>Address</i> tables is implemented in the reference field <code>location</code>.  The following sample code snippets demonstrate how these reference fields are used in <i>e</i>X<i>treme</i>SQL:</p>
                <div class="code-block"><pre>    &#160;
    const char * db_name = "joindb";
    &#160;
    // Define global SQL engine
    using namespace McoSql;
    McoSqlEngine engine;
    &#160;
    // Define the structure correponding to database tables
    struct _Address
    {
        int4        zipcode;
        char const* city;
        char const* street;
    };
    &#160;
    int main()
    {
        …
        engine.open( db_name, referencesdb_get_dictionary(), DATABASE_SIZE, MEMORY_PAGE_SIZE);
        &#160;
        // Insert records
        insertRecords();
        &#160;
        // Search Addresses by zip
        searchAddresses();
    &#160;
        // Show Company-Addresses
        showJoin1();
        &#160;
        // Show Company-Orders
        showJoin2();
    &#160;
        // Show Company-Orders where desc like '%1%'
        showJoin3();
    &#160;
        // Clean up
        deleteRecords();
        engine.close();
    &#160;
        sample_pause_end("\n\nPress any key to continue . . . ");
        return 0;
    }
    &#160;
    void showJoin1()
    {
        printf("\n\n\tSELECT C.name FROM Address A,Company C ...");
        for (int i = 1; i &lt;= nRecords; i++)
        {
            QueryResult result( engine.executeQuery( "SELECT C.name FROM Address A,Company C "
                    "WHERE A.zipcode=%i AND
                    A.autoid=C.location", i ) );
            Cursor* iterator = result-&gt;records();
            assert(iterator-&gt;hasNext());
            Record* rec = iterator-&gt;next();
            String * pName = (String*)rec-&gt;get(0);
            printf( "\n\t\t%d) %s", i, pName-&gt;body() );
        }
    }
    &#160;
    void showJoin2()
    {
        printf("\n\n\tSELECT C.name, O.description FROM Address A,Company C,Orders O ...");
        for (int i = 1; i &lt;= nRecords; i++)
        {
            QueryResult result( engine.executeQuery( "SELECT C.name, O.description "
                        "FROM Address A,Company C,Orders O "
                        "WHERE A.zipcode=%i AND A.autoid=C.location"
                        " AND C.autoid=O.company", i ) );
            Cursor* iterator = result-&gt;records();
            assert(iterator-&gt;hasNext());
            Record* rec = iterator-&gt;next();
            String * pName = (String*)rec-&gt;get(0);
            String * pDesc = (String*)rec-&gt;get(1);
            printf( "\n\t\t%d) %s: %s", i, pName-&gt;body(), pDesc-&gt;body() );
        }
    }
    &#160;
    void showJoin3()
    {
        printf("\n\n\tSELECT C.name, O.description ... WHERE O.description like '%%1%%' ...");
        for (int i = 1; i &lt;= nRecords; i++)
        {
            QueryResult result( engine.executeQuery( "SELECT C.name, O.description "
                        "FROM Address A,Company C,Orders O "
                        "WHERE O.description like '%1%' AND "
                        "A.zipcode=%i AND A.autoid=C.location "
                        "AND C.autoid=O.company", i ) );
            Cursor* iterator = result-&gt;records();
            while ( iterator-&gt;hasNext() ) 
            {
                Record* rec = iterator-&gt;next();
                String * pName = (String*)rec-&gt;get(0);
                String * pDesc = (String*)rec-&gt;get(1);
                printf( "\n\t\t%d) %s: %s", i, pName-&gt;body(), pDesc-&gt;body() );
            }
        }
    }
    &#160;</pre>
                </div>
                <p>Some programming points to note in the code snippets <code>showJoin1</code>, <code>showJoin2</code>  and <code>showJoin3</code> above:</p>
                <ul>
                    <li value="1">	The <i>McoSQL</i> class <i>String</i> is used to access the <code>Company.Name</code> and <code>Order.Description</code> fields by calling method <code>get(n)</code>.</li>
                    <li value="2">	The <code>string</code> values are printed out by calling the <code>String</code> method “<code>body()</code>”.</li>
                </ul>
                <p>&#160;</p>
                <h1>Searching through a Vector or Array</h1>
                <p>It is possible to search through a vector or array using the SQL <code>IN</code> operator, for example:</p>
                <div class="code-block"><pre>    &#160;
    select * from T where ? in T.vector;
    &#160;</pre>
                </div>
                <p>The above statement works for vectors of <code>scalar</code> types, but for vectors of compound types an <i>e</i>X<i>treme</i>DB specific expression must be used.  For example, using the following schema definition:</p>
                <div class="code-block"><pre>    &#160;
    struct E 
    {
        uint4 q1;
        uint4 q2;
        vector&lt;D&gt; q3;
    };
    &#160;
    class R
    {
        uint4 r1;
        E     r2;
        tree &lt;r2.q1&gt; by_r2e1;
    };
    &#160;</pre>
                </div>
                <p>a proper <code>select</code> statement would be like the following:</p>
                <div class="code-block"><pre>    &#160;
    select * from R where exists i: (exists j: (r2.q3[i].d3[j].c1=1));
    &#160;</pre>
                </div>
                <p>However, note that such a query requires a sequential search and a quadratic iteration through all of the possible values of the indexes, and will consequently be quite slow (thus is inadvisable).</p>
                <p>&#160;</p>
            </blockquote>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../../../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>