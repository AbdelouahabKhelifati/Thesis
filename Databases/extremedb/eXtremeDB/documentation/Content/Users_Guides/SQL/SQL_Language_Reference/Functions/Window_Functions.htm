<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="extremedb.xml" data-mc-path-to-help-system="../../../../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="Programming with eXtremeDB|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]|[%=System.LinkedTitle%]">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>eXtremeSQL Window Functions</title>
        <link href="../../../../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../../../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../../../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../../../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../../../../Resources/Stylesheets/KB_Style.css" rel="stylesheet" />
        <script src="../../../../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../../../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../../../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../../../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../../../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../../../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../../../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="TopicContent">
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="7" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">ToC path: </span>
                </div>
            </div>
            <h1><i>e</i>X<i>treme</i>SQL Window Functions</h1>
            <blockquote>
                <p>A “Window function” is a variation on an aggregation function. Where an aggregation function, like <code>SUM()</code> and <code>AVG()</code>, takes <code>n</code> inputs and returns a single value, a window function returns <code>n</code> values.</p>
                <p>For example, consider the simple table defined as:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    CREATE TABLE test(i int);
    INSERT INTO test VALUES(1),(2),(3),(4),(5);
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The <code>SUM()</code> and <code>AVG()</code>aggregate functions return the following values:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT SUM(i), AVG(i) FROM test;
    #1      #2
    ------------------------------------------------------------------------------
    15      3
    Selected records: 1
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>In an SQL <code>SELECT</code> statement, the <code>OVER</code> keyword indicates that the preceding function is to be applied to a <code>window</code> representing a group of rows relative to the current row in the result set of the query. For example, the window functions <code>SUM()</code> and <code>AVG()</code> return the following values:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT i, SUM(i) OVER(), AVG(i) OVER() FROM test;
    i       #2      #3
    ------------------------------------------------------------------------------
    1       1       1
    2       3       1.5
    3       6       2
    4       10      2.5
    5       15      3
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The output of a window function depends on a number of input values (function arguments, computed values from other rows in the frame, etc.), so they don’t include functions that work element-wise, like + or <code>ROUND()</code>. Window functions include variations on aggregate functions, like <code>SUM()</code>, <code>AVG()</code>, <code>MIN()</code> and <code>MAX()</code>, functions for ranking and ordering, like <code>RANK()</code>, and functions for taking offsets, like <code>LEAD()</code> and <code>LAG()</code>.</p>
                <p>
                    <img src="../../../../Resources/Images/note.png" />Note that these SQL window functions are not to be confused with the “<a href="../../../../Programming/SQL/Analytics_Functions/Window_Agg_Functions.htm">Window_Agg</a>” functions in the Vector-based Analytics Library. The “<a href="../../../../Programming/SQL/Analytics_Functions/Window_Agg_Functions.htm">Window_Agg</a>” functions operate only on sequences (i.e. fields of type sequence) where the “window” is specified as a fixed number of elements (i.e. interval) to perform computations on.</p>
                <h2>Window function syntax</h2>
                <p>A window function call always contains an <code>OVER</code> clause directly following the window function's name and argument(s). This is what syntactically distinguishes it from a regular function or aggregate function. The <code>OVER</code> clause determines exactly how the rows of the query are to be split up for processing by the window function. A <code>PARTITION BY</code> list within the <code>OVER</code> clause can be used for dividing the rows into groups, or partitions that share the same values specified in the <code>PARTITION BY</code> expression(s). For each row, the window function is computed across the rows that fall into the same partition as the current row.</p>
                <p>For a given window we can specify:</p>
                <ul>
                    <li value="1">	the order of the rows in the window (the <code>ORDER BY</code> clause)</li>
                    <li value="2">	a subset of the table data to operate on (the <code>PARTITION BY</code> clause)</li>
                    <li value="3">	the window defined by the previous two clauses can be further narrowed down into frames of  rows by use of the <code>ROWS BETWEEN</code> clause which can be:<ul style="list-style-type: circle;"><li value="1">	bounded – eg. <code>ROWS BETWEEN 2 PRECEDING AND CURRENT ROW</code></li><li value="2">	partially bounded – eg. <code>ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</code></li><li value="3">	unbounded – eg. <code>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code></li></ul></li>
                    <li value="4">	 “logical” <code>frames</code> can also be defined through the <code>RANGE BETWEEN</code> option (see “Specifying window frames” below)</li>
                </ul>
                <p>The following window functions are supported. Note that those below “for ordered rows” require an <code>ORDER BY</code> clause in the <code>OVER</code> specification:</p>
                <ul>
                    <li value="1"><i>aggregate functions</i>
                    </li>
                </ul>
                <blockquote>
                    <ul style="list-style-type: circle;">
                        <li value="1"><code>count</code> – the cumulative row count</li>
                        <li value="2"><code>row_number</code> – the row number</li>
                        <li value="3"><code>min</code> – the minimum value</li>
                        <li value="4"><code>max</code> – the maximum value</li>
                        <li value="5"><code>sum</code> – the cumulative sum of this and preceding rows</li>
                        <li value="6"><code>avg</code> – the average of this row and all previous rows</li>
                        <li value="7"><code>median</code> - the median of this row and all previous rows</li>
                    </ul>
                </blockquote>
                <ul>
                    <li value="1"><![CDATA[	]]><i>for ordered rows</i></li>
                </ul>
                <blockquote>
                    <ul style="list-style-type: circle;">
                        <li value="1"><![CDATA[	]]><code>first_value</code> – the first value</li>
                        <li value="2"><code>	last_value</code> – the last value</li>
                        <li value="3"><![CDATA[	]]><code>nth_value</code> – the specified nth value</li>
                        <li value="4"><code>	lead</code> – access a row at a specified offset after the current row</li>
                        <li value="5"><![CDATA[	]]><code>lag</code> – access a row at a specified offset before the current row</li>
                        <li value="6"><code>rank</code> – the rank of the value in this row (there can be gaps in the sequence of ranks)</li>
                        <li value="7"><![CDATA[	]]><code>dense_rank</code> – the rank of the value in this row (with no gaps in the sequence of ranks)</li>
                        <li value="8"><![CDATA[	]]><code>percent_rank</code> – used for computing the percentile of this row</li>
                        <li value="9"><![CDATA[	]]><code>ntile</code> - distributes the rows into a specified number of groups</li>
                    </ul>
                </blockquote>
                <h2>Specifying window frames</h2>
                <p>The window frame for each row of the result set is determined by specifying <code>BETWEEN</code> bounds. These <code>BETWEEN</code> bounds can be specified by either <code>ROWS</code> or <code>RANGE</code> options. The <code>ROWS</code> option defines a fixed number of rows preceding and following the current row; and the rows that will comprise the frame will be determined by the <code>ORDER BY</code> clause. If no bounds are explicitly specified, the default frame is from the first row (<code>UNBOUNDED PRECEDING</code>) to the current row.</p>
                <p>
                    <img src="../../../../Resources/Images/note.png" /> Note that the <code>BETWEEN</code> bounds must be specified with <i>explicit constant</i> values, <i>not with parameters</i>. For example, the following statement <i>is not valid</i>:</p>
                <blockquote>
                    <div class="code-block"><pre>    &#160;
    SELECT stamp, SUM(price*quantity) OVER w AS pq1, SUM(quantity) OVER w AS vol, pq1/vol AS VWAP
    FROM Quotes
    WINDOW w AS (PARTITION BY pkid ORDER BY stamp RANGE BETWEEN ? PRECEDING AND 0 FOLLOWING)
    &#160;</pre>
                    </div>
                    <p>Here the parameter substitution "<code>BETWEEN ? PRECEDING</code>" is not allowed. </p>
                    <p>Instead the following statement using constant value <code>5</code> is valid:</p>
                    <div class="code-block"><pre>&#160;
    SELECT stamp, SUM(price*quantity) OVER w AS pq1, SUM(quantity) OVER w AS vol, pq1/vol AS VWAP
    FROM Quotes
    WINDOW w AS (PARTITION BY pkid ORDER BY stamp RANGE BETWEEN 5 PRECEDING AND 0 FOLLOWING)
    &#160;</pre>
                    </div>
                </blockquote>
                <p>If the <code>RANGE</code> option is used, then all rows within the frame that have the same <code>ORDER BY</code> value as the current row will be included in that row’s function computation. To illustrate the difference between <code>physical</code> <code>ROWS BETWEEN</code> frames and <code>logical</code> <code>RANGE BETWEEN</code> frames, we will add a column to the example table test and insert values as follows:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    ALTER TABLE test ADD val int;
    UPDATE test SET val=100 WHERE i=1;
    UPDATE test SET val=200 WHERE i=2;
    UPDATE test SET val=200 WHERE i=3;
    UPDATE test SET val=200 WHERE i=4;
    UPDATE test SET val=300 WHERE i=5;
    SELECT * FROM test;
    i       val
    ------------------------------------------------------------------------------
    1       100
    2       200
    3       200
    4       200
    5       300
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>Now to compute the sum over the physical frame of <code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code> (the default frame) we could perform a query like the following:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT i, val, SUM(val) OVER(ORDER BY val ROWS BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW) AS Row_Sum FROM test;
    i       val     Row_Sum
    ------------------------------------------------------------------------------
    1       100     100
    2       200     300
    3       200     500
    4       200     700
    5       300     1000
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>Note that <code>SUM(val)</code> is calculated as the sum of the value val for the current row plus its value for all preceding rows. To compute the sum over the logical frame <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code> we could perform a query like the following:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT i, val, SUM(val) OVER(ORDER BY val RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW) AS Range_Sum FROM test;
    i       val     Range_Sum
    ------------------------------------------------------------------------------
    1       100     100
    2       200     700
    3       200     700
    4       200     700
    5       300     1000
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>Note that the <code>ORDER BY</code> value of column val is the same for rows 2, 3 and 4; so <code>SUM(val)</code> here is calculated for these rows as <code>100 + 200 + 200 + 200 = 700</code>.</p>
                <p>&#160;</p>
                <h2>Examples</h2>
                <p>The following examples use data from Washington DC’s Capital Bikeshare Program, which publishes detailed trip-level historical data on their website. Each row represents one ride. The following import script was used to create the table bikes, the index <code>bike_num_idx</code> to speed up lookups by <code>bike_num</code>, and then insert the sample data:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    CREATE TABLE bikes(duration int, start_date string, end_date string, start_st_num int,
    start_st string, end_st_num int, end_st string, bike_num string,
    member_type string);
    INSERT INTO bikes SELECT * from foreign table(path='2016-Q1-Trips-History-Data.csv', delimiter=',', skip=1) AS bikes;
    CREATE INDEX bike_num_idx ON bikes(bike_num);
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>A simple practical example of a Window function is calculating a running total. For example the following query creates an aggregation (<code>running_total</code>) as the cumulative sum of field duration (note that this is without using a <code>GROUP BY</code> clause):</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT duration, start_date, SUM(duration) OVER (ORDER BY start_date) AS running_total
    FROM bikes WHERE bike_num = 'W22196' AND start_date &gt;= '3/31/2016';
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The first part of the above aggregation, <code>SUM(duration)</code>, looks similar to any other aggregation. Adding the keyword <code>OVER</code> designates it as a window function. So the above aggregation could be read as “take the sum of duration over the entire result set, in order of <code>start_date</code>”. Here, for brevity of output, we have specified a <code>WHERE</code> clause for a <code>bike_num (W22196)</code> and a single day (3/31/2016) with a limited number of trips. The result set shows how the <code>running_total</code> displays the cumulative sum:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    duration        start_date        running_total
    ------------------------------------------------------------------------------
    456465  	 3/31/2016 0:05    456465
    300889  	 3/31/2016 14:25   757354
    1001144 	 3/31/2016 23:51   1758498
    577035  	 3/31/2016 8:20    2335533
    Selected records: 4
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The following query demonstrates the use of a <code>PARTITION BY</code> clause to calculate the cumulative sum for blocks of result set rows grouped by the start terminal number <code>start_st_num</code> and ordered by <code>start_date</code>:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT start_st_num, duration, start_date, SUM(duration)
    OVER (PARTITION BY start_st_num ORDER BY start_date) AS running_total
    FROM bikes WHERE bike_num = 'W22196' AND start_st_num BETWEEN 31610 and 31625;
    start_st_num    duration   start_date        running_total
    ------------------------------------------------------------------------------
    31624   	 1375776    1/12/2016 18:28   1375776
    31624   	 396755     1/21/2016 8:47    1772531
    31624   	 988750     1/7/2016 19:38    2761281
    31624   	 203844     2/29/2016 10:26   2965125
    31624   	 987070     3/11/2016 16:30   3952195
    31624   	 372239     3/11/2016 18:09   4324434
    31623   	 602551     1/14/2016 7:02    602551
    31623   	 691224     1/16/2016 21:03   1293775
    31623   	 372176     1/18/2016 12:40   1665951
    31623   	 278196     1/20/2016 13:48   1944147
    31623   	 389189     1/7/2016 7:42     2333336
    31623  		 387578     3/29/2016 18:44   2720914
    31622   	 382357     1/18/2016 8:24    382357
    31622   	 797607     1/19/2016 8:36    1179964
    31622   	 508194     3/30/2016 9:09    1688158
    31621   	 837364     1/13/2016 17:37   837364
    31621   	 143947     3/1/2016 8:52     981311
    31620   	 188661     3/27/2016 12:22   188661
    31620   	 300889     3/31/2016 14:25   489550
    31618 		 3336939    3/30/2016 14:09   3336939
    31615   	 216014     1/6/2016 16:36    216014
    31615   	 577035     3/31/2016 8:20    793049
    31613   	 1493051    3/30/2016 10:18   1493051
    Selected records: 23
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>This query groups the results by <code>start_st_num</code>. Note that within each value of <code>start_st_num</code>, the running total sums duration across the current row and all previous rows of that window. This is the effect of the <code>PARTITION BY</code> clause. Also note that the optional <code>ORDER BY</code> clause simply orders by the designated column(s) the same way that an <code>ORDER BY</code> clause would for the <code>SELECT</code> statement, except that it treats every partition separately.</p>
                <p>
                    <img src="../../../../Resources/Images/note.png" />Note that you cannot use window functions and standard aggregations in the same query. More specifically, you can’t include window functions in a <code>GROUP BY</code> clause.</p>
                <p>As the <code>SUM()</code> function calculates the cumulative sum, similarly the <code>COUNT()</code>and <code>AVG()</code> functions calculate the cumulative number of rows in the partition and their average. For example:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT start_st_num, duration, start_date,
    SUM(duration) OVER (PARTITION BY start_st_num ORDER BY start_date) AS running_total,
    COUNT(duration) OVER (PARTITION BY start_st_num ORDER BY start_date) AS running_count,
    AVG(duration) OVER (PARTITION BY start_st_num ORDER BY start_date) AS running_avg
    FROM bikes WHERE bike_num = 'W22196' and start_st_num BETWEEN 31610 and 31625;
    start_st_num    duration start_date  running_total running_count  running_avg
    ------------------------------------------------------------------------------
    31624   1375776 1/12/2016 18:28 	1375776 	1       	1375776
    31624   396755  1/21/2016 8:47  	1772531 	2       	886265.5
    31624   988750  1/7/2016 19:38  	2761281 	3       	920427
    31624   203844  2/29/2016 10:26 	2965125 	4       	741281.25
    31624   987070  3/11/2016 16:30 	3952195 	5       	790439
    31624   372239  3/11/2016 18:09 	4324434 	6       	720739
    31623   602551  1/14/2016 7:02  	602551  	1       	602551
    31623   691224  1/16/2016 21:03 	1293775 	2       	646887.5
    31623   372176  1/18/2016 12:40 	1665951 	3       	555317
    31623   278196  1/20/2016 13:48 	1944147 	4       	486036.75
    31623   389189  1/7/2016 7:42   	2333336 	5       	466667.2
    31623   387578  3/29/2016 18:44 	2720914 	6       	453485.666666667
    31622   382357  1/18/2016 8:24  	382357  	1       	382357
    31622   797607  1/19/2016 8:36  	1179964 	2       	589982
    31622   508194  3/30/2016 9:09  	1688158 	3       	562719.333333333
    31621   837364  1/13/2016 17:37 	837364  	1       	837364
    31621   143947  3/1/2016 8:52   	981311  	2       	490655.5
    31620   188661  3/27/2016 12:22 	188661  	1       	188661
    31620   300889  3/31/2016 14:25 	489550  	2       	244775
    31618   3336939 3/30/2016 14:09 	3336939 	1       	3336939
    31615   216014  1/6/2016 16:36  	216014  	1       	216014
    31615   577035  3/31/2016 8:20  	793049  	2       	396524.5
    31613   1493051 3/30/2016 10:18 	1493051 	1       	1493051
    Selected records: 23
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>To demonstrate the next set of functions we will use a simple table and dataset created by the following script:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    CREATE TABLE test(i int);
    INSERT INTO test VALUES(1),(2),(3),(4),(5);
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The <code>LAG()</code> and <code>LEAD()</code>functions return the value for the specified row following or preceding the current row, respectively:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT i,
    LAG(i,1) OVER (ORDER BY i ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING),
    LEAD(i,1) OVER (ORDER BY i ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM test;
    i       #2      #3
    ------------------------------------------------------------------------------
    1       null    2
    2       1       3
    3       2       4
    4       3       5
    5       4       null
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The <code>MIN()</code> and <code>MAX()</code>functions return the minimal and the maximum values respectively for the specified frames. For example, when using the default bounds (<code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>), the <code>MIN()</code> and <code>MAX()</code>are determined by the ever increasing frame. For example:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT i, MIN(i) OVER (ORDER BY i), MAX(i) OVER (ORDER BY i) FROM test;
    i       #2      #3
    ------------------------------------------------------------------------------
    1       1       1
    2       1       2
    3       1       3
    4       1       4
    5       1       5
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>But when an unbounded frame is specified (<code>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code>) the minimum and maximum values are for the entire window:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT i,
    MIN(i) OVER (ORDER BY i ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING),
    MAX(i) OVER (ORDER BY i ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
    FROM test;
    i       #2      #3
    ------------------------------------------------------------------------------
    1       1       5
    2       1       5
    3       1       5
    4       1       5
    5       1       5
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The functions <code>LAST_VALUE()</code>, <code>FIRST_VALUE()</code>, and <code>NTH_VALUE()</code> with no boundaries specified and ordering by the field <code>i</code> will produce 5 frames and the value of <code>LAST_VALUE()</code> will be the value of <code>i</code> for the current row. This is because the default frame for window functions is <code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>. So by not specifying a frame explicitly, <code>FIRST_VALUE()</code> returns the value of the first row in the table and <code>LAST_VALUE()</code>returns the value in the current row. The <code>NTH_VALUE()</code> function returns the value of the <code>nth</code> row (zero-based) of the current frame or <code>NULL</code> if there is no <code>nth</code> row in the current frame. For example:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT i, FIRST_VALUE(i) OVER (ORDER BY i), LAST_VALUE(i) OVER (ORDER BY i),
    NTH_VALUE(i, 1) OVER (ORDER BY i) FROM test;
    i       #2      #3      #4
    ------------------------------------------------------------------------------
    1       1       1       null
    2       1       2       2
    3       1       3       2
    4       1       4       2
    5       1       5       2
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>If we specify an unbounded window the value of <code>LAST_VALUE()</code> will be the last value in the entire window:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT i,
    FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING),
    LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING),
    NTH_VALUE(i, 1) OVER (ORDER BY i ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM test;
    i       #2      #3      #4
    ------------------------------------------------------------------------------
    1       1       5       2
    2       1       5       2
    3       1       5       2
    4       1       5       2
    5       1       5       2
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>And if we specify a bounded window the value of <code>LAST_VALUE()</code> will be the last value in the specified frame (range of rows):</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT i, FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING),
    LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING),
    NTH_VALUE(i, 2) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) FROM test;
    i       #2      #3      #4
    ------------------------------------------------------------------------------
    1       1       2       null
    2       1       3       3
    3       2       4       4
    4       3       5       5
    5       4       5       null
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>To demonstrate ranking window functions we will use another simple table and dataset created by the following script:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    CREATE TABLE t(v string);
    INSERT INTO t(v) VALUES ('a'),('a'),('a'),('b'),('c'),('c'),('d'),('e');
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The <code>ROW_NUMBER()</code> function assigns unique numbers to each row within the partition. For example:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT v, ROW_NUMBER() OVER(ORDER BY v) FROM t;
    v       #2
    ------------------------------------------------------------------------------
    a       1
    a       2
    a       3
    b       4
    c       5
    c       6
    d       7
    e       8
    Selected records: 8
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The <code>RANK()</code> function behaves like <code>ROW_NUMBER()</code> except that “equal” rows are ranked the same. For example:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT v, RANK() OVER(ORDER BY v) FROM t;
    v       #2
    ------------------------------------------------------------------------------
    a       1
    a       1
    a       1
    b       4
    c       5
    c       5
    d       7
    e       8
    Selected records: 8
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The <code>DENSE_RANK()</code> function calculates a rank with no gaps, i.e. “dense”. For example:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT v, DENSE_RANK() OVER(ORDER BY v) FROM t;
    v       #2
    ------------------------------------------------------------------------------
    a       1
    a       1
    a       1
    b       2
    c       3
    c       3
    d       4
    e       5
    Selected records: 8
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The <code>PERCENT_RANK()</code> function calculates the relative rank of the current row to others in the partition. This function is used in statistical analysis to determine the percentile for a group of values. The actual formula used to calculate the <code>percent_rank</code> is:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    PERCENT_RANK() = ( RANK() – 1 ) / ( TotalRows - 1 )
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>To demonstrate this we create yet another table with the following script:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    CREATE TABLE salaries(DepartmentID int, Salary int);
    INSERT INTO salaries VALUES (1, 15000), (1, 18000), (1, 23000), (1, 23000), (1, 25000);
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The <code>RANK()</code> and <code>PERCENT_RANK()</code> functions are applied to the <code>Salary</code> column in the following query:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT DepartmentID, Salary,
    ROW_NUMBER() OVER (PARTITION BY DepartmentID ORDER BY Salary ROWS BETWEEN UNBOUNDED
    PRECEDING AND UNBOUNDED FOLLOWING) AS RowNumber,
    RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary ROWS BETWEEN UNBOUNDED
    PRECEDING AND UNBOUNDED FOLLOWING) AS RowRank,
    PERCENT_RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary ROWS BETWEEN UNBOUNDED
    PRECEDING AND UNBOUNDED FOLLOWING) AS PercentRank
    FROM salaries;
    DepartmentID    Salary  RowNumber RowRank PercentRank
    ------------------------------------------------------------------------------
    1       	 15000   1		1       0
    1       	 18000   2		2       0.25
    1       	 23000   3		3       0.5
    1       	 23000   4		3       0.5
    1       	 25000   5		5       1
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>Here we have 4 different <code>Salary</code> values in 5 rows. The values returned by <code>PERCENT_RANK()</code> are computed as follows:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    1.	RANK = 1 so PERCENT_RANK = ( 1 – 1 ) / 4 = 0
    2.	RANK = 2 so PERCENT_RANK = ( 2 – 1 ) / 4 = 0.25
    3.	RANK = 3 so PERCENT_RANK = ( 3 – 1 ) / 4 = 0.5
    4.	RANK = 3 so PERCENT_RANK = ( 3 – 1 ) / 4 = 0.5
    5.	RANK = 5 so PERCENT_RANK = ( 5 – 1 ) / 4 = 1
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>The <code>NTILE()</code>function distributes result set rows into a specified number of groups. To demonstrate we will create yet another table with the following script:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    CREATE TABLE students(StudentID char(2), Marks integer);
    INSERT INTO students VALUES('S1', 75);
    INSERT INTO students VALUES('S2', 83);
    INSERT INTO students VALUES('S3', 91);
    INSERT INTO students VALUES('S4', 83);
    INSERT INTO students VALUES('S5', 93);
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>We can apply the <code>NTILE()</code>function to this table with a script like the following:</p>
            </blockquote>
            <blockquote>
                <div class="code-block"><pre>&#160;
    SELECT StudentID, Marks, NTILE(2) OVER(ORDER BY Marks ROWS BETWEEN UNBOUNDED PRECEDING
    AND UNBOUNDED FOLLOWING) FROM students;
    StudentID      Marks   #3
    ------------------------------------------------------------------------------
    S1      	75      1
    S2      	83      1
    S4      	83      1
    S3      	91      2
    S5      	93      2
    Selected records: 5
    &#160;</pre>
                </div>
            </blockquote>
            <blockquote>
                <p>Note that the group number <code>1</code> has three rows while group <code>2</code> has two simply because there is an uneven number of result rows.</p>
            </blockquote>
            <p style="font-size: 6pt;margin-top: 0;margin-bottom: 0;">&#160;</p>
            <hr width="100%" size="0" align="center" />
            <p class="copyright" style="font-size: 8pt;"><a href="../../../../Copyright_Notice.htm" title="Copyright Notice" alt="Copyright Notice">© 2001-2019 McObject LLC. All rights reserved</a>.</p>
            <p class="copyright" style="font-size: 8pt;">&#160;</p>
            <p class="copyrightFeedback" style="font-size: 8pt;"><a href="mailto:Support@McObject.com?subject=Online Documentation feedback">Send feedback</a> <span style="color: #000000;">on this topic to McObject. </span></p>
        </div>
    </body>
    <script id="MCO-LINKS">/* <![CDATA[ */
		(function(){
		var isFramed = false;
		try {
		isFramed = window != window.top || document != top.document || self.location != top.location;
		} catch (e) {
		isFramed = true;
		}
		if (!isFramed) {
		var link1 = document.createElement('a');
		link1.setAttribute('href','#');
		link1.setAttribute('id','back-id');
		link1.setAttribute('title','Go back');
		link1.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>';
		var link2 = document.createElement('a');
		link2.setAttribute('href','/');
		link2.setAttribute('title','Go to mcobject.com');
		link2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var link3 = document.createElement('a');
		link3.setAttribute('href','/docs/extremedb.htm');
		link3.setAttribute('title','Go to table of content');
		link3.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#555555"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>';
		var el = document.createElement('div');
		el.style.cssText = 'position:fixed;display:flex;flex-direction:column;right:16px;top:8px;background:#f7f7f7;box-shadow:4px 4px 4px #777777;padding:4px 8px;';
		el.appendChild(link1);
		el.appendChild(link2);
		el.appendChild(link3);
		document.body.append(el);
		document.querySelector('#back-id').addEventListener('click',function(e){e.preventDefault(); window.history.back();});
		}
		})();
	/* ]]> */</script>
</html>