define({"136":{i:0.00020815320161956,u:"../Content/Users_Guides/Core/Features/Binary_Fields.htm",a:"Binary data can be stored in eXtremeDB fields of type string, blob, binary and varbinary. Fields of type blob can be used for large data fields (greater than 1 Kb). When a field is not intended to be used in indexes and its data size is less than 64 Kb string fields can be used. String fields in ...",t:"Binary Fields"},"137":{i:0.000739231656386044,u:"../Content/Users_Guides/Core/Using_Binary_Data.htm",a:"As explained in the C API  base data types  page, for dynamic fields, such as string, vector, sequence, blob or optional struct fields, a reference pointer is stored in the data layout for the objects of this class, and the actual object data is stored separately and retrieved via this reference ...",t:"Storing and Accessing Binary Data"},"138":{i:0.00139656674209864,u:"../Content/Users_Guides/Core/Datetime_Fields.htm",a:" The eXtremeDB datetime type is a 64-bit integer value used to store the date and time in databases. The precision of datetime  values is determined by the runtime parameter DATETIME_PRECISION. Numerically, the precision represents the number of ticks per second. The default  value for ...",t:"Date, Time and Datetime Fields "},"139":{i:0.000309521443091856,u:"../Content/Users_Guides/Core/Features/Vertical_Storage.htm",a:"The eXtremeDB sequence data type provides the capability to store data in vertical or columnar form. A  sequence is an unbounded array of eXtremeDB-supported scalar data elements (i.e. [u]int[1|2|3|4], time, date, float, double,char and datetime). Sequences  are dynamic; they don\u0027t require layout ...",t:"Vertical Data Storage"},"140":{i:0.000174251670463499,u:"../Content/Users_Guides/Core/Features/Parallel_Processing_with_Sequences.htm",a:"Support for the parallel processing of sequences is implemented thorough a thread pool in the SQL engine that can optimize performance for sequence operations in multi-processor environments. The thread pool allows sequence functions to split sequences into equal parts across threads and perform ...",t:"Parallel Processing with Sequences"},"141":{i:0.000424863536927065,u:"../Content/Users_Guides/Core/Schema_Definition/Schemas_C.htm",a:"For C projects, the database schema is specified in the eXtremeDB Data Definition Language ( DDL ) which identifies the database, defines each data class, its elements, its relationship to other data classes, and data access methods. The DDL syntax, keywords and preprocessor are designed to be ...",t:"Database Schema Definition in C"},"142":{i:0.000148588539555496,u:"../Content/Users_Guides/Core/Schema_Definition/Schemas_Cpp.htm",a:"C++ applications use the same eXtremeDB DDL  processor as C applications to define the database schema. Please refer to the  C Schema Definition  page for details. For C++ applications, the  mcocomp -hpp or -cpp option can be specified to cause generation of C++ \"wrapper\" class implementations in ...",t:"Database Schema Definition in C++"},"143":{i:0.000151767399899953,u:"../Content/Users_Guides/Core/Schema_Definition/Schemas_Java.htm",a:"As explained in the  Java Quick Start , the JNI uses the Java class syntax, with annotations.  At run-time, Java reflection is used to discover the classes with their annotations and build up an eXtremeDB database dictionary. Note that the annotation @Persistent() marks a Java class to be managed by ...",t:"Database Schema Definition in Java"},"144":{i:0.000152142844577844,u:"../Content/Users_Guides/Core/Schema_Definition/Schemas_Python.htm",a:"The eXtremeDB Python wrapper has the  mcocomp  runtime compiled in, so the database schema can be defined in the form of text, just like a regular C API schema (mco) file.  (Please see the C API  Users_Guide  page for details on schema definition using the eXtremeDB DDL ). For example, the following ...",t:"Database Schema Definition in Python"},"145":{i:0.000151398136686856,u:"../Content/Users_Guides/Core/Schema_Definition/Schemas_Csharp.htm",a:"As explained in the  C# Quick Start , the C# API uses the C# class syntax, with attributes.  At run-time, C# reflection is used to discover the classes with their attributes and build up an eXtremeDB database dictionary. Note that the attribute[Persistent] marks a C# class to be managed by the ...",t:"Database Schema Definition in C#"},"146":{i:0.000178468221311134,u:"../Content/Users_Guides/Core/Runtime_Environment.htm",a:"The eXtremeDB runtime environment must be initialized before performing any database actions.   This startup procedure initializes one or more semaphores that coordinate access to the database between multiple processes, or between multiple threads of a single process.  Each process must initialize ...",t:"Runtime Environment Control"},"147":{i:0.000289106620369969,u:"../Content/Users_Guides/Core/Runtime_Control/Runtime_Control_C.htm",a:"The startup procedure that initializes the eXtremeDB runtime environment in C applications is  mco_runtime_start() . It must be called before any database operations can be performed. However, prior to calling  mco_runtime_start() , it is common practice to register a fatal error handler by calling  ...",t:"Runtime Control in C"},"148":{i:0.000156468365414105,u:"../Content/Users_Guides/Core/Runtime_Control/Runtime_Control_Cpp.htm",a:"C++ applications use the standard C API function calls to initialize and shut down the eXtremeDB runtime environment and to register a fatal error handler or set runtime options. Likewise the C API is used directly to view runtime information or options. Also, the runtime libraries used by C++ ...",t:"Runtime Control in C++"},"149":{i:0.000159647225758561,u:"../Content/Users_Guides/Core/Runtime_Control/Runtime_Control_Java.htm",a:"The startup procedure that initializes the eXtremeDB runtime environment in Java applications is implemented in the Database.runtimeStart() method which is invoked automatically by the constructor when a Database object is instantiated. And Database.runtimeStop() is invoked automatically to shutdown ...",t:"Runtime Control in Java"},"150":{i:0.00025357020222278,u:"../Content/Users_Guides/Core/Runtime_Control/Runtime_Control_Python.htm",a:"The startup procedure that initializes the eXtremeDB runtime environment in Python applications is implemented in the exdb.init_runtime() method which must be called before any database operations can be performed. The exdb.init_runtime() method accepts the following arguments to set runtime options ...",t:"Runtime Control in Python"},"151":{i:0.000159277962545464,u:"../Content/Users_Guides/Core/Runtime_Control/Runtime_Control_Csharp.htm",a:"The startup procedure that initializes the eXtremeDB runtime environment in C# applications is implemented in the Database.RuntimeStart() method which is invoked automatically by the constructor when a Database object is instantiated. And Database.RuntimeStop() is invoked automatically to shutdown ...",t:"Runtime Control in C#"},"152":{i:0.000197931661750638,u:"../Content/Users_Guides/Core/Database_Control.htm",a:"All databases, whether all-in-memory, persistent or hybrid (with both transient and persistent classes) occupy main memory in the application’s memory space.  For in-memory databases, a single memory device specifies  the type of memory (conventional or shared) and its size. For persistent databases ...",t:"eXtremeDB Database Control"},"153":{i:0.000928233778151033,u:"../Content/Users_Guides/Core/Memory_Devices.htm",a:"As described in the  Database Storage  page, eXtremeDB supports the notion of logical database devices which are abstractions of physical storage locations that can be conventional memory (static or heap allocated memory in the application address space), shared memory (“named” memory shared by ...",t:"Database Memory Devices"},"154":{i:0.000767572890041816,u:"../Content/Users_Guides/Core/Database_Control/Devices_C.htm",a:" The application determines the size and location of the memory devices, the type of memory and how the eXtremeDB  runtime will use the device by defining a  mco_device_t  structure. This structure is necessarily quite complex in order to accommodate a variety of storage device characteristics. ...",t:"Database Memory Device Specification in C"},"155":{i:0.000409676474592578,u:"../Content/Users_Guides/Core/Database_Control/Devices_Cpp.htm",a:"Database Memory Device Specification in C++ C++ applications use the standard C API  mco_device_t  structure to define their memory device(s). Please refer to the  C API Memory Devices  page for details.",t:"Database Memory Device Specification in C++"},"156":{i:0.000346251353391351,u:"../Content/Users_Guides/Core/Database_Control/Devices_Java.htm",a:"For Java applications using in-memory databases, a single conventional memory device required for all database data, indexes and metadata is automatically defined and initialized in the Database.open() method when no device array is specified. For example, the typical sequence of API calls that uses ...",t:"Database Memory Device Specification in Java"},"157":{i:0.00036598381433975,u:"../Content/Users_Guides/Core/Database_Control/Devices_Python.htm",a:"For Python applications using in-memory databases, a single conventional memory device is required for all database data, indexes and metadata and is automatically defined and initialized in the exdb.open_database() method when no device array is specified. For example:  \n    db = ...",t:"Database Memory Device Specification in Python"},"158":{i:0.00034568853179869,u:"../Content/Users_Guides/Core/Database_Control/Devices_Csharp.htm",a:"For C# applications using in-memory databases, a single conventional memory device required for all database data, indexes and metadata is automatically defined and initialized in the Database.Open() method when no device array is specified. For example, the typical sequence of API calls that uses ...",t:"Database Memory Device Specification in C#"},"159":{i:0.000601838898815863,u:"../Content/Users_Guides/Core/Creating Databases.htm",a:" In-Memory Databases In-memory databases are created in conventional or shared memory when the database open API is called. When the database is opened, memory devices are initialized and metadata, in the form of the database dictionary that informs the eXtremeDB  runtime about the database ...",t:"Creating/Opening Databases "},"160":{i:0.000752063721158373,u:"../Content/Users_Guides/Core/Database_Control/Open_C.htm",a:" To create a database, the application first specifies  memory device(s) , and database parameters that are then passed to the  mco_db_open_dev() API. For an in-memory database the relevant parameters are described below. For persistent databases there are additional considerations. Please use the ...",t:"Create/Open Databases in C"},"161":{i:0.000881807890085635,u:"../Content/Users_Guides/Core/Persistent_Databases/Database_Control/Persistent_Open_C.htm",a:" To create or open a persistent database, the application first specifies  memory device(s) , and database parameters that are then passed to the  mco_db_open_dev() API. The database parameters are specified in a  mco_db_params_t  structure that consists of many elements to determine runtime ...",t:"Create/Open Persistent Databases in C"},"162":{i:0.000168759079930899,u:"../Content/Users_Guides/Core/Database_Control/Open_Cpp.htm",a:"Create/Open Databases in C++ C++ applications use the standard C  memory devices  and  mco_db_params_t structure, and call the C API  mco_db_open_dev() to open the database. Please refer to the  C API Creating Databases  page for details.",t:"Create/Open Databases in C++"},"163":{i:0.000164263170803229,u:"../Content/Users_Guides/Core/Persistent_Databases/Database_Control/Persistent_Open_Cpp.htm",a:"Persistent Database Creation in C++ C++ applications use the standard C APIs to define memory devices and database parameters  that are then passed to the  mco_db_open_dev() API. Please refer to the  C API Database Creation  page for details.",t:"Persistent Database Creation in C++"},"164":{i:0.000301561183397907,u:"../Content/Users_Guides/Core/Database_Control/Open_Java.htm",a:"As demonstrated in the  Java Quick Start ,  databases are created by the Database method open(). There are two versions of the open() method:  \n    open( String dbName, Parameters params, long size)\n \n    open( String dbName, Parameters params, Devices[] devices)\n  The first version is appropriate ...",t:"Create/Open Databases in Java"},"165":{i:0.000249705853374902,u:"../Content/Users_Guides/Core/Persistent_Databases/Database_Control/Persistent_Open_Java.htm",a:" To create or open a persistent database, the application first specifies the Database.MCO_CFG_DISK_SUPPORT flag in the mode argument passed to the Database constructor. Whereas an in-memory database application needs only a single memory device, persistent database applications must define at least ...",t:"Create/Open Persistent Databases in Java"},"166":{i:0.000241900721077497,u:"../Content/Users_Guides/Core/Database_Control/Open_Python.htm",a:"In-memory databases are created in Python by the eXtremeDB wrapper (exdb) method open_database(). For example:  \n    db = exdb.open_database(\"myopendb\", dict)\n      This uses default argument values to create an in-memory database with the name “myopendb”  using 128Mb of RAM. The variable db is a ...",t:"Create/Open Databases in  Python"},"167":{i:0.000369879618042735,u:"../Content/Users_Guides/Core/Persistent_Databases/Database_Control/Persistent_Open_Python.htm",a:"Create/Open Persistent Databases in Python  To create or open a persistent database, the application ... Parameter Settings Please refer to the general guidelines discussed in the  Creating Databases  page for determining the proper values for MemPageSize, DiskPageSize, MaxConnections, ...",t:"Create/Open Persistent Databases in Java"},"168":{i:0.000300878043399543,u:"../Content/Users_Guides/Core/Database_Control/Open_Csharp.htm",a:"As demonstrated in the  C# Quick Start , databases are created by the Database method Open(). There are three versions of the Open() method:  \n    Open( String dbName, Parameters params, long size)\n \n    Open( String dbName, Parameters params, Devices[] devices)\n     \n    Open( String dbName, ...",t:"Create/Open Databases in  C#"},"169":{i:0.000249512294995338,u:"../Content/Users_Guides/Core/Persistent_Databases/Database_Control/Persistent_Open_Csharp.htm",a:" To create or open a persistent database, the application first specifies the Database.Mode.DiskSupport flag in the mode argument passed to the Database constructor. Whereas an in-memory database application needs only a single memory device, persistent database applications must define at least 4 ...",t:"Create/Open Persistent Databases in C#"},"170":{i:0.000163693408321708,u:"../Content/Users_Guides/Core/Connections.htm",a:" To perform operations on a database, an application connects to the database (creates a database handle) by creating a connection. The database must have been previously  created , possibly in a different process if the database is in shared memory.  The  database connection is used in subsequent ...",t:"Connecting to Databases "},"171":{i:0.000212418770214674,u:"../Content/Users_Guides/Core/Database_Control/Connection_C.htm",a:"A C application connects to the database (creates a database handle) by calling the  mco_db_connect() API to create a connection handle. The database must have been previously  opened , possibly in a different process if the database is in shared memory.  If successful,  mco_db_connect() returns a  ...",t:"Database Connections in C"},"172":{i:0.000149318558504031,u:"../Content/Users_Guides/Core/Database_Control/Connection_Cpp.htm",a:"Database Connections in C++ C++ applications use the standard  C API  mco_db_connect() to create a connection handle to the database. Please refer to the  C API Connections  page for details.",t:"Database Connections in C++"},"173":{i:0.000152497418848487,u:"../Content/Users_Guides/Core/Database_Control/Connection_Java.htm",a:"A Java application connects to the database (creates a database handle) by instantiating a Connection. The database must have been previously created by calling the Database method  open(), possibly in a different process if the database is in shared memory.  If successful, the constructor returns a ...",t:"Database Connections in Java"},"174":{i:0.000152872863526379,u:"../Content/Users_Guides/Core/Database_Control/Connection_Python.htm",a:"A Python application connects to the database (creates a database handle) by calling the Database method connect(). The database must have been previously  opened , possibly in a different process if the database is in shared memory. For example:      \n    db = exdb.open_database(\"myopendb\", dict)\n  ...",t:"Database Connections in Python"},"175":{i:0.00015212815563539,u:"../Content/Users_Guides/Core/Database_Control/Connection_Csharp.htm",a:"A C# application connects to the database (creates a database handle) by instantiating a Connection. The database must have been previously created by calling the Database method  Open(), possibly in a different process if the database is in shared memory.  If successful, the constructor returns a  ...",t:"Database Connections in C#"},"176":{i:0.000163693408321708,u:"../Content/Users_Guides/Core/Extending.htm",a:"Extending Database Memory  Applications can extend the amount of memory for use by a database. The APIs and structures for extending database memory are specific to the programming language used. Please use the links below to view detailed explanations and examples  for your development environment:",t:"Extending Database Memory "},"177":{i:0.000297330165920266,u:"../Content/Users_Guides/Core/Database_Control/Extend_C.htm",a:"A C application can extend the amount of memory for use by a database by calling  mco_db_extend_dev() to add a new memory device. The following code snippet demonstrates the recommended way for C applications to extend a database:      \n     \n    int extend_db_memory(const char * dbname)\n    {\n      ...",t:"Extending Database Memory in C"},"178":{i:0.000160913557272042,u:"../Content/Users_Guides/Core/Database_Control/Extend_Cpp.htm",a:"Extending Database Memory in C++ C++ applications use the standard  C APIs to extend in-memory databases. Please refer to the  C API Extend  page for details.",t:"Extending Database Memory in C++"},"179":{i:0.000164092417616498,u:"../Content/Users_Guides/Core/Database_Control/Extend_Java.htm",a:"A Java application can extend the amount of memory for use by a database by calling the Database method extend().  The following code snippet demonstrates the recommended way for Java applications to extend a database:      \n     \n    void extend_db_memory(Database db)\n    {\n        int size = 1024 ...",t:"Extending Database Memory in Java"},"180":{i:0.000163723154403401,u:"../Content/Users_Guides/Core/Database_Control/Extend_Csharp.htm",a:"A C# application can extend the amount of memory for use by a database by calling the Database method Extend().  The following code snippet demonstrates the recommended way for C# applications to extend a database:      \n     \n    void extend_db_memory(Database db)\n    {\n        int size = 1024 * ...",t:"Extending Database Memory  in C#"},"181":{i:0.000137388441178233,u:"../Content/Users_Guides/Core/Object_Interfaces.htm",a:" To create and modify in-memory database objects, an application uses APIs specific to the application development language. Whereas C and C++ applications use strongly typed APIs  generated  from the schema definition, Java, C# and Python applications use the language instantiation operator (eg. ...",t:"Creating and Modifying Database Objects "},"182":{i:0.000628270321670081,u:"../Content/Users_Guides/Core/Object_Interfaces/Object_Interfaces_C.htm",a:"Creating and Modifying Database Objects   in C As explained in the following links, the static application-independent functions  are used for eXtremeDB runtime control ,  database control  (opening, connecting to and closing databases),  transaction management  and  cursor navigation . But to ...",t:"Creating and Modifying Database Objects in C"},"183":{i:0.000145592001407514,u:"../Content/Users_Guides/Core/Object_Interfaces/Object_Interfaces_Cpp.htm",a:"C++ applications typically use a mix of C++ and  C APIs  to manage database objects. The  mcocomp schema compiler with option -hpp generates C++ class definitions for each database class. These class interfaces can be used to create and modify database objects using these generated create() and ...",t:"Creating and Modifying Database Objects in C++"},"184":{i:0.000148770861751971,u:"../Content/Users_Guides/Core/Object_Interfaces/Object_Interfaces_Java.htm",a:"Java applications use the new operator to instantiate an object and the assignment operator to modify the objects values. To create the database store of the object the Connection method insert() is called within a transaction. For example:  \n    @Persistent // Class Record will be stored in ...",t:"Creating and Modifying Database Objects in Java"},"185":{i:0.000149146306429862,u:"../Content/Users_Guides/Core/Object_Interfaces/Object_Interfaces_Python.htm",a:"To create an object (i.e. insert a record into the database) use the Connection method new() which takes a class name as argument. It returns a Python object which corresponds to the one created in the database. The type for the python object is dynamically defined from the schema when the database ...",t:"Creating and Modifying Database Objects in Python"},"186":{i:0.000148401598538873,u:"../Content/Users_Guides/Core/Object_Interfaces/Object_Interfaces_Csharp.htm",a:"C# applications use the new operator to instantiate an object and the assignment operator to modify the objects values. To create the database store of the object the Connection method Insert() is called within a transaction. For example:  \n    [Persistent] // Class Record will be stored in ...",t:"Creating and Modifying Database Objects in C#"},"187":{i:0.000246911572818943,u:"../Content/Users_Guides/Core/Object_Interfaces/Nullable_Fields_And_Indexes.htm",a:"Note that nulls are not included into indexes.  In other words, if a nullable field is indexed, and an object of the class has the null indicator set to true for that field, that object will not be included in the index.  Therefore, take care that there is some other access method other than through ...",t:"Nullable Fields and Indexes"},"188":{i:0.00118034546042539,u:"../Content/Users_Guides/Core/Datetime_Fields/Datetime_C.htm",a:"As explained in the  Datetime FIelds  page, a field of datetime type is a 64 bit integer value used to store the date and time in databases and the precision of datetime  values is determined by the runtime parameter DATETIME_PRECISION which represents the number of ticks per second. The default  ...",t:"Managing Date/Time Fields  in C"},"189":{i:0.000319481273697293,u:"../Content/Users_Guides/Core/Datetime_Fields/Datetime_Cpp.htm",a:"Managing Date/Time Fields  in C++ For C++ database applications the APIs for managing datetime fields are exactly as for C applications. Please see the  C API Datetime Fields  page for details.",t:"Managing Date/Time Fields  in C++"},"190":{i:0.000361633156917688,u:"../Content/Users_Guides/Core/Datetime_Fields/Datetime_Java.htm",a:"As explained in the  Datetime FIelds  page, a field of type datetime (actually mapped to class java.util.Date) is a 64 bit integer value used to store the date and time in databases and the precision of Datetime  values is determined by the runtime parameter DATETIME_PRECISION which represents the ...",t:"Managing Date/Time Fields  in Java"},"191":{i:0.000361528531322599,u:"../Content/Users_Guides/Core/Datetime_Fields/Datetime_Csharp.htm",a:"As explained in the  Datetime FIelds  page, a field of type Datetime (actually mapped to class System.DateTime) is a 64 bit integer value used to store the date and time in databases and the precision of Datetime  values is determined by the runtime parameter DATETIME_PRECISION which represents the ...",t:"Managing Date/Time Fields  in C#"},"192":{i:0.000382868664218651,u:"../Content/Users_Guides/Core/Datetime_Fields/Datetime_Python.htm",a:"As explained in the  Datetime FIelds  page, a field of datetime type is a 64 bit integer value used to store the date and time in databases and the precision of datetime  values is determined by the runtime parameter DATETIME_PRECISION which represents the number of ticks per second. The default  ...",t:"Managing Datetime Fields  in Python"},"193":{i:0.00233308462862326,u:"../Content/Users_Guides/Core/Class_Relationships.htm",a:"A common application-level database operation is implementing a relationship between database classes. For developers familiar with relational databases and SQL, a join between two tables is implemented by a foreign key in one table referencing a primary key in another table. For example, a simple ...",t:"Database Class Relationships"},"194":{i:0.00119152907229465,u:"../Content/Users_Guides/Core/Class_Relationships/Class_Relationships_C.htm",a:"As explained in the  Class Relationships page , eXtremeDB provides a number of ways to implement relationships (joins) between tables, each having distinct advantages and costs in terms of memory overhead and performance. The different techniques available to C developers are presented in the ...",t:"Database Class Relationships in C"},"195":{i:0.000621869216889108,u:"../Content/Users_Guides/Core/Class_Relationships/Class_Relationships_Cpp.htm",a:"Database Class Relationships in C++ C++ applications use the standard  C APIs to manage class relationships. (Please refer to the  C API Class Relationships  page for details.)",t:"Database Class Relationships in C++"},"196":{i:0.000693451590090112,u:"../Content/Users_Guides/Core/Class_Relationships/Class_Relationships_Java.htm",a:"As explained in the  Class Relationships page , eXtremeDB provides a number of ways to implement relationships (joins) between tables, each having distinct advantages and costs in terms of memory overhead and performance. The different techniques available to Java developers are presented in the ...",t:"Database Class Relationships in Java"},"197":{i:0.000624678814020467,u:"../Content/Users_Guides/Core/Class_Relationships/Class_Relationships_Csharp.htm",a:"As explained in the  Class Relationships page , eXtremeDB provides a number of ways to implement relationships (joins) between tables, each having distinct advantages and costs in terms of memory overhead and performance. The different techniques available to C# developers are presented in the ...",t:"Database Class Relationships in C#"},"198":{i:0.000669464060350121,u:"../Content/Users_Guides/Core/Class_Relationships/OID_Reference_Example_C.htm",a:"As explained in the  Class Relationships in C page , eXtremeDB provides a number of ways for C developers to implement relationships (joins) between tables, including the Object Id or OID which is available only to the C and C++ APIs. The following “satellite radio receiver” example, demonstrates ...",t:"OID Reference Example in C"},"199":{i:0.000910994257551365,u:"../Content/Users_Guides/Core/Indexes_Cursors.htm",a:"The process of gaining access to objects stored in eXtremeDB is called navigation. Like other databases, eXtremeDB uses indexes to navigate to objects based on key values. (Please see the  Indexes web page for brief feature descriptions of the variety of specialized eXtremeDB indexes.) eXtremeDB ...",t:"eXtremeDB Indexes and Cursors"},"200":{i:0.000293738678554532,u:"../Content/Users_Guides/Core/Indexes_Cursors/BTree.htm",a:"As explained in the  Indexes  page, the eXtremeDB, B-Tree (tree) indexes can include any combination of fields, structure elements or vector elements from a given class. Tree indexes can be used for ordered (sorted) retrieval, range retrieval and pattern matching.  Also, key-value-inclusive and ...",t:"B-Tree Indexes"},"201":{i:0.00057445430338436,u:"../Content/Users_Guides/Core/Indexes_Cursors/Patricia.htm",a:"As explained in the  Indexes  page, the eXtremeDB Patricia Trie indexes can be used for optimal access of IP addresses and similar alphanumeric strings. Searches on patricia indexes are performed using the patricia-specific search methods LongestMatch, ExactMatch, PrefixMatch and NextMatch.  ...",t:"Patricia trie Indexes"},"202":{i:0.000332164268498581,u:"../Content/Users_Guides/Core/Indexes_Cursors/RTree.htm",a:"R-Tree Indexes As explained in the  Indexes  page, the eXtremeDB rtree index is commonly used to speed spatial searches; for example, find the rectangle that contains this point, find all rectangles that overlap this rectangle, or find all rectangles in the neighborhood of this point.  All manner of ...",t:"RTree Indexes"},"203":{i:0.000241075652905231,u:"../Content/Users_Guides/Core/Indexes_Cursors/KDTree.htm",a:"As explained in the  Indexes  page, eXtremeDB supports a k-dimensional tree index, called kdtree which are ideal for multi-dimensional key value searches. A kdtree is a data structure for organizing points in a k-dimensional space. The kdtree is a binary tree in which every node is a k-dimensional ...",t:"KD-Tree Indexes"},"204":{i:0.000322621756377933,u:"../Content/Users_Guides/Core/Indexes_Cursors/Trigram.htm",a:"As explained in the  Indexes  page, the eXtremeDB , Trigram (trigram) indexes are  ideal for text searches when the exact spelling of the target object is not precisely known. It finds objects which match the maximum number of three-character strings in the entered search terms, i.e., near matches. ...",t:"Trigram Indexes"},});