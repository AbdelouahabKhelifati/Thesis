define({"1801":{i:0.00013033961753581,u:"../Content/Programming/xSQL/SDK_Samples/Scripts/with.htm",a:"xSQL Sample With This sample demonstrates the use of the with operator.  This sample can be run from directory samples\\xsql\\scripts with the following command:  \n    ..\\..\\..\\target\\bin\\xsql.exe -b -c xsql.cfg -f with.sql\n     ",t:"xSQL Sample With"},"1802":{i:0.000152734280828965,u:"../Content/Programming/xSQL/SDK_Samples/xSQL_Financial.htm",a:"As explained in the samples/xsql/scripts/financial/readme.txt file, the SQL sample files *.sql in this directory are designed to demonstrate the use of various SQL analytics functions on sequences (time-series) using xSQL. They can be run by starting xSQL with the following commands:  \n    cd ...",t:"xSQL Financial Samples"},"1803":{i:0.000186544957281948,u:"../Content/Programming/xSQL/SDK_Samples/xSQL_Statistical_Functions.htm",a:"The samples/xsql/scripts/financial directory contains a number of command and script files to facilitate running select commands to demonstrate groups of statistical functions. These command files invoke xSQL and run scripts to demonstrate the  SQL Analytics Functions  by category. The examples in ...",t:"xSQL Analytics (Statistical) Functions Samples"},"1804":{i:0.00012163265184034,u:"../Content/Programming/xSQL/xSQL_Functions.htm",a:"The xSQL server provides a number of built-in statically linked functions (UDFs) including a service (a function) that accesses a meta table called Metafunction. For example the following query lists all of the available functions:  \n    select * from Metafunction;\n    ...",t:"xSQL Functions"},"1805":{i:0.000217526766880216,u:"../Content/Programming/xSQL/xSQL_IoT_Functions.htm",a:"xSQL IoT Functions The xSQL  server provides the following functions to control the IoT runtime:",t:"xSQL IoT Functions"},"1806":{i:0.000148046764257888,u:"../Content/Programming/xSQL/xSQL_Functions/iot_enable.htm",a:"Turns the IoT runtime on. For an overview see page  Introduction to eXtremeDB Active Replication Fabric Prototype      \n    xsql_iot_enable();\n      Arguments Description This function turns on the IoT runtime which may have been disabled at runtime startup.  Example  \n    XSQL\u003eselect ...",t:"xsql_iot_enable"},"1807":{i:0.000148046764257888,u:"../Content/Programming/xSQL/xSQL_Functions/iot_disable.htm",a:"Turns the IoT runtime on. For an overview see page  Introduction to eXtremeDB Active Replication Fabric Prototype      \n    xsql_iot_disable();\n      Arguments Description This function turns off the IoT runtime which may have been enabled at runtime startup.  Example  \n    XSQL\u003eselect ...",t:"xsql_iot_disable"},"1808":{i:0.000148046764257888,u:"../Content/Programming/xSQL/xSQL_Functions/iot_enable_connection.htm",a:"Turns the IoT connector on. For an overview see page  Introduction to eXtremeDB Active Replication Fabric Prototype      \n    xsql_iot_enable_connection(type string, address string);\n      Arguments Description This function turns on the IoT connector which may have been disabled at runtime startup. ...",t:"xsql_iot_enable_connection"},"1809":{i:0.000148046764257888,u:"../Content/Programming/xSQL/xSQL_Functions/iot_disable_connection.htm",a:"Turns the IoT connector off. For an overview see page  Introduction to eXtremeDB Active Replication Fabric Prototype      \n    xsql_iot_disable_connection(type string, address string);\n      Arguments Description This function turns off the IoT connector which may have been enabled at runtime ...",t:"xsql_iot_disable_connection"},"1810":{i:0.000189993500490346,u:"../Content/Programming/xSQL/xSQL_Functions/iot_connections.htm",a:"Lists the configured IoT connectors. For an overview see page  Introduction to eXtremeDB Active Replication Fabric Prototype      \n    xsql_iot_connections();\n      Arguments Description This function lists the configured IoT connectors. It returns the ResultSet table with the following columns ...",t:"xsql_iot_connections"},"1811":{i:0.000148046764257888,u:"../Content/Programming/xSQL/xSQL_Functions/iot_set_level.htm",a:"Changes the level of the router at runtime. For an overview see page  Introduction to eXtremeDB Active Replication Fabric Prototype      \n    xsql_iot_set_level(level int);\n      Arguments Description This function changes the level of a router at runtime.  Example  \n    XSQL\u003eselect ...",t:"xsql_iot_set_level"},"1812":{i:0.000527367910405563,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Keywords_and_Reserved_Words.htm",a:"The following table lists eXtremeSQL reserved words that have operational meaning. If used as identifiers in SQL statements, reserved words must be enclosed within double quotes. For example:   \n    XSQL\u003ecreate table T (\"field\" int, \"type\"  int);\n      Note that when reserved words are quoted in ...",t:"Keywords and Reserved Words"},"1813":{i:0.000147461424058333,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Operators.htm",a:"SQL Operators The eXtremeSQL SQL language operators are of the following types:",t:"SQL Operators"},"1814":{i:0.000146701185394886,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Arithmetic_Operators.htm",a:"Arithmetic operators are used to perform computations. Syntax  \n    select val1 operator val2 [operator val3 .. operator valN]\n      The eXtremeSQL arithmetic operators are the following: Examples  \n    select 17 / 5 + 3;\n    #1\n    ...",t:"Arithmetic Operators"},"1815":{i:0.000718026232819774,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Assignment_Operators.htm",a:"Assignment occurs during insert and update operations. When necessary eXtremeSQL will implicitly convert or coerce the type of a value being assigned to a column. Please see the  Data Type Conversion  page for further details.  Data types  can also be coerced explicitly using the cast() operator.  ...",t:"Assignment Operators"},"1816":{i:0.000146701185394886,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Binary_Operators.htm",a:"Binary operators are used in where clause predicates to perform the indicated operation on two operands. The result is boolean true or false. Syntax  \n    select * from ... \n    where val1 operator val2\n      The eXtremeSQL binary operators are the following: Examples  \n    create table t(i integer, ...",t:"Binary Operators"},"1817":{i:0.000146701185394886,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Comparison_Operators.htm",a:"Comparison operators are binary operators that return a boolean result. Syntax  \n    select * from ... \n    where expression1 operator expression2\n      The eXtremeSQL comparison operators are the following: Examples  \n    select 17 / 5 + 3;\n    #1\n    ...",t:"Comparison Operators"},"1818":{i:0.000146701185394886,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Logical_Operators.htm",a:"Logical operators are used to operate on one or more operands and return a boolean result. Syntax  \n    select * from ...\n    where expression1 and  expression2\n     \n    select * from ...\n    where expression1 or expression2\n     \n    select * from ...\n    where not expression1\n      The eXtremeSQL ...",t:"Logical Operators"},"1819":{i:0.000147461424058333,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Predicates.htm",a:"SQL Predicates SQL language predicates are used in a select statement where clause to limit result set rows. The eXtremeSQL predicate operators are the following:",t:"SQL Predicates"},"1820":{i:0.000142523096469128,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Between.htm",a:"The between predicate specifies inclusive bounds for values in a where clause. Syntax  \n    select * from ... \n    where val between lower_bound and upper_bound\n      This expression is equivalent to:  \n    select * from ... \n    where val \u003e= lower_bound and val \u003c= upper_bound\n      The not operator ...",t:"Between"},"1821":{i:0.000142523096469128,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Like.htm",a:"The like predicate specifies a pattern for string values in a where clause. The comparison with characters specified in the pattern is case sensitive; i.e. \u0027A\u0027 is not equal to \u0027a\u0027. If a case insensitive comparison is desired, the ilike operator can be used. The pattern can be a string with or ...",t:"Like"},"1822":{i:0.000142523096469128,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/In.htm",a:"The in predicate specifies a set of values to match in a where clause. The set can be specified with explicit values enclosed in parentheses or a select statement. Syntax  \n    select * from ... \n    where val in (val1, .., valN)\n     \n    select * from ...\n    where val in (select valX from ... ...",t:"In"},"1823":{i:0.000142523096469128,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Exists.htm",a:"The exists predicate specifies a result set of values to match in a where clause.  Syntax      \n    select * from ...\n    where exists (select valX from ... where ...)\n     \n      The not operator can be added to an expression using in:  \n    select * from ... \n    where not exists (select valX from ...",t:"Exists"},"1824":{i:0.000142523096469128,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Prefix_Match.htm",a:"and exact_match The prefix_match and exact_match predicates are used with Patricia trie indexes. They specify prefixes for string values in a where clause. For more details on the Patricia trie indexes and search methods, see the  Patricia trie Indexes  page. Syntax select * from ... where s ...",t:"prefix_match"},"1825":{i:0.000142523096469128,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Exact_Match.htm",a:"prefix_match and exact_match The prefix_match and exact_match predicates are used with Patricia trie indexes. They specify prefixes for string values in a where clause. For more details on the Patricia trie indexes and search methods, see the  Patricia trie Indexes  page. Syntax select * from ... ...",t:"exact_match"},"1826":{i:0.000909991461082624,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Data_Types.htm",a:"The following table defines the eXtremeSQL supported data types and their corresponding eXtremeDB DDL  definition. For more detailed information use the link for the data type of interest. The SQL engine will perform data type conversions transparently for most types. Please see the  Data Type ...",t:"eXtremeSQL Data Types"},"1827":{i:0.000371130305210193,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Data_Types/Binary_Data.htm",a:"eXtremeSQL provides fixed length BINARY\u003cn\u003e and variable length VARBINARY or BLOB storage options for arrays of bytes containing character or non-character data.  For an overview see page  SQL Data Types As explained in page  Binary Fields , binary data is stored in eXtremeDB fields of type  blob ,  ...",t:"eXtremeSQL Binary Data"},"1828":{i:0.000262338109419103,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Data_Types/Character_Data.htm",a:"The eXtremeSQL character data types provide fixed length and variable length storage options for arrays of single-byte (e.g.  ascii ) or double-byte (e.g.  unicode ) characters. The size of character arrays cannot exceed 64 Kb. For fields that must store more than 64 Kb of data, a  BLOB  can be ...",t:"eXtremeSQL Character Data"},"1829":{i:0.000262338109419103,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Data_Types/Integer_Data.htm",a:"eXtremeSQL provides the full range of SQL integer data types: TINYINT, SMALLINT, INT, BIGINT, LONGINT and UNSIGNED. For an overview see page  SQL Data Types The table in page  SQL Data Types  shows the correspondence between these SQL types and their underlying eXtremeDB storage types as well as the ...",t:"eXtremeSQL Integer Data"},"1830":{i:0.000262338109419103,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Data_Types/Floating_Point_Data.htm",a:"eXtremeSQL provides the SQL data types FLOAT, REAL, DOUBLE, NUMERIC and DECIMAL to manage floating-point values. For an overview see page  SQL Data Types The table in page  SQL Data Types  shows the correspondence between these SQL types and their underlying eXtremeDB storage types as well as the ...",t:"eXtremeSQL Floating-Point Data"},"1831":{i:0.000262338109419103,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Data_Types/Date_Time_Data.htm",a:"eXtremeSQL provides the SQL data types DATE, TIME and TIMESTAMP to manage date and time values. For an overview see page  SQL Data Types The table in page  SQL Data Types  shows that these three SQL types, DATE, TIME and TIMESTAMP, map to underlying 8-byte eXtremeDB datetime values.  \n    create ...",t:"eXtremeSQL DateTime Data"},"1832":{i:0.000672142329126606,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Data_Type_Conversion.htm",a:"eXtremeSQL Data Type Conversion The eXtremeSQL engine will implicitly convert most SQL types to successfully perform statements. The implicit type conversions are the following: DATE to TIME (TIMESTAMP) INTEGER to NUMERIC or FLOAT CHAR to FLOAT CHAR to VARCHAR BINARY to VARBINARY When performing ...",t:"Data Type Conversion"},"1833":{i:0.000147461424058333,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Statements.htm",a:"eXtremeSQL processes SQL statements of two types: Data Definition Language (DDL) and Data Manipulation Language (DML).  DDL Statements DDL statements add, modify and remove tables and indexes to or from the eXtremeSQL Metatable which manages all SQL access. Please use the following links to view the ...",t:" eXtremeSQL Statements"},"1834":{i:0.000141068962978858,u:"../Content/Programming/SQL/DDL_Statements.htm",a:"eXtremeSQL DDL Statements DDL statements add, modify and remove tables and indexes to or from the eXtremeSQL Metatable which manages all SQL access. Please use the following links to view the syntax for and examples of the Data Definition Language statements:",t:" eXtremeSQL DDL Statements"},"1835":{i:0.000132997181930145,u:"../Content/Programming/SQL/DML_Statements.htm",a:"eXtremeSQL DML Statements DML statements add, modify or remove rows from or perform queries on existing tables. Please use the following links to view the syntax for and examples of the Data Manipulation Language statements:",t:" eXtremeSQL DML Statements"},"1836":{i:0.00100520709672267,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Functions.htm",a:"eXtremeSQL  Functions Please use the links in the table below to view the eXtremeSQL functions of the indicated types:",t:"eXtremeSQL  Functions"},"1837":{i:0.000207075733646895,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Functions/Administrative_Functions.htm",a:"eXtremeSQL Administrative Functions Please use the links in the table below to view the eXtremeSQL aggregate functions:",t:"eXtremeSQL Administrative Functions"},"1838":{i:0.000207075733646895,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Functions/Database_Statistics_Functions.htm",a:"eXtremeSQL  Database Statistics Functions Please use the links in the table below to view the eXtremeSQL database statistics functions:",t:"eXtremeSQL Database Statistics Functions"},"1839":{i:0.000224307077309036,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Functions/Date_Time_Functions.htm",a:"eXtremeSQL  Date/Time Functions Please use the links in the table below to view the eXtremeSQL date and time functions:",t:"eXtremeSQL Date/Time Functions"},"1840":{i:0.000708614444473788,u:"../Content/Programming/SQL/Functions/setDateTimePrecision.htm",a:"Change the precision for DateTime operations using eXtremeSQL. For an overview see page  Managing Date/Time Fields  in SQL Prototype      \n    integer setDateTimePrecision( precision );\n      Arguments Description This function changes the precision for DateTime operations using eXtremeSQL by ...",t:"setDateTimePrecision"},"1841":{i:0.000207075733646895,u:"../Content/Users_Guides/SQL/SQL_Language_Reference/Functions/Mathematical_Functions.htm",a:"eXtremeSQL Mathematical Functions Please use the links in the table below to view the eXtremeSQL math functions:",t:"eXtremeSQL Mathematical Functions"},"1842":{i:0.000662185455339033,u:"../Content/Programming/SQL/Analytics_Functions/Functions_By_Category.htm",a:"eXtremeSQL provides a library of analytics SQL functions that operate on  sequences. The examples in the  SQL Analytics Examples  page demonstrate several of these functions. The examples use data described in the  Example Data  section to demonstrate the different categories of functions. The links ...",t:"Analytics SQL Functions by Category"},"1843":{i:0.000153072548132861,u:"../Content/Programming/SQL/Analytics_Functions/Comparison_Operators.htm",a:"The following comparison operators functions take two input sequences, left and right, and produce the Boolean result sequence result. If the two input sequence arguments are of different lengths the operation will be performed on only the number of elements in the shorter of the two sequences.  ...",t:"Comparison Operators SQL Functions"},"1844":{i:0.000251744909871496,u:"../Content/Programming/SQL/Analytics_Functions/Comparison/SQL_Eq_Ne_Gt_Ge_Lt_Le.htm",a:"The seq_eq(), seq_ne(), seq_gt(), seq_ge(), seq_lt(), seq_le() functions return a Boolean value by applying the indicated logical operation comparing the values of elements from sequence 1 to the corresponding elements of sequence 2. The results are easily verified by examining the output below. ...",t:"SQL Sequence EQ, NE, GT, GE, LT, LE functions"},"1845":{i:0.000149775790901452,u:"../Content/Programming/SQL/Analytics_Functions/Logical_Operators.htm",a:"The following logical operators functions take one Boolean sequence argument input, or two Boolean input sequences, left and right, and produce the Boolean result sequence. If the two input sequence arguments are of different lengths the operation will be performed on only the number of elements in ...",t:"Logical Operators SQL Functions"},"1846":{i:0.00025223940117244,u:"../Content/Programming/SQL/Analytics_Functions/Logical/SQL_And_Or_Xor.htm",a:"SQL Sequence And, Or and Xor Functions The seq_not(), seq_and(), seq_or() and seq_xor() functions take two sequence arguments of type Boolean and return a sequence of type Boolean. These functions apply the indicated operation to the corresponding elements of two sequences. Following is an example ...",t:"SQL Sequence And, Or, Xor Functions"},"1847":{i:0.000153072548132861,u:"../Content/Programming/SQL/Analytics_Functions/Conversion_Functions.htm",a:"The following conversion functions take a single input sequence   and produce the result sequence of the desired type. Example Following is an example code snippet demonstrating the conversion functions:          \n    -- seq_integer, seq_real\n            \n     \n    INSERT INTO ...",t:"Conversion Operators SQL Functions"},"1848":{i:0.000167007134563594,u:"../Content/Programming/SQL/Analytics_Functions/Unary_Operators.htm",a:"The following unary functions take a single input sequence, apply the specified operation  and return a sequence of the same type.  Example Following is an example code snippet demonstrating the unary operator functions:      \n    -- seq_abs, seq_neg\n            \n     \n    INSERT INTO ...",t:"Unary SQL Sequence Functions"},"1849":{i:0.000266886095784631,u:"../Content/Programming/SQL/Analytics_Functions/Unary/SQL_Abs_Neg.htm",a:"The seq_abs()function returns a result sequence with the absolute values of the input sequence elements. The seq_neg() function returns a result sequence with the “negative” or opposite sign of the input sequence elements.  Following is an example script demonstrating the seq_abs() and seq_neg()  ...",t:"SQL Sequence Abs and Neg Functions"},"1850":{i:0.000149775790901452,u:"../Content/Programming/SQL/Analytics_Functions/Binary_Functions.htm",a:"The following binary functions take two input sequences, left and right, and produce the result sequence  of the same type. The two input sequences must be of the same type. If the two input sequences are of different lengths the operation will be performed on only the number of elements in the ...",t:"Binary SQL Functions"},"1851":{i:0.000156756907096921,u:"../Content/Programming/SQL/Analytics_Functions/Binary/SQL_Add_Sub_Mul_Div.htm",a:"SQL Sequence Add, Subtract, Multiply and Divide Functions The seq_add() function adds the element from sequence 1 to the corresponding element of sequence 2; the seq_sub() function subtracts the element of sequence 2 from the corresponding element of sequence 1; the seq_mul() function multiplies the ...",t:"SQL Sequence Binary Add, Subtract, Multiply and Divide Functions"},"1852":{i:0.000156756907096921,u:"../Content/Programming/SQL/Analytics_Functions/Binary/SQL_Mod.htm",a:"The seq_mod() function calculates the modulo (remainder after division) of the elements of sequence 1 by the corresponding elements of sequence 2. Following is an example script demonstrating the seq_mod() function:  \n    INSERT INTO SimpleSequence(testNumber,dVal1,dVal2)\n     \n    ...",t:"SQL Sequence Modulo function"},"1853":{i:0.000156756907096921,u:"../Content/Programming/SQL/Analytics_Functions/Binary/SQL_Pow.htm",a:"The seq_pow() function takes two sequence arguments of type double and returns a sequence of type double. The elements of sequence 1 are raised to the power of the corresponding elements of sequence 2. Following is an example script demonstrating theseq_pow()  function:  \n    INSERT INTO ...",t:"SQL Sequence Pow Function"},"1854":{i:0.000156756907096921,u:"../Content/Programming/SQL/Analytics_Functions/Binary/Maxof_Minof.htm",a:"The seq_maxof()and seq_minof() functions are binary functions taking 2 sequences as arguments and, for each corresponding pair of elements from the input sequences, return the sequence with greater or lesser element from each pair. For example:  \n    XSQL\u003ecreate table t(s sequence(int), q ...",t:"SQL Sequence Maxof and Minof functions"},"1855":{i:0.000149775790901452,u:"../Content/Programming/SQL/Analytics_Functions/Collapse_Functions.htm",a:"The following collapse functions take two input sequences, left and right, and produce the result sequence  of  type double where the computed scalar result is the first element. The two input sequences must be of the same type. If the two input sequences are of different lengths the operation will ...",t:"Collapse SQL Functions"},"1856":{i:0.000188584405122094,u:"../Content/Programming/SQL/Analytics_Functions/Collapse/SQL_Wsum_Wavg.htm",a:"The seq_wsum(), seq_wavg() functions take two sequence arguments of type double and return a scalar result of type double. The weighted sum function seq_wsum() calculates the sum of the products of the two sequence elements. In fact the seq_wsum() is equivalent to: seq_sum( seq_mul()). The weighted ...",t:"SQL Sequence Weighted Sum and Weighted Average Functions"},"1857":{i:0.000188584405122094,u:"../Content/Programming/SQL/Analytics_Functions/Collapse/SQL_Cov_Corr.htm",a:"The seq_cov(), seq_corr() standard statistical functions calculate a scalar result of type double that indicates the strength of correlation between the two sequences. Covariance results of 0 indicate that there is no correlation between the two sequences; if seq_cov() returns a positive value (as ...",t:"SQL Sequence Covariance and Correlation Functions"},"1858":{i:0.000149775790901452,u:"../Content/Programming/SQL/Analytics_Functions/Conditional_Functions.htm",a:"The following conditional  functions take one input sequence or two (then, else) sequences, and a Boolean sequence condition. The result sequence of the same type except for seq_filter_pos() which returns a result sequence of type uint4. The two input sequence iterator arguments must be of the same ...",t:"Conditional SQL Functions"},"1859":{i:0.000167366073105312,u:"../Content/Programming/SQL/Analytics_Functions/Conditional/SQL_Iif_if.htm",a:"The seq_iif() and seq_if() functions return a sequence of values that represent the result of an If-Then-Else condition. When the boolean value in sequence 1 is true, an element from sequence 2 is selected; when false from sequence 3. However, the positions in sequence 2 and 3 are advanced ...",t:"SQL Sequence Iff and If Functions"},"1860":{i:0.000167366073105312,u:"../Content/Programming/SQL/Analytics_Functions/Conditional/SQL_Filter.htm",a:"The seq_filter() function has as first argument a boolean type, and the return sequence is of the type of the second argument. The result sequence contains only those elements of sequence 2 for which the corresponding element of sequence 1 is true. The seq_filter_pos() function returns the positions ...",t:"SQL Sequence Filter Function"},"1861":{i:0.000149775790901452,u:"../Content/Programming/SQL/Analytics_Functions/Manipulator_Functions.htm",a:"The following sequence manipulator functions take a variety of input sequence or scalar arguments and produce result sequences or scalar types as described in the table below: Example Following is an example code snippet demonstrating sequence manipulator methods:      \n    -- seq_repeat, ...",t:"Sequence Manipulator SQL Functions"},"1862":{i:0.000134022979936083,u:"../Content/Programming/SQL/Analytics_Functions/Manipulator/SQL_Repeat.htm",a:"The seq_repeat() function returns a result sequence containing repeating values from the input sequence. Note that the second argument, a positive integer, specifies the number of times to repeat the values specified in the sequence argument. Following is an example script demonstrating the ...",t:"SQL Sequence Repeat Function"},"1863":{i:0.000134022979936083,u:"../Content/Programming/SQL/Analytics_Functions/Manipulator/SQL_Reverse.htm",a:"The seq_reverse() function returns a result sequence with the input sequence elements in reverse order. Following is an example script demonstrating the seq_reverse() function:  \n    INSERT INTO SimpleSequence(testNumber,iVal1)\n    VALUES(1,\u0027{-3,-2,-1,0,1,2,3}\u0027);\n     \n    SELECT iVal1, ...",t:"SQL Sequence Reverse Function"},"1864":{i:0.000134022979936083,u:"../Content/Programming/SQL/Analytics_Functions/Manipulator/SQL_Concat.htm",a:"The seq_concat() function returns a sequence that contains the elements of sequence 1 followed by the elements of sequence 2.  Following is an example script demonstrating the seq_concat() function:  \n    INSERT INTO SimpleSequence(testNumber,iVal1,iVal2)\n    VALUES(2,\u0027{1}\u0027,\u0027{2,3}\u0027);\n     \n    ...",t:"SQL Sequence Concatenation Function"},"1865":{i:0.000134022979936083,u:"../Content/Programming/SQL/Analytics_Functions/Manipulator/SQL_Subseq.htm",a:"The seq_subseq() function is used to extract a segment of the input sequence by specifying integer position arguments “from” and “to”.  Following is an example script demonstrating the seq_subseq() function:  \n    SELECT symbol, seq_subseq(seq_search(day, 20130101, 20131231),1,4) as \"2013_1-4\"\n    ...",t:"SQL Sequence Subseq Function"},"1866":{i:0.000134022979936083,u:"../Content/Programming/SQL/Analytics_Functions/Manipulator/SQL_Diff.htm",a:"The seq_diff() function returns a sequence of values representing the difference of element n minus element n-1.  Following is an example script demonstrating the seq_diff() function:  \n    INSERT INTO SimpleSequence(testNumber,iVal1)\n    VALUES(2,\u0027{4,9,2,9,1,4,9,7,5,3}\u0027);\n     \n    SELECT iVal1, ...",t:"SQL Sequence Diff Function"},"1867":{i:0.000134022979936083,u:"../Content/Programming/SQL/Analytics_Functions/Manipulator/SQL_Unique.htm",a:"The seq_unique() function removes repeating values from the result sequence but a value may appear more than once. For example, note that the value 4 in the result set above appears once at the beginning of the sequence where the input sequence has a repeated value, and then again at the second to ...",t:"SQL Sequence Unique Function"},"1868":{i:0.000134022979936083,u:"../Content/Programming/SQL/Analytics_Functions/Manipulator/SQL_Norm.htm",a:"The seq_norm()function takes a sequence argument of type double and calculates the normalized value of each element by dividing the element value by the square root of the sum of squares of all elements. Following is an example script demonstrating the seq_norm() function:  \n    INSERT INTO ...",t:"SQL Sequence Norm Function"},"1869":{i:0.000361481741758121,u:"../Content/Programming/SQL/Analytics_Functions/Manipulator/SQL_Trend.htm",a:"The seq_trend()function compares pairs of element values to determine if the values are trending up or down. For a sequence of values V: if Vn-1 \u003c  Vn then the result sequence element n will be 1 to indicate a positive trend; if Vn-1 \u003e Vn then the result sequence element n will be -1 to indicate a ...",t:"SQL Sequence Trend Function"},"1870":{i:0.000134022979936083,u:"../Content/Programming/SQL/Analytics_Functions/Manipulator/SQL_Ceil_Floor.htm",a:"The seq_ceil() and seq_floor() functions take sequence arguments of type double and return a sequence of type double containing the values of the nearest integer below or above the input element value. Following is an example script demonstrating the seq_ceil()and seq_floor() functions:  \n    INSERT ...",t:"SQL Sequence Ceil, Floor Functions"},"1871":{i:0.000134022979936083,u:"../Content/Programming/SQL/Analytics_Functions/Manipulator/SQL_Stretch.htm",a:"The seq_stretch() function is often used when calculating “split” adjusted prices, seq_stretch() “stretches” a sequence by copying elements from a third sequence dVal3 into the result sequence based on a comparison of the values of the two input time series ts1 and ts2. It repeats elements of dVal3 ...",t:"SQL Sequence Stretch Function"},});