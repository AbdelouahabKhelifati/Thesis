define({"205":{i:0.00045213438241219,u:"../Content/Users_Guides/Core/Indexes_Cursors/Hash_Autoid.htm",a:"As explained in the  Indexes  page, the eXtremeDB hash indexes are more efficient for exact match searches than tree indexes within in-memory databases. eXtremeDB provides hash index algorithms modified for efficient operations in memory when the associated class is transient. Hash indexes will ...",t:"Hash and Autoid Indexes"},"206":{i:0.000176943445890322,u:"../Content/Users_Guides/Core/Indexes_Cursors/List.htm",a:"As explained in the  Indexes  page, the eXtremeDB list index can be declared to allow applications to iterate over the objects of a class without regard to any particular order. If no other index is defined for a given class, then a list index will be created implicitly. As with  autoid indexes the ...",t:"List Indexes"},"207":{i:0.000626362031847917,u:"../Content/Users_Guides/Core/Indexes_Cursors/Inclusive_Covering_Indexes.htm",a:"The eXtremeDB in-memory database implementation was originally created when RAM memory was predominately a random access device; i.e. accessing any place in memory takes the same amount of time and CPU cycles. This model was accurate until recent years for embedded devices as well as for server-type ...",t:"Key-Value-Inclusive and Covering Indexes"},"208":{i:0.00117094416055753,u:"../Content/Users_Guides/Core/Indexes_Cursors/Indexes_Cursors_C.htm",a:"As explained in the  Indexes and Cursors  page, eXtremeDB  supports a variety of index types. The following sections give  C API implementation details for managing each of these index types:  B-Tree ,  Patricia ,  R-Tree ,  KD-Tree ,  Hash ,  OID ,  Autoid ,  User-defined . An eXtremeDB class can ...",t:"Indexes and Cursors in C"},"209":{i:0.000613097466377303,u:"../Content/Users_Guides/Core/Persistent_Databases/Persistent_Indexes_Cursors_C.htm",a:"Cursor read-ahead buffering Navigating index structures can require accessing many pages of index “leaf” nodes. For example an application performing a sequential traversal of a disk-based B-Tree index will perform a blocking read access for each index page. This can have a significant performance ...",t:"Persistent Database Index Optimization in C"},"210":{i:0.000181439355017993,u:"../Content/Users_Guides/Core/Indexes_Cursors/Indexes_Cursors_Cpp.htm",a:"Indexes and Cursors in C++ C++ applications use the standard  C APIs to manage indexes and cursors. (Please refer to the  C API Indexes and Cursors  page for details.)",t:"Indexes and Cursors in C++"},"211":{i:0.00020038299357443,u:"../Content/Users_Guides/Core/Indexes_Cursors/Indexes_Cursors_Java.htm",a:"As explained in the  Indexes and Cursors  page, eXtremeDB , supports a variety of index types. The following sections give implementation details for Java APIs used to manage each of these index types. B-Tree Indexes As explained in the  B-Tree Indexes  page, BTree indexes can be used for ordered ...",t:"Indexes and Cursors in Java"},"212":{i:0.000197367251760772,u:"../Content/Users_Guides/Core/Indexes_Cursors/Indexes_Cursors_Csharp.htm",a:"As explained in the  Indexes and Cursors  page, eXtremeDB  supports a variety of index types. The following sections give implementation details for C# APIs used to manage each of these index types. B-Tree Indexes As explained in the  B-Tree Indexes  page, BTree indexes can be used for ordered ...",t:"Indexes and Cursors in C#"},"213":{i:0.00020358426476607,u:"../Content/Users_Guides/Core/Searches.htm",a:" Searches for objects in a database are performed using indexes. As explained in the  Indexes  page, eXtremeDB provides a number of specialized types of index. Lookups Hash indexes (including  autoid) and unique BTree indexes allow applications to perform quick find or lookup operations specifying a ...",t:"Index Search and Pattern Search"},"214":{i:0.000131175163960988,u:"../Content/Users_Guides/Core/Indexes_Cursors/Search_Algorithm.htm",a:"The index search algorithm operates with key weights, not with key values, regardless of whether the index direction is ascending or descending.  The search operations and their rules require some explanation. To demonstrate how key searches produce their result sets, consider a simple key ...",t:"eXtremeDB B-Tree Search Algorithm"},"215":{i:0.000348019332269996,u:"../Content/Users_Guides/Core/Indexes_Cursors/Searches_C.htm",a:"Search interfaces locate desired objects or groups of objects by unique identifier or by index.  Exact match lookups by unique identifier (including unique hash, oid and  autoid ) using the _find() functions are extremely efficient for locating individual objects. eXtremeDB also offers a rich set of ...",t:"Index Searches in C"},"216":{i:0.000160738025561991,u:"../Content/Users_Guides/Core/Indexes_Cursors/Searches_Cpp.htm",a:"Index Searches in C++ Search operations in C++ are performed using  the C API functions. Please refer to the  C API Seaches  page.",t:"Index Searches in C++"},"217":{i:0.000204013999298204,u:"../Content/Users_Guides/Core/Indexes_Cursors/Searches_Java.htm",a:"Search interfaces locate desired objects or groups of objects by unique identifier or by index.  Exact match lookups by unique identifier (including  HashTable  and  autoid  ) using the Cursor method find() are extremely efficient for locating individual objects. eXtremeDB also offers a rich set of ...",t:"Index Searches in Java"},"218":{i:0.000129682865990358,u:"../Content/Users_Guides/Core/Indexes_Cursors/Searches_Python.htm",a:"Search operations in Python are performed using  the  Cursor methods  find() or  search(). The  find()  method locates an object in the database. It returns an object instance or None if not found. The  search()  method locates an object in the cursor or None if not found. Then the  Cursor ...",t:"Index Searches in Python"},"219":{i:0.000200632058323602,u:"../Content/Users_Guides/Core/Indexes_Cursors/Searches_Csharp.htm",a:"Search interfaces locate desired objects or groups of objects by unique identifier or by index.  Exact match lookups by Unique identifier (including  HashTable  and  AutoID  ) using the Cursor method Find() are extremely efficient for locating individual objects. eXtremeDB also offers a rich set of ...",t:"Index Searches in C#"},"220":{i:0.000312818565475189,u:"../Content/Users_Guides/Core/Events_TTL.htm",a:"eXtremeDB provides  the ability to manage database events with application callback procedures, and the possibility of setting time-to-live thresholds to cause automatic deletion of obsolete database objects. Please use the links below to view detailed explanations and examples  for your development ...",t:"Using eXtremeDB Database Events and Time-To-Live Features"},"221":{i:0.000331359893846028,u:"../Content/Users_Guides/Core/Events_TTL/Events_TTL_C.htm",a:"As explained in the  introduction  page, eXtremeDB provides the capability to automatically delete obsolete database objects through the Time-To-Live feature, and to manage database object new, delete, update and checkpoint events. The C APIs for these features are explained in the sections below. ...",t:"Using eXtremeDB Events and Time-To-Live Features in C"},"222":{i:0.000179307940126275,u:"../Content/Users_Guides/Core/Events_TTL/Events_TTL_Cpp.htm",a:"Using eXtremeDB Database Events and Time-To-Live Features in C++ C++ applications use the standard  C APIs to manage the database events and Time-To-Live features. (Please refer to the  C API Events and TTL  page for details.)",t:"Using eXtremeDB Database Events and Time-To-Live Features in C++"},"223":{i:0.000241422735062593,u:"../Content/Users_Guides/Core/Events_TTL/Events_TTL_Java.htm",a:"As explained in the introduction  page , eXtremeDB provides  the capability to automatically delete obsolete database objects through the Time-To-Live feature, and to manage database object new, delete, update and checkpoint events. The Java APIs for these features are explained in the sections ...",t:"Using eXtremeDB Database Events and Time-To-Live Features in Java"},"224":{i:0.000182862245148623,u:"../Content/Users_Guides/Core/Events_TTL/Events_TTL_Python.htm",a:"Using eXtremeDB Database Events and Time-To-Live Features in Python As explained in the introduction  page , eXtremeDB provides  the capability to automatically delete obsolete database objects through the Time-To-Live feature, and to manage database object new, delete, update and checkpoint events. ...",t:"Using eXtremeDB Database Event and Time-To-Live Features in Python"},"225":{i:0.000182117537257634,u:"../Content/Users_Guides/Core/Events_TTL/Events_TTL_Csharp.htm",a:"As explained in the introduction  page , eXtremeDB provides  the capability to automatically delete obsolete database objects through the Time-To-Live feature, and to manage database object new, delete, update and checkpoint events.  The C# APIs for these features are explained in the sections ...",t:"Using eXtremeDB Database Events and Time-To-Live Features in C#"},"226":{i:0.00205520158242491,u:"../Content/Users_Guides/Core/Concurrency_Transaction_Managers.htm",a:"As explained in the  Fundamental Concepts , eXtremeDB manages multi-thread and multi-process contention for database data through the use of  transaction blocking ; and provides  three different  transaction managers  that handle concurrent access to data according to either optimistic or ...",t:"Concurrency Control and eXtremeDB Transaction Managers"},"227":{i:0.00104552273678148,u:"../Content/Users_Guides/Core/Transaction_Control.htm",a:"A transaction is a unit of work with the database (a single logical operation on the data). eXtremeDB transactions enforce the ACID properties.  The ACID model is one of the oldest and most important concepts of database theory.  It establishes four goals that a database management system must ...",t:"Transaction Control in eXtremeDB"},"228":{i:0.00450557788319276,u:"../Content/Users_Guides/Core/Isolation_Levels.htm",a:"Transaction isolation defines how and when the changes made by one transaction become visible to other concurrent transactions.  DBMSs usually offer a number of transaction isolation levels that define the degree to which one transaction must be isolated from data modifications made by other ...",t:"Transaction Isolation Levels"},"229":{i:0.00335341219334008,u:"../Content/Users_Guides/Core/Transaction_Priorities_Scheduling.htm",a:"With  MURSIW, eXtremeDB  supports transaction priorities; i.e. it is possible to assign a priority value to each transaction at runtime.  At the time a transaction is registered with the runtime, the transaction scheduler checks the priority value and shifts the transaction forward or backwards in ...",t:"Transaction Priorities and Scheduling"},"230":{i:0.00541809703121076,u:"../Content/Users_Guides/Core/Transaction_Managers.htm",a:"Choosing the eXtreme DB Transaction Manager The choice of Transaction Manager can be important for multi-task and/or mutli-process applications, or multi-user environments where more than one thread or process may be updating database tables.  In single-user/single-threaded applications, where only ...",t:"Choosing the eXtremeDB Transaction Manager"},"231":{i:0.00815230285405316,u:"../Content/Users_Guides/Core/MURSIW_Transaction_Manager.htm",a:"The eXtreme DB MURSIW Transaction Manager As explained in the  Fundamental Concepts page , MURSIW is a traditional, lock-based transaction manager implemented as a simple queue.  And it is important to note that when MURSIW is used the only possible  Isolation level  is MCO_SERIALIZABLE. The ...",t:"The eXtremeDB MURSIW Transaction Manager"},"232":{i:0.00613215030496832,u:"../Content/Users_Guides/Core/MVCC_Transaction_Manager.htm",a:"The eXtreme DB MVCC Transaction Manager The Multi-Versioning Concurrency Control (MVCC) transaction manager enhances applications’ database concurrency management options.  With the MVCC model, while querying a database each transaction sees a snapshot of committed data, regardless of any ...",t:"The eXtremeDB MVCC Transaction Manager"},"233":{i:0.00107875041661784,u:"../Content/Users_Guides/Core/Concurrency/Concurrency_C.htm",a:"As explained in the  Transaction  and  Concurrency  control pages, applications use  transaction blocking  for all database access. This allows the eXtremeDB transaction managers  to schedule and process all database operations, whether they involve simple READ_ONLY access or READ_WRITE operations ...",t:"Database Concurrency and Transaction Management in C"},"234":{i:0.000320235011601989,u:"../Content/Users_Guides/Core/Concurrency/Concurrency_Cpp.htm",a:"Database Concurrency and Transaction Management in C++ C++ applications use the standard  C APIs to manage transactions and concurrency. (Please refer to the  C API Concurrency and Transaction Management  page for details.)",t:"Database Concurrency and Transaction Management in C++"},"235":{i:0.000348069177764635,u:"../Content/Users_Guides/Core/Concurrency/Concurrency_Java.htm",a:"As explained in the  Transaction  and  Concurrency  control pages, applications use  transaction blocking  for all database access. This allows the eXtremeDB transaction managers to schedule and process all database operations, whether they involve simple ReadOnly access or ReadWrite operations that ...",t:"Database Concurrency and Transaction Management in Java"},"236":{i:0.000347671764142018,u:"../Content/Users_Guides/Core/Concurrency/Concurrency_Csharp.htm",a:"As explained in the  Transaction  and  Concurrency  control pages, applications use  transaction blocking  for all database access. This allows the eXtremeDB transaction managers to schedule and process all database operations, whether they involve simple ReadOnly access or ReadWrite operations that ...",t:"Database Concurrency and Transaction Management in C#"},"237":{i:0.00115090513082679,u:"../Content/Users_Guides/Core/Database_Backup_Restore.htm",a:"As explained in the  Database Persistence  page, backup is a prudent way to preserve the database in case of hardware failure. The backup guarantees that it will be possible to restore the database to the state it had been at the time the last backup was completed eXtremeDB provides a number of ...",t:"Database Backup and Restore"},"238":{i:0.00028467896212641,u:"../Content/Users_Guides/Core/Database_Persistence.htm",a:"eXtremeDB provides a number of methods for assuring that in-memory database data can be preserved on persistent storage media. First of all, backup is a prudent way to preserve the database in case of hardware failure.  (See page  Database Backup and Restore  for further details.) The backup ...",t:"Database Persistence"},"239":{i:0.00272024383266645,u:"../Content/Users_Guides/Core/Database_Backup_Restore/Incremental_Backup.htm",a:"As explained in the  Database Backup and Restore  page, eXtremeDB provides incremental backup and restore APIs for both in-memory and persistent databases as well as a  file backup  capability for persistent databases. (Please see the  File Backup  page for further details.) An incremental backup ...",t:"Incremental Backup and Restore"},"240":{i:0.000741990604646008,u:"../Content/Users_Guides/Core/Database_Backup_Restore/Inc_Backup_Restore_C.htm",a:"Incremental online backup can be performed while normal database activity proceeds uninterrupted. While the  library level backup is the recommended method of implementation, the eXtremeDB  runtime exports  low level APIs to allow applications to provide custom backup implementation. For alternative ...",t:"Incremental Backup and Restore in C"},"241":{i:0.000895548744353066,u:"../Content/Users_Guides/Core/Database_Backup_Restore/Library_Backup_Implementation.htm",a:"The incremental backup process creates a backup file which stores database pages in blocks marked by a binary session header and footer structure (called a backup record). A single backup file can contain several independent backups, possibly of different types (full or incremental) or with ...",t:"Incremental Backup Implementation"},"242":{i:0.000575227931182324,u:"../Content/Users_Guides/Core/Database_Backup_Restore/Inc_Backup_Restore_Cpp.htm",a:" Incremental Backup and Restore in C++ Incremental online backup can be performed while normal database activity proceeds uninterrupted using the C++ McoSqlEngine methods described below. Alternatively, C++ applications can call the C API functions described in the  Incremental Backup and Restore in ...",t:" Database Backup and Restore in C++"},"243":{i:0.000507003500922152,u:"../Content/Users_Guides/Core/Database_Backup_Restore/Inc_Backup_Restore_SQL.htm",a:"Incremental backup and restore operations can be performed from any SQL client by executing the eXtremeSQL extensions  BACKUP  ,  VERIFY  and  RESTORE . (Also note that  file backup  can be performed for persistent databases by calling SQL function  file_backup().) BACKUP The BACKUP statement must ...",t:"Incremental Backup and Restore with SQL"},"244":{i:0.000538478548770904,u:"../Content/Users_Guides/Core/Database_Backup_Restore/Inc_Backup_Restore_xSQL.htm",a:" Incremental Backup and Restore with xSQL The following xSQL commands are provided to perform incremental backup and restore operations on in-memory and persistent databases. (Also note that  file backup  can be performed for persistent databases by calling SQL function  file_backup().) BACKUP  \n    ...",t:" Incremental Backup and Restore with xSQL"},"245":{i:0.000243194948203135,u:"../Content/Users_Guides/Core/Database_Backup_Restore/Inc_Backup_Restore_Python.htm",a:" Incremental Backup and Restore in Python Incremental online backup  can be performed while normal database activity proceeds uninterrupted using the  methods described below. Alternatively, there are APIs to save a database image or class data. (See the  Data Export and Import  page for further ...",t:" Incremental Backup and Restore in Python"},"246":{i:0.00244361936425651,u:"../Content/Users_Guides/Core/Database_Backup_Restore/File_Backup.htm",a:"eXtremeDB provides the capability for applications using persistent databases to create copies of the data and log files in a background thread while normal database operations proceed uninterrupted. It is the most efficient way of creating a backup of a disk database as it copies data at the file ...",t:"File Backup"},"247":{i:0.00036422056052895,u:"../Content/Users_Guides/Core/Data_Export_Import.htm",a:"In addition to the  backup/restore APIs , eXtremeDB provides a number of methods to save and load a database snapshot as well as to save the database metadata and dictionary.  There are also APIs to allow an application to export and import XML formatted data, or to save and load a database class in ...",t:"Data Export and Import Operations"},"248":{i:0.000303547402952676,u:"../Content/Users_Guides/Core/Data_Export_Import/Data_Export_Import_C.htm",a:"As explained in the  Data Export and Import  page, eXtremeDB provides a number of methods to export and import a database snapshot or class. These methods are described in the sections below. Note that, in addition to data export/import operations, eXtremeDB provides backup and restore capability ...",t:"Data Export and Import in C"},"249":{i:0.00130624246674771,u:"../Content/Programming/C/Core_Functions/Static/Auxiliary/Backup.htm",a:"Incremental Online Backup in C The library level backup  APIs are the recommended method of implementing incremental backup and restore. For an overview see page  Incremental Backup and Restore in C The following functions are used to manage backup and restore. ",t:"Incremental Online Backup in C"},"250":{i:0.000179487539560018,u:"../Content/Users_Guides/Core/Data_Export_Import/Data_Export_Import_C_XML.htm",a:" For C applications, the eXtremeDB schema compiler  option “–x” causes  mcocomp to generate interface functions to retrieve, create and replace (update) the contents of an object with the content of an XML string. Usage of the static and generated XML APIs are explained in the following sections. ...",t:"The  eXtremeDB XML C API "},"251":{i:0.000160527386283503,u:"../Content/Users_Guides/Core/Data_Export_Import/Data_Export_Import_Cpp.htm",a:"In addition to the  backup/restore APIs , C++ applications can use the standard  C APIs to create  database snapshots, to save and load class data, and to save the database schema and metadata. (Please refer to the  C API Data Export Import  page for details.) Also, note that from a C++ eXtremeSQL ...",t:"Data Export and Import in C++"},"252":{i:0.000163706246627959,u:"../Content/Users_Guides/Core/Data_Export_Import/Data_Export_Import_Java.htm",a:"Database backup The eXtremeDB database backup and restore functionality is implemented by the Connection class methods createBackup() and restoreBackup(). Please see SDK sample  incBackup  for implementation details. createBackup() The createBackup() method has two forms:      \n    public virtual ...",t:"Data Export and Import in Java"},"253":{i:0.000286027616394433,u:"../Content/Users_Guides/Core/Data_Export_Import/Data_Export_Import_Python.htm",a:"The following APIs save a database image snapshot or class data to the specified external file. Also APIs are provided to perform incremental online backup . (See the  Incremental Backup and Restore  page for further details.) Database snapshots To save an image of an in-memory database (transient ...",t:"Data Export and Import in Python"},"254":{i:0.000163336983414862,u:"../Content/Users_Guides/Core/Data_Export_Import/Data_Export_Import_Csharp.htm",a:"Database backup The eXtremeDB database backup and restore functionality is implemented by the Connection class methods CreateBackup() and RestoreBackup(). Please see SDK sample  IncBackup  for implementation details. CreateBackup() The CreateBackup() method has two forms:      \n    public virtual ...",t:"Data Export and Import in C#"},"255":{i:0.00138707604430659,u:"../Content/Users_Guides/Transaction_Logging.htm",a:"eXtremeDB Transaction Logging extends eXtremeDB with three important capabilities:  for eXtremeDB in-memory database recovery in the event of failure  for “Data Relay” to facilitate seamless, fine-grained data sharing between eXtremeDB applications and external systems for creating a persistent ...",t:"Transaction Logging"},"256":{i:0.000412533929922482,u:"../Content/Users_Guides/TL/TL_Introduction.htm",a:"As explained in the  eXtremeDB Transaction Logging User\u0027s Guide , Transaction logging is an industry standard term that normally refers to database log file processing.  eXtremeDB Transaction Logging is mainly used for a set of tasks only one of which is adding persistence to in-memory databases. ...",t:"Introduction to eXtremeDB Transaction Logging"},"257":{i:0.000156340667777078,u:"../Content/Getting_Started/Getting_Started_TL.htm",a:"As explained in the  eXtremeDB Transaction Logging User\u0027s Guide ,  Transaction Logging (TL) provides for recovery of an eXtremeDB in-memory database in the event of failure, “Data Relay” to external systems and for creating a persistent queue of events. The  TL Introduction  gives an overview of TL ...",t:"Getting Started with eXtremeDB Transaction Logging"},"258":{i:0.00222409489312127,u:"../Content/Users_Guides/TL/TL_Applications.htm",a:"C/C++ applications using eXtremeDB Transaction Logging must first initialize the TL subsystem by calling  mco_translog_init() before the database is opened via  mco_db_open_dev().  In java and C# applications, the Database constructor initializes the TL subsystem when the database is instantiated. ...",t:"eXtremeDB Transaction Logging Applications"},"259":{i:0.0003844810824296,u:"../Content/Users_Guides/TL/TL_Strategies_Implementation.htm",a:"A transaction log that is usable for restoring the main eXtremeDB database (which is often the primary purpose of Transaction Logging) may or may not be created. Data to potentially be passed to an external data store is read by the function   mco_translog_iterate() which calls in its turn a ...",t:"Data Relay and Persistent Event Queue Strategies and Implementation"},"260":{i:0.000372204183262021,u:"../Content/Users_Guides/TL/TL_HA_CL.htm",a:"In some cases it is desirable to enhance eXtremeDB High Availability (HA) and/or eXtremeDB Cluster applications. For example, you might want one node of a cluster, or an HA replica, to be responsible for replicating data asynchronously to an external system in the “cloud” using Data Relay. The ...",t:"eXtremeDB Transaction Logging with HA and Cluster"},"261":{i:0.000357438624053758,u:"../Content/Users_Guides/TL/TL_Dynamic_DDL.htm",a:"eXtremeSQL supports the SQL DDL operations to create, alter or drop tables and indexes. These operations obviously cause the database schema to be modified. Schema modifications are reflected in the log and are applied to the database transparently to the application. Dynamic DDL is also supported ...",t:"eXtremeDB Transaction Logging with Dynamic DDL"},"262":{i:0.00012163265184034,u:"../Content/Users_Guides/TL/TL_SDK_Samples.htm",a:"Transaction Logging SDK Samples  Please use the links below to view eXtremeDB Transaction Logging SDK samples  for your development environment:",t:"Transaction Logging SDK Samples"},"263":{i:0.00807327814655048,u:"../Content/Users_Guides/Core/Sequences.htm",a:"Sequences\n\n A sequence is an unbounded array of eXtremeDB-supported scalar data elements (i.e. [u]int[1234], time, date, float and double ). Sequences are dynamic; they don\u0027t require layout placement through the dictionary and can be created and removed at runtime. The database schema defines the ...",t:"Optimizing Data Access with Sequences"},"264":{i:0.00365577656454947,u:"../Content/Users_Guides/Core/Time_Series_and_Columnar_Data.htm",a:"The sequence data type  Some data lends itself to columnar storage, such as time series. eXtremeDB includes support for ordered data (time series) as well as a library of vector-based analytics functions and SQL extensions to support SQL-style operations over time series data.  eXtremeDB combines ...",t:"Time Series and Columnar Data"},"265":{i:0.00545763747139624,u:"../Content/Users_Guides/Core/Using_Sequences.htm",a:"A sequence is an unbounded array of eXtremeDB-supported scalar data elements. (Please see the  Sequences  page for further explanation of the sequence data type.)  Sequences can be inserted, iterated and updated using SQL or native language APIs. Please use the links below to view detailed ...",t:"Using Sequences"},"266":{i:0.000784356141108301,u:"../Content/Users_Guides/Core/Using_Sequences/Using_Sequences_C.htm",a:"As explained in the  User\u0027s Guide  page, a sequence is an unbounded array of eXtremeDB-supported scalar data elements. The  generated C API  classname_fieldname_*()  functions are used by C applications to manage database fields of type  sequence . As  sequences  are effectively vectors of values, ...",t:"Using Sequences in C"},"267":{i:0.000827752280986197,u:"../Content/Users_Guides/Core/Using_Sequences/Using_Sequences_Cpp.htm",a:"As explained in the  User\u0027s Guide  page, a sequence is an unbounded array of eXtremeDB-supported scalar data elements. The C++  Sequence class is used together with the generated C API classname_fieldname_*() functions in C++ applications to manage database fields of type  sequence . As  sequences  ...",t:"Using Sequences in C++"},"268":{i:0.000784356141108301,u:"../Content/Users_Guides/Core/Using_Sequences/Using_Sequences_Java.htm",a:"The Java Sequence class is used to manage database fields of type  sequence . As  sequences  are effectively vectors of values, they are accessed through iterators. Where the C type  mco_seq_iterator_h is used in C applications, the Java class Sequence serves the equivalent role in Java ...",t:"Using Sequences in Java"},"269":{i:0.000784356141108301,u:"../Content/Users_Guides/Core/Using_Sequences/Using_Sequences_Csharp.htm",a:"The C# Sequence class is used to manage database fields of type  sequence . As  sequences  are effectively vectors of values, they are accessed through iterators. Where the C type  mco_seq_iterator_h is used in C applications, the C# class Sequence serves the equivalent role in C# applications. The ...",t:"Using Sequences in C#"},"270":{i:0.000899068332323463,u:"../Content/Users_Guides/Core/Using_Sequences/Using_Sequences_Python.htm",a:"As explained in the  User\u0027s Guide  page, a sequence is an unbounded array of eXtremeDB-supported scalar data elements. The Python  SequenceIterator class is used to manage database fields of type  sequence . As  sequences  are effectively vectors of values, they are accessed through iterators. Where ...",t:"Using Sequences in Python"},"271":{i:0.0020877816121596,u:"../Content/Users_Guides/Core/Network_Communications.htm",a:" The eXtremeSQL, eXtremeDB High Availability, and eXtremeDB Cluster extension modules all use network channel implementations for remote connections to other eXtremeDB applications. (Please see the  Database Security web page for an illustration of eXtremeDB protection for network communications and ...",t:"Network Communications with eXtremeDB "},"272":{i:0.00146455982074887,u:"../Content/Users_Guides/Core/Network_Communications/Network_Communications_C.htm",a:"As explained in the  Network Communications  page, eXtremeDB release 7.1.1795 and later allow the IPv6 address protocol for specifying node addresses. The following section describes issues that can be important for developers porting applications that used network communications in prior versions ...",t:"Managing Network Communications in C"},"273":{i:0.00104538533314011,u:"../Content/Users_Guides/Core/Network_Communications/OpenSSL_Parameters.htm",a:"SSL Parameters The SSL parameters and the calls they are passed to are detailed in the following table. (Please refer to the  Secure Sockets Layer (SSL) Parameters  page for further details.) ",t:"SSL Parameters"},});