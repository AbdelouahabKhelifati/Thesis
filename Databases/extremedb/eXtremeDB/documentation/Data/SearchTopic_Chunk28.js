define({"1940":{i:0.000158079282323168,u:"../Content/Users_Guides/SQL/SQL_Cpp_API.htm",a:"eXtremeSQL is implemented as a compact set of C++ classes  in pre-built  libraries  that provide SQL access to eXtremeDB databases.  The usage of these classes is demonstrated in the  SQL C++ SDK Samples . For developers new to eXtremeSQL, we recommend the Quick Start  tutorial  to quickly learn the ...",t:"eXtremeSQL C++ API"},"1941":{i:0.000140828077520187,u:"../Content/Users_Guides/SQL/C++_API/SQL_Cpp_Runtime_Libraries.htm",a:"eXtreme SQL C++ Runtime Libraries The  /target/bin  directory under your eXtremeSQL installation root directory contains a number of binary libraries that can be statically linked to your C applications.  Each library is provided in two forms: Debug - used during development to aid in finding ...",t:"eXtremeSQL C++ Runtime Libraries"},"1942":{i:0.000497756828441278,u:"../Content/Programming/C++/SQL_Cpp_Samples.htm",a:"The C++ embedded SQL samples use the McoSqlEngine and related classes to encapsulate the native C functions demonstrated in the  C API embedded SQL samples . By default, all sample executables are built in the eXtremeDB/target/bin directory so, after building the sample(s), it is convenient to cd to ...",t:"C++ Embedded SQL Samples"},"1943":{i:0.000132481288116405,u:"../Content/Programming/C++/SDK_Samples/SQL_Samples/13-SqlAggregator.htm",a:"This sample demonstrates how to use an SqlAggregator to manage database shards in a local process. How to Run See instructions  here  on how to build this and other samples on your development platform. Once built, the sample can be run from the \\target\\bin directory:  \n    api_sql_13_aggregator\n    ...",t:"13-SqlAggregator"},"1944":{i:0.000176335784051649,u:"../Content/Users_Guides/SQL/C++_API/SQL_Cpp_App_Development.htm",a:"As explained in the  eXtremeSQL C API page, an embedded SQL  application, both in C and C++, will define its database schema using the eXtremeDB DDL  then compile the schema using  mcocomp . The applications will then use the  static C API functions  to start the eXtremeSQL  runtime and specify ...",t:"Embedded SQL Application Development in C++"},"1945":{i:0.000186099345888113,u:"../Content/Users_Guides/SQL/C++_API/McoSqlEngine.htm",a:"The principle class for most eXtremeSQL C++ applications is McoSqlEngine. (However, functionality for managing transactions and executing prepared statements, i.e. SQL statements that are created once and executed multiple times, is provided in the McoSqlSession class. Please refer to the  Managing ...",t:"The eXtremeSQL C++ Class McoSqlEngine"},"1946":{i:0.000129959656648945,u:"../Content/Users_Guides/SQL/C++_API/McoDistributedSqlEngine.htm",a:"The eXtremeSQL Distributed SQL Engine provides limited support for the database sharding architecture for eXtremeDB Cluster installations.  Why is it limited? Most full-blown distributed database engines (such as the one found in Oracle for example) normally create an execution plan based on the ...",t:"The eXtremeSQL C++ Class McoDistributedSqlEngine"},"1947":{i:0.000152557526200035,u:"../Content/Users_Guides/SQL/C++_API/Memory_Allocator.htm",a:"For class McoSqlEngine, the class StdAllocator is used for all memory allocation. Applications that need to replace the built-in malloc()/free()-based allocator can explicitly create an allocator. Such a custom allocator must instantiate an object of the StdAllocator class passing the custom ...",t:"The eXtremeSQL Memory Allocator in C++"},"1948":{i:0.000129959656648945,u:"../Content/Users_Guides/SQL/C++_API/Free_Memory_Threshold.htm",a:"When a transient database runs out of memory in the middle of an update  transaction, it is quite possible that the transaction won’t be able to be rolled back. The rollback requires memory to rebuild internal structures, rebalance trees, etc. The core runtime handles this scenario through allowing ...",t:"Managing the eXtremeSQL Free Memory Threshold in C++"},"1949":{i:0.000423603477913364,u:"../Content/Users_Guides/SQL/C++_API/Query_Result_Processing.htm",a:"The  QueryResult  class provides a convenient way to process SQL result set rows. The records() method returns a  Cursor object that provides method hasNext() to iterate over the result set rows and a number of methods for extracting the data or column information from these rows. For example the ...",t:"SQL Query Result Processing in C++"},"1950":{i:0.000129959656648945,u:"../Content/Users_Guides/SQL/C++_API/SqlAggregator.htm",a:"The SqlAggregator is a class that acts like a  distributed connection , but within a single process. In order to use the SqlAggregator the C++ application creates an array of SqlEngine objects to run as shards. Then it starts all of the  SqlEngine objects and passes the array to the SqlAggregator ...",t:"Using the eXtremeSQL SqlAggregator in C++"},"1951":{i:0.000304612125907951,u:"../Content/Users_Guides/SQL/C++_API/User_Defined_Functions.htm",a:"eXtremeSQL  supports User Defined Functions (UDF) that can optimize the performance of database operations. UDFs are written in C++ and compiled into dynamic load libraries which can then be loaded at runtime by C++ applications. For example, the following code snippet defines then registers a UDF ...",t:"Using eXtremeSQL User Defined Functions in C++"},"1952":{i:0.000129959656648945,u:"../Content/Users_Guides/SQL/C++_API/McoSqlOpenParameters.htm",a:"The sample  api_sql_02_open_initililize  demonstrates how to use the default open parameters and simple call engine.open()  for an in-memory database. To manage a Persistent or Hybrid database (containing both persistent and transient classes), or to manage a database with multiple memory segments, ...",t:"Using eXtremeSQL C++ Class McoSqlOpenParameters"},"1953":{i:0.000444135935479962,u:"../Content/Users_Guides/SQL/C++_API/Structures_Arrays_Strings.htm",a:"The following eXtremeSQL sample code snippets illustrate the use of the Field, Struct and Array classes to access elements of structures.  The sample code uses the following schema definition:      \n    declare database structuresdb;\n    struct aPoint \n    {\n        int4 x;\n        int4 y;\n    };\n   ...",t:"Using eXtremeSQL Structures, Arrays and Strings in C++"},"1954":{i:0.000129959656648945,u:"../Content/Users_Guides/SQL/C++_API/String_Math_Functions.htm",a:"String and math functions are often used to modify, convert or compute derived values in the result set returned from a SQL query or to assign values in a SQL insert or update.  The following table lists the eXtremeSQL built-in functions: The built-in functions can be called from normal SQL select ...",t:"Using eXtremeSQL String, Math and User-defined Functions"},"1955":{i:0.000129959656648945,u:"../Content/Users_Guides/SQL/C++_API/Aggregate_Functions.htm",a:"Aggregate functions are often used to perform operations on a column of a result set.  The standard aggregate functions supplied by eXtremeSQL are listed in the following table.  Note that all aggregate functions return the type of the value stored in that table column. The following code snippet ...",t:"Using eXtremeSQL  Aggregate functions in C++"},"1956":{i:0.000129959656648945,u:"../Content/Users_Guides/SQL/C++_API/Group_By.htm",a:"Standard Group By eXtremeSQL allows standard group by clauses like the following:      \n    -- show items in P with average quantity \u003e 320\n    SELECT DISTINCT SP.pid FROM SP GROUP BY SP.pid, SP.jid HAVING avg(SP.qty) \u003e 320;\n     \n    -- show items in S with links to P2\n    SELECT DISTINCT S.sname ...",t:"Using the eXtremeSQL  Group By Clause"},"1957":{i:0.000158079282323168,u:"../Content/Users_Guides/SQL/SQL_Java_API.htm",a:"eXtremeSQL is implemented as a compact set of Java classes in pre-built  libraries  that provide SQL access to eXtremeDB databases.  The usage of these classes is demonstrated in the  SQL Java SDK Samples . For developers new to eXtremeSQL, we recommend the Quick Start  tutorial  to quickly learn ...",t:"eXtremeSQL Java API"},"1958":{i:0.000155224646780073,u:"../Content/Users_Guides/SQL/Java_API/SQL_Java_Runtime_Libraries.htm",a:"eXtreme SQL Java Runtime Libraries The core eXtremeDB runtime functionality is encapsulated in the extremedb.jar archive  which is compiled together with the Java application. Then the following Database configuration values can be set to dynamically load the associated library when a Database is ...",t:"eXtremeSQL Java Runtime Libraries"},"1959":{i:0.000155224646780073,u:"../Content/Users_Guides/SQL/Java_API/SQL_Java_App_Development.htm",a:"As explained in the  Java application development   page, a Java application will define its database schema as native Java classes with the @Persistent annotation, then specify optional support libraries in the Database constructor call. Memory devices and database parameters are specified in the ...",t:"Embedded SQL Application Development in Java"},"1960":{i:0.000148020933302831,u:"../Content/Users_Guides/SQL/Java_API/Example.htm",a:"The following code snippet demonstrates the basic embedded eXtremeSQL Java application implementation:  \n    import com.mcobject.extremedb.*;\n    import java.io.Console;\n     \n    @Persistent // class will be stored in eXtremeDB database\n    class MyTable\n    {\n        int pk;\n        String value;\n ...",t:"eXtremeSQL Java Example"},"1961":{i:0.000148020933302831,u:"../Content/Users_Guides/SQL/Java_API/Misc_Java_Details.htm",a:"Free Memory Threshold An update operation on a transient database can run out of memory in the middle of a transaction, and in this case it is quite possible that the transaction won’t be able to be rolled back. To address this, the McoSqlEngine::setFreeMemoryThreshold() method is used in the C++ ...",t:"Miscellaneous Java Details"},"1962":{i:0.000148020933302831,u:"../Content/Users_Guides/SQL/Java_API/SqlAggregator.htm",a:"The SqlAggregator is a class that acts like a  distributed connection , but within a single process. In order to use the SqlAggregator the Java application creates an array of SqlLocalConnection objects to run as shards. Then it starts all of the  SqlLocalConnection objects and passes the array to ...",t:"Using the eXtremeSQL SqlAggregator in Java"},"1963":{i:0.000158079282323168,u:"../Content/Users_Guides/SQL/SQL_Csharp_API.htm",a:"eXtremeSQL is implemented as a compact set of C# classes in pre-built  libraries  that provide SQL access to eXtremeDB databases.  The usage of these classes is demonstrated in the  SQL C# SDK Samples . For developers new to eXtremeSQL, we recommend the Quick Start  tutorial  to quickly learn the ...",t:"eXtremeSQL C# API"},"1964":{i:0.000140828077520187,u:"../Content/Users_Guides/SQL/Csharp_API/SQL_Csharp_Runtime_Libraries.htm",a:"eXtreme SQL C# Runtime Libraries The core eXtremeDB and eXtremeSQL runtime functionality is encapsulated in the extremedb4net.dll library which is loaded dynamically at application startup. Then the following Database.Mode values can be set to dynamically load the associated library when a Database ...",t:"eXtremeSQL C# Runtime Libraries"},"1965":{i:0.000140828077520187,u:"../Content/Users_Guides/SQL/Csharp_API/SQL_Csharp_App_Development.htm",a:"As explained in the  C# application development   page, a C# application will define its database schema as native C# classes with the [Persistent] attribute, then specify optional support libraries in the Database constructor call. Memory devices and database parameters are specified in the ...",t:"Embedded SQL Application Development in C#"},"1966":{i:0.00016476892938214,u:"../Content/Users_Guides/SQL/Csharp_API/Example.htm",a:"The following code snippet demonstrates a basic embedded eXtremeSQL C# application implementation:  \n    public static void Main(String[] args)\n    {\n        Database db;\n        Database.Device[] devs;\n        Database.Parameters parameters = new Database.Parameters();\n        bool disk = false;\n   ...",t:"eXtremeSQL C# Example"},"1967":{i:0.00016476892938214,u:"../Content/Users_Guides/SQL/Csharp_API/Misc_Csharp_Details.htm",a:"Free Memory Threshold An update operation on a transient database can run out of memory in the middle of a transaction, and in this case it is quite possible that the transaction won’t be able to be rolled back. To address this, the McoSqlEngine::setFreeMemoryThreshold() method is used in the C++ ...",t:"Miscellaneous C# Details"},"1968":{i:0.00016476892938214,u:"../Content/Users_Guides/SQL/Csharp_API/SqlAggregator.htm",a:"The SqlAggregator is a class that acts like a  distributed connection , but within a single process. In order to use the SqlAggregator the C# application creates an array of SqlLocalConnection objects to run as shards. Then it starts all of the  SqlLocalConnection objects and passes the array to the ...",t:"Using the eXtremeSQL SqlAggregator in C#"},"1969":{i:0.000158079282323168,u:"../Content/Users_Guides/SQL/SQL_Python_API.htm",a:"eXtremeSQL is implemented as a compact set of Python classes in pre-built  libraries  that provide SQL access to eXtremeDB databases using the  Python DB API Specification . Developers are encouraged to view this website for general information on the Python Database classes and methods..  The usage ...",t:"eXtremeSQL Python API"},"1970":{i:0.00016642197842665,u:"../Content/Users_Guides/SQL/Python_API/SQL_Python_Runtime_Libraries.htm",a:"eXtreme SQL Python Runtime Libraries The Python wrapper supports a SQL engine and a SQL server that operate on eXtremeDB databases. No additional libraries need to be specified on the call to exdb.Init_runtime().The main parts of this SQL server interface are the SqlEngine and SqlServer classes. ...",t:"eXtremeSQL Python Runtime Libraries"},"1971":{i:0.00063194422607989,u:"../Content/Programming/Python/SDK_Samples/Python_SQL_Samples.htm",a:"Python SQL samples  Please use the links below to view the description and specific instructions for individual samples in the following sub-directories:",t:"Python SQL samples"},"1972":{i:0.000300684921046494,u:"../Content/Programming/Python/SDK_Samples/SQL/rsql.htm",a:"This sample demonstrates use of a remote connection and the DB interface. How to Run In a console window run:  \n    target\\bin\\ xsql -p 5001\n      Then in a second console window run:  \n    rsql\n  But it is more instructive to run one instance in your development environment debugger, stepping ...",t:"rsql"},"1973":{i:0.000516902968320822,u:"../Content/Programming/Python/SDK_Samples/SQL/sqlbasic.htm",a:"This sample demonstrates working with sequences using a financial tick database. It demonstrates a collection of ticks and several often used queries. How to Run In a console window run:  \n    sqlbasic\n      But it is more instructive to run one instance in your development environment debugger, ...",t:"sqlbasic"},"1974":{i:0.000300684921046494,u:"../Content/Programming/Python/SDK_Samples/SQL/sqlseq.htm",a:"sqlseq This sample demonstrates working with sequences using SQL. How to Run In a console window run:  \n    sqlseq\n      But it is more instructive to run one instance in your development environment debugger, stepping through the code.",t:"sqlseq"},"1975":{i:0.00016642197842665,u:"../Content/Users_Guides/SQL/Python_API/SQL_Python_App_Development.htm",a:"The eXtremeSQL Python wrapper supports a SQL engine and a SQL server that operate on eXtremeDB databases using the  Python DB API Specification . Developers are encouraged to view this website for general information on the Python Database classes and methods. Using the eXtremeSQL Python Wrapper ...",t:"SQL Application Development in Python"},"1976":{i:0.000156997449113421,u:"../Content/Users_Guides/SQL/Python_API/Cursors.htm",a:"As defined by the DB API specification, to perform queries an empty cursor is created and then the execute() method is called on the cursor to perform the SQL query. For example:  \n    \u003e\u003e\u003e cursor = conn.cursor()\n    \u003e\u003e\u003e cursor.execute(\"SELECT ikey, high, volume FROM Quote WHERE ikey = ?\", (5,))\n    ...",t:"eXtremeSQL Cursors in Python"},"1977":{i:0.000211254312245235,u:"../Content/Users_Guides/SQL/Python_API/Transactions.htm",a:"All eXtremeDB database access is performed within transactions to assure database integrity by enforcing the ACID principles (see the  eXtremeDB User Guide  for a detailed description of transaction processing). When using the eXtremeSQL API, transaction processing is implicit , i.e. transactions ...",t:"Managing eXtremeSQL Transactions in Python"},"1978":{i:0.000223721583378492,u:"../Content/Users_Guides/SQL/Python_API/Sequences.htm",a:"The eXtremeDB Python wrapper extends the SQL DB API specification by allowing operations with eXtremeDB sequences. A sequence may appear as a result of a SELECT statement, or, as a parameter in INSERT or UPDATE statements. For example, the following statement could be sent to the SQL engine:  \n    ...",t:"eXtremeSQL Sequences in Python"},"1979":{i:0.000156997449113421,u:"../Content/Users_Guides/SQL/Python_API/AsyncDistributedConnections.htm",a:"The  AsyncDistributedConnection class allows applications to execute multiple SQL statements asynchronously across multiple database shards. The method execute() accepts multiple SQL statements and arguments or parameters. An  AsyncDistributedConnection instance is created by calling the ...",t:"eXtremeSQL Asynchronous Distributed Connections in Python"},"1980":{i:0.000580091132113683,u:"../Content/Programming/ODBC/ODBC_Unix-Linux.htm",a:"Please use these links to view an  overview  of the eXtremeSQLODBC implementation and  installation steps . Below are presented the steps to configure the McObject ODBC driver fo connect to eXtremeSQL applications.  As explained in the ODBC installation guide, all of the ODBC Driver setup procedures ...",t:"eXtremeDB ODBC DSN configuration on Unix-Linux systems"},"1981":{i:0.000937805396640284,u:"../Content/Programming/ODBC/ODBC_DSN_Win.htm",a:"eXtremeDB ODBC DSN configuration on Windows systems Please use these links to view an  overview  of the eXtremeSQL ODBC implementation and  installation steps . Below are presented the steps to configure the McObject ODBC driver to connect to eXtremeSQL applications. The McObject ODBC Setup dialog ...",t:"Installing the McObject ODBC Driver on Windows 64 systems"},"1982":{i:0.00189106244923758,u:"../Content/Programming/JDBC/SDK_Samples/Simple_JDBC.htm",a:"This sample demonstrates inserting and updating database objects with JDBC. How to Run In a console window from directory samples/jdbc/SimpleJDBC run  \n    ../../../target/bin/xsql -i -c xsql.cfg\n      Then in a second console window run  \n    On Unix/Linux:\n            \n     \n    SimpleJDBC.sh\n    ...",t:"Simple JDBC"},"1983":{i:0.000178393246272093,u:"../Content/Programming/JDBC/SDK_Samples/JDBC_Batch.htm",a:"Batch processing allows grouping related SQL statements into a batch by calling addBatch(), and submitting them with a single call to executeBatch(). Sending several SQL statements with executeBatch() improves performance by reducing the amount of communication overhead. The clearBatch() method can ...",t:"JDBC Batch Processing"},"1984":{i:0.000445215015022735,u:"../Content/Users_Guides/Server/Feed_Handler/Using_Feed_Handler.htm",a:"Introduction In a general sense, feed handlers are a broad class of applications and frameworks that parse, process, aggregate, and/or store market data. Different kinds of market data feeds may supply different kinds of data, such as quote or trade data, orders and order books, yield curves, etc. ...",t:"Using the eXtremeDB Feed Handler"},"1985":{i:0.000221144292912914,u:"../Content/Users_Guides/Server/Feed_Handler/Feed_Handler_API_Overview.htm",a:"The eXtremeDB Feed Handler API Overview The Feed Handler Application Programming Interface allows the users to create their own extension modules that handle market data feeds not currently supported by the eXtremeDB Feed Handler. The modules are implemented as shared libraries on Linux and macOS, ...",t:"The eXtremeDB Feed Handler C API Overview"},"1986":{i:0.00012163265184034,u:"../Content/Appendix.htm",a:"Appendix Please use the links below to view the appendix of interest:",t:"Appendix"},"1987":{i:0.000768268996386519,u:"../Content/Appendix/VxWorks_653.htm",a:" Introduction A VxWorks 653 module is the system controlled by one RTOS, and that RTOS is the core OS of VxWorks 653. Within a module, VxWorks 653 supports complete separation between applications as well as between the applications and the module\u0027s core OS. As a result, applications can interact ...",t:"Appendix A: eXtremeDB for VxWorks 653"},"1988":{i:0.000531356126356722,u:"../Content/Appendix/Analytics_Function_Mappings.htm",a:"Appendix B: Mapping of the Corresponding Analytics APIs The following table links to analytics functions that are available in the indicated native language APIs:",t:"Appendix B: Mapping of the Corresponding Analytics APIs"},"1989":{i:0.000191840176538935,u:"../Content/Appendix/LUA_Support.htm",a:"Appendix C: Lua Reference Manual eXtremeSQL supports Lua for User-defined functions (stored procedures) and scripting. Please refer to page  Using Lua with eXtremeSQL  for implementation details and the  Lua 5.3.Reference Manual for details on the Lua language.",t:"Appendix C: Lua Reference Manual"},"1990":{i:0.00012163265184034,u:"../Content/Appendix/Publication_Date.htm",a:"Appendix D: McObject Web Site Documentation Publication Date The publication date of the current version of documentation on the McObject  Web site is November 4, 2019.",t:"Appendix D: McObject Web Site Documentation Publication Date"},"1991":{i:0.000275271702310485,u:"../Content/Appendix/Unsearchable_Words.htm",a:"The following common words can not be searched do to the number of times they appear in the content pages: a, about, after, against, all, also, among, an, and, are, as, at, be, became, because, been, between,  but, by, can, come, do, during, each, early, for, found, from, had, has, have, he, her, ...",t:"Appendix X: Unsearchable Words"},"1992":{i:0.00012163265184034,u:"../Content/Copyright_Notice.htm",a:"© 2001–2019 by McObject LLC. All rights reserved. No part of this document may be reproduced or transmitted in any form or by any means, electronic, mechanical, photocopying, recording, or otherwise, without prior written permission of McObject LLC. McObject® and eXtremeDB® are trademarks or ...",t:"Copyright Notice"},"1993":{i:0.000127376433061053,u:"../Content/Programming/Csharp/Classes/Analytics_Methods/WindowAgg_Methods.htm",a:"Like Grid Aggregate methods, the Java SequenceIterator Window Aggregate methods take an integer interval argument and produce a result sequence containing the calculated aggregate for each interval.  The difference in how Window Aggregate methods determine their sliding window interval is described ...",t:"Window Aggregate Java SequenceIterator Methods"},"1994":{i:0.000362479174267084,u:"../Content/Programming/Java/Classes/HA_Classes/MasterConnection/setQuorum.htm",a:"This method is called by the master to set the HA quorum at runtime. For an overview see page  HA Applications Prototype  \n    public void setQuorum(int quorum);\n  Arguments Description This function is called by the master  to set the HA quorum at runtime. Note that a value of quorum greater than 0 ...",t:"setQuorum"},"1995":{i:0.00054040072016256,u:"../Content/Programming/Python/Classes/IoT/IoTReplicator/Constructor.htm",a:"The Python IoTReplicator Constructor Create an IoTReplicator instance. For an overview see page  Python IoTReplicator Class Prototype  \n    IoTReplicator(con, comm, params)\n  Arguments Description This constructor creates an instance of IoTReplicator with the specified parameters. Returns",t:"The Python IoTReplicator Constructor"},"1996":{i:0.000411366341147304,u:"../Content/Users_Guides/SQL/SQL_Implementation_Details/Aggregating_UDF.htm",a:"The Sql Engine allows user-defined functions (UDF) to perform custom aggregation, i.e. functions used with the SQL group by operator. These user-defined functions can be used like SQL functions  sum(),  count(),  max() etc. (Please see page  eXtremeSQL User Defined Functions  for further details.) ...",t:"Aggregating User-Defined Functions"},"1997":{i:0.00012163265184034,u:"../Content/Appendix/lua-5.3.4/doc/readme.html",a:"Lua 5.3 readme",t:"readme"},"1998":{i:0.000127376433061053,u:"../Content/Programming/Csharp/Classes/Analytics_Methods/GrandAgg_Methods.htm",a:"The Grand Aggregate Java SequenceIterator methods produce a double result SequenceIterator the first element of which is the operation result. Example Following is an example code snippet demonstrating a grand aggregate function:          \n    Cursor\u003cQuote\u003e cursor = new Cursor\u003cQuote\u003e(con, ...",t:"Grand Aggregate Java SequenceIterator Methods"},"1999":{i:0.000127376433061053,u:"../Content/Programming/Csharp/Classes/Analytics_Methods/Unary_Operators.htm",a:"The unary SequenceIterator methods returna result sequence of the same type or, in the case of match(), takes a character string argument pattern and returns a Boolean SequenceIterator. Example Following is an example code snippet demonstrating unary operators :      \n    Cursor\u003cQuote\u003e cursor = new ...",t:"Unary Java SequenceIterator Methods"},"2000":{i:0.00106703034507972,u:"../Content/Programming/Common/Analytics/Materialized.htm",a:"The term materialized is used to indicate a sequence that results from a database query. Sequences that are the result of operations on other sequences are typically non-materialized. Some analytics operations such as append and search can only be performed on materialized sequences. The following ...",t:"Materialized and Non-Materialized Sequences"},"2001":{i:0.00012163265184034,u:"../Content/Index.htm",a:"The following proxy can be used to generate a list of all index entries in your project. Optional Tasks: You can select whether alphabetized headings should be automatically included at the top of each index section in the output. You can also select a style to affect the look of the entire index. ...",t:"Index"},"2002":{i:0.00012163265184034,u:"../Content/Programming/Csharp/Classes/Aggregator.htm",a:"The Java  Aggregator  Class  Aggregator  is used to perform aggregation. Grouping and aggregation is done using two interfaces Aggregate and GroupBy. There are some predefined implementations for standard aggregates: max, min, sum, avg, count, etc. And it is possible to define user-defined ...",t:"The Java Aggregator Class "},"2003":{i:0.00054040072016256,u:"../Content/Programming/Python/Classes/IoT/IoTReplicator/connect.htm",a:"IoTReplicator.connect() Create a connection with an IoTCommunicator. For an overview see page  Python IoTReplicator Class Prototype  \n    connect(address, timeout, sock_params)\n  Arguments Description This method initiates the IoTConnection with an IoTCommunicator object. Returns",t:"IoTReplicator.connect()"},"2004":{i:0.000194101348468718,u:"../Content/Programming/C++/Classes/Database.htm",a:"The class Database should not be instantiated directly but is instead instantiated though one of its related classes; typically via the  McoSqlEngine consturctor. For an overview see page  C++ Classes The only Database method of interest is beginTransaction() which is typically called through an  ...",t:"The C++ Database Class"},"2005":{i:0.00147797660906667,u:"../Content/Programming/Python/Classes/IoT/IoTReplicator.htm",a:"The Python IoTReplicator Class The IoTReplicator object manages the replication process interfacing with the IoTCommunicator on one side and with the database on the other.",t:"The Python IoTReplicator Class"},"2006":{i:0.00109530770161275,u:"../Content/Appendix/lua-5.3.4/doc/contents.html",a:"Lua 5.3 Reference Manual - contents",t:"contents"},"2007":{i:0.000278454293466484,u:"../Content/Programming/Common/Analytics/Win_Agg_EMA.htm",a:"The Exponential Moving Average (EMA) is calculated using the following iterative algorithm, where n is the “number of days” for the moving average (starting with 1):  \n    p = 2 / (interval+1)\n    EMA[0] = input[0] * p\n    EMA[n] = EMA[n-1] * (1–p)\n      For example, applying the EMA calculation to ...",t:"Window Aggregate EMA"},"2008":{i:0.00012163265184034,u:"../Content/Resources/Templates/SDKSampleTopic.htm",a:"Sample Name Brief How to Run Text Pertinent code  \n    Code\n ",t:"Sample Name"},"2009":{i:0.00012163265184034,u:"../Content/Programming/Java/Classes/Embedded_Classes/Embedded_Statistic_Classes.htm",a:"The Java Embedded Statistic Classes For an overview see page  Statistic Class Please use the links below to view  the individual class definitions:",t:"The Java Embedded Statistic Classes"},"2010":{i:0.000136402374979318,u:"../Content/Programming/Java/Classes/Embedded_Classes/Embedded_Statistic_Classes/IndexStatMeta.htm",a:"The Java Embedded Statistic Class IndexStatMeta For an overview see page  Java Statistic Class Class Definition  \n    public static class IndexStatMeta extends IndexStat\n    {\n        public long DiskPagesCount;\n    };\n        Definitions:",t:"The Java Embedded Statistic Class IndexStatMeta"},"2011":{i:0.000127376433061053,u:"../Content/Programming/Csharp/Classes/Analytics_Methods/HashAgg_Methods.htm",a:"The Hash Aggregate Java SequenceIterator methods take various input arguments and return a GroupByResult result for the grouping values and groups for the group aggregates. The GroupByResult can then be converted to a SequenceIterator by calling its getIterator() method. When finished, the ...",t:"Hash Aggregate Java SequenceIterator Methods"},"2012":{i:0.00012163265184034,u:"../Content/Resources/Templates/FunctionTopic.htm",a:"Function Name Brief Prototype  \n    Code\n  Arguments Description Text Return Codes Example  \n    Code\n ",t:"Function Name"},});