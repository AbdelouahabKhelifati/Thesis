define({"274":{i:0.000421901270279328,u:"../Content/Users_Guides/Core/Network_Communications/Network_Communications_Cpp.htm",a:"Managing Network Communications in C++ For C++ database applications the APIs for managing  network communications are exactly as for C applications. Please see the  Managing Network Communications in C  page for details.",t:"Managing Network Communications in C++"},"275":{i:0.000692451155655264,u:"../Content/Users_Guides/Core/Network_Communications/Network_Communications_Java.htm",a:"As explained in the  Network Communications  page, eXtremeDB release 7.1.1795 and later allow the IPv6 address protocol for specifying node addresses. The following section describes issues that can be important for developers porting applications that used network communications in prior versions ...",t:"Managing Network Communications in Java"},"276":{i:0.000592622474556146,u:"../Content/Users_Guides/Core/Network_Communications/Network_Communications_Csharp.htm",a:"As explained in the  Network Communications  page, eXtremeDB release 7.1.1795 and later allow the IPv6 address protocol for specifying node addresses. The following section describes issues that can be important for developers porting applications that used network communications in prior versions ...",t:"Managing Network Communications in C#"},"277":{i:0.000741699621259719,u:"../Content/Users_Guides/Core/Network_Communications/Network_Communications_Python.htm",a:"As explained in the  Network Communications  page, eXtremeDB release 7.1.1795 and later allow the IPv6 address protocol for specifying node addresses. The following section describes issues that can be important for developers porting applications that used network communications in prior versions ...",t:"Managing Network Communications in Python"},"278":{i:0.000167315876236508,u:"../Content/Users_Guides/Core/Monitoring_Storage.htm",a:"Often it is useful for applications to know how much database memory is left or currently in use. eXtremeDB provides statistics APIs to check the amount of memory actually in use and the free memory available. Also a callback mechanism is provided for embedded applications that must react when used ...",t:"Monitoring Database Storage"},"279":{i:0.000387294806501234,u:"../Content/Users_Guides/Core/Monitoring_Storage/Monitoring_Storage_C.htm",a:"As mentioned in the Monitoring In-Memory Database Storage  page ,  eXtremeDB provides statistics APIs to check the amount of memory actually in use and the free memory available, and a callback mechanism  for embedded applications that must react when used memory space hits a threshold.  Also the ...",t:"Monitoring Database Storage in C"},"280":{i:0.000149831739732933,u:"../Content/Users_Guides/Core/Monitoring_Storage/Monitoring_Storage_Cpp.htm",a:"Monitoring Database Storage in C++ C++ applications use the standard  C APIs to monitor database storage. (Please refer to the  C API Monitoring Database Storage  page for details.)",t:"Monitoring Database Storage in C++"},"281":{i:0.000145335830605263,u:"../Content/Users_Guides/Core/Monitoring_Storage/Monitoring_Storage_xSQL.htm",a:"Sometimes it is useful to see the amount of database memory  space available in the database. xSQL provides the mem command for this purpose. It displays the amount of total and free storage in the database. The available storage is displayed in bytes (-b), Kilobytes (-k, default), Megabytes (-m), ...",t:"Monitoring Database Storage in xSQL"},"282":{i:0.00015301060007739,u:"../Content/Users_Guides/Core/Monitoring_Storage/Monitoring_Storage_Java.htm",a:"Java applications can obtain database page statistics directly from the Connection class properties FreePages, TotalPages and DbPageSize. Also, the Connection methods getClassStats() and getIndexStat() return the class and index statistics, and property IndexStatCount gives the number of indexes in ...",t:"Monitoring Database Storage in Java"},"283":{i:0.000153386044755281,u:"../Content/Users_Guides/Core/Monitoring_Storage/Monitoring_Storage_Python.htm",a:"Python applications can obtain database page statistics with the Connection class method getStats() which returns values for properties FreePages, TotalPages and DbPageSize. Also, the Connection methods getClassStats() and getIndexStat() return the class and index statistics. Persistent Databases ...",t:"Monitoring Database Storage in Python"},"284":{i:0.000152641336864292,u:"../Content/Users_Guides/Core/Monitoring_Storage/Monitoring_Storage_Csharp.htm",a:"C# applications can obtain database page statistics directly from the Connection class properties FreePages, TotalPages and DbPageSize. Also, the Connection methods GetClassStats() and GetIndexStat() return the class and index statistics, and property IndexStatCount gives the number of indexes in ...",t:"Monitoring Database Storage in C#"},"285":{i:0.00332829409091457,u:"../Content/Users_Guides/Core/Persistent_Databases/Persistent_Database_IO.htm",a:"To understand how persistent database read and write operations are performed it is important to first understand how caching works. Typically, persistent database applications are not performing I/O to the persistent media (hard disk, solid state disk, etc.) directly. The operations of reading and ...",t:"Persistent Database I/O"},"286":{i:0.0024897304941683,u:"../Content/Users_Guides/Core/Persistent_Databases/Persistent_Media_IO.htm",a:"As explained in the  Persistent Database I/O  page, there are two aspects of writing data to consider: performance and recovery in the case of system failure. To allow for recovery of the database in the case of a system failure, the eXtremeDB  runtime uses a log file in addition to the database ...",t:"Persistent Media I/O"},"287":{i:0.0010733761499536,u:"../Content/Users_Guides/Core/Persistent_Databases/Media_IO/Media_IO_C.htm",a:"The eXtremeDB  disk manager supports asynchronous I/O and different multi-file formats as described in the following sections.   Asynchronous file I/O By default, AIO is disabled. In order to use the asynchronous I/O mode, the application sets the MCO_DB_USE_AIO bit in the  db_params.mode_mask , for ...",t:"Persistent Media I/O in C"},"288":{i:0.000386170923452701,u:"../Content/Users_Guides/Core/Persistent_Databases/Media_IO/Media_IO_Cpp.htm",a:"Persistent Media I/O in C++ For C++ persistent database applications the APIs for AIO and multi-file support are exactly as for C applications. Please see the  C API Persistent Media I/O  page for details.",t:"Persistent Media I/O in C++"},"289":{i:0.000386170923452701,u:"../Content/Users_Guides/Core/Persistent_Databases/Media_IO/Media_IO_Java.htm",a:"The eXtremeDB  disk manager supports asynchronous I/O and different multi-file formats as described in the following sections.   Asynchronous file I/O By default, AIO is disabled. In order to use the asynchronous I/O mode, the application sets the DB_USE_AIO bit in the Database.Parameters.mode ...",t:"Persistent Media I/O in Java"},"290":{i:0.000386170923452701,u:"../Content/Users_Guides/Core/Persistent_Databases/Media_IO/Media_IO_Csharp.htm",a:"The eXtremeDB  disk manager supports asynchronous I/O and different multi-file formats as described in the following sections.   Asynchronous file I/O By default, AIO is disabled. In order to use the asynchronous I/O mode, the application sets the DB_USE_AIO bit in the Database.Parameters.Mode ...",t:"Persistent Media I/O in C#"},"291":{i:0.000386170923452701,u:"../Content/Users_Guides/Core/Persistent_Databases/Media_IO/Media_IO_Python.htm",a:"The eXtremeDB  disk manager supports asynchronous I/O  as described in the following section.   Asynchronous file I/O By default, AIO is disabled. In order to use the asynchronous I/O mode, the application specifies DbParamsModeMask.USE_AIO in the open_database() argument db_params_mode_mask. The ...",t:"Persistent Media I/O in Python"},"292":{i:0.00102895134472758,u:"../Content/Users_Guides/Core/Persistent_Databases/Cache_Management/Prioritized_Cache.htm",a:"As explained in the  Persistent Database I/O  page, for persistent databases I/O operations (reading from and writing to the persistent media) are the most “expensive” operations in performance terms. To minimize the effect of I/O, eXtremeDB  implements a Disk Manager (DM) Cache that interacts with ...",t:"eXtremeDB Prioritized Cache"},"293":{i:0.00146382943174894,u:"../Content/Users_Guides/Core/Persistent_Databases/Cache_Management/Cache_Management_C.htm",a:"As explained in the  Prioritized Cache  page, eXtremeDB  provides a number of C API functions to monitor and manage the runtime cache. These APIs and important information regarding their usage are described in the following sections. Cache Priorities Applications can influence how long certain ...",t:"Cache Management in C"},"294":{i:0.00123605498156357,u:"../Content/Users_Guides/Core/Persistent_Databases/Setting_Log_File_Type.htm",a:"As explained in the  Persistent Database I/O  page, database log file updates are performed automatically by the eXtremeDB  Disk Manager  whenever persistent data is written to the database. In the event of a hardware or software failure, the runtime can recover the database using this log. Log file ...",t:"Setting the Transaction Log File Type"},"295":{i:0.000427350892887336,u:"../Content/Users_Guides/Core/Persistent_Databases/Log_File_Type_Parameters/Log_File_Type_Parameters_C.htm",a:"As explained in the  persistent database recovery  page the eXtremeDB  runtime uses the transaction log file to perform recovery automatically in the case of a prior application crash. The  Persistent Database I/O  page explains the different log types and how to choose the appropriate type for ...",t:"Setting Log File Types and Parameters in C"},"296":{i:0.000231194445762144,u:"../Content/Users_Guides/Core/Persistent_Databases/Log_File_Type_Parameters/Log_File_Type_Parameters_Cpp.htm",a:"Setting Log File Types and Parameters in C++ For C++ persistent database applications the APIs for setting log file type and parameters are exactly as for C applications. Please see the  C API Setting Log File Type and Parameters  page for details.",t:"Setting Log File Types and Parameters in C++"},"297":{i:0.0002343733061066,u:"../Content/Users_Guides/Core/Persistent_Databases/Log_File_Type_Parameters/Log_File_Type_Parameters_Java.htm",a:"As explained in the  persistent database recovery  page the eXtremeDB  runtime uses the transaction log file to perform recovery automatically in the case of a prior application crash. The  Persistent Database I/O  page explains the different log types and how to choose the appropriate type for ...",t:"Setting Log File Types and Parameters in Java"},"298":{i:0.000234004042893503,u:"../Content/Users_Guides/Core/Persistent_Databases/Log_File_Type_Parameters/Log_File_Type_Parameters_Csharp.htm",a:"As explained in the  persistent database recovery  page the eXtremeDB  runtime uses the transaction log file to perform recovery automatically in the case of a prior application crash. The  Persistent Database I/O  page explains the different log types and how to choose the appropriate type for ...",t:"Setting Log File Types and Parameters in C#"},"299":{i:0.000234748750784491,u:"../Content/Users_Guides/Core/Persistent_Databases/Log_File_Type_Parameters/Log_File_Type_Parameters_Python.htm",a:"As explained in the  persistent database recovery  page the eXtremeDB  runtime uses the transaction log file to perform recovery automatically in the case of a prior application crash. The  Persistent Database I/O  page explains the different log types and how to choose the appropriate type for ...",t:"Setting Log File Types and Parameters in Python"},"300":{i:0.000408511411702059,u:"../Content/Users_Guides/Core/Error_Handling.htm",a:"Part of the normal application development process involves including code to manage error conditions that can occur during program execution. To facilitate error handling the eXtremeDB  runtime uses return codes to indicate the status of the runtime after execution of a function or method. The C  ...",t:"eXtremeDB Error Handling"},"301":{i:0.000515174504304997,u:"../Content/Users_Guides/Core/Error_Handling/Error_Handling_C.htm",a:"As explained in the  Error Handling  page, the C API runtime functions return three categories of return codes: Status, Error and Fatal Error. The actual values of these return codes are enumerated in mco.h.  Status codes are return codes that are less than or equal to 50 and have #define names that ...",t:"eXtremeDB Error Handling in C"},"302":{i:0.000212937655175147,u:"../Content/Users_Guides/Core/Error_Handling/Error_Handling_Cpp.htm",a:"eXtremeDB Error Handling in C++ C++ applications use the standard  C APIs to handle error conditions. (Please refer to the  C API Error Handling  page for details.)",t:"eXtremeDB Error Handling in C++"},"303":{i:0.000216116515519604,u:"../Content/Users_Guides/Core/Error_Handling/Error_Handling_Java.htm",a:"As explained in the  Error Handling  page, the Java class methods may return no value (void), a long value representing an object’s  autoid, or a boolean value representing success or failure. Normal handling of these return codes is straight forward. For example:  \n    if ...",t:"eXtremeDB Error Handling in Java"},"304":{i:0.000215747252306507,u:"../Content/Users_Guides/Core/Error_Handling/Error_Handling_Csharp.htm",a:"As explained in the  Error Handling  page, the C# class methods may return no value (void), a long value representing an object’s  autoid, or a boolean value representing success or failure. Normal handling of these return codes is straight forward. For example:  \n    if ...",t:"eXtremeDB Error Handling in C#"},"305":{i:0.00074129388784043,u:"../Content/Users_Guides/Core/Tracing_Framework.htm",a:"The eXtremeDB tracing framework allows applications to output trace and debugging information to a log file. This framework is a flexible mechanism for logging events mainly from internal operations of the eXtremeDB  runtime. Sometimes, to discover the source of a problem, developers need to know ...",t:"eXtremeDB Tracing Framework"},"306":{i:0.00164213271320473,u:"../Content/Programming/C/Core_Functions/Static/Auxiliary/Tracing_Framework_C.htm",a:"The eXtremeDB tracing framework allows applications to output trace and debugging information to a log file. All C/C++ applications should link with the mcotrace library. (Note that xSQL can also be configured to output trace information. Please refer to the  xSQL Tracing Framework  page for ...",t:"eXtremeDB Tracing Framework C API"},"307":{i:0.000611164687125978,u:"../Content/Programming/xSQL/Tracing_Framework_xSQL.htm",a:"As explained in the  Tracing Framework  page, eXtremeDB provides APIs that allow applications to output trace and debugging information to a log file. Please view the   C API Tracing Framework  page for details about the various tracing options. For xSQL these options are specified in the config ...",t:"xSQL Tracing Framework"},"308":{i:0.000248668349739519,u:"../Content/Users_Guides/Core/Recovery.htm",a:"Database recovery can be necessary in a number of situations. For example, consider a multi-process implementation: a bug in the application could cause the eXtremeDB  runtime to be corrupted in process A, in turn causing  mco_stop()  to be called, while it has the database “locked” (i.e. is ...",t:"Database Recovery from Failed Processes"},"309":{i:0.00091641211115262,u:"../Content/Users_Guides/Core/Recovery/Recovery_C.htm",a:"As explained in the  Database Recovery  page, eXtremeDB provides the “sniffer” utility to allow C and C++ applications to detect and remove “dead” connections. Using the Sniffer API Because there is no system-independent way to detect when a process has failed, the “sniffer” API  mco_db_sniffer()  ...",t:"Database Recovery from Failed Processes in C"},"310":{i:0.000320362221825244,u:"../Content/Users_Guides/Core/Persistent_Databases/Recovery/Persistent_Recovery_C.htm",a:"Persistent database recovery can be necessary in the case of a system failure. The eXtremeDB  runtime uses the transaction  log file  to perform recovery automatically when  mco_db_open_dev() is called.  Note that, for automatic recovery, it is important that either the RedoLog (the default) or ...",t:"Persistent Database Recovery from Failed Processes in C"},"311":{i:0.00012612856096801,u:"../Content/Users_Guides/Core/Recovery/Recovery_Cpp.htm",a:"Database Recovery from Failed Processes in C++ C++ in-memory database applications use the same \"sniffer\" utility as do C applications to detect and remove “dead” connections. Please see the  C API Database Recovery  page for details.",t:"Database Recovery from Failed Processes in C++"},"312":{i:0.000145118194063247,u:"../Content/Users_Guides/Core/Persistent_Databases/Recovery/Persistent_Recovery_Cpp.htm",a:"Persistent Database Recovery from Failed Processes in C++ For C++ persistent database applications the automatic database recovery is exactly as for C applications. Please see the  C API Persistent Database Recovery  page for details.",t:"Persistent Database Memory Device Specification in C++"},"313":{i:0.000184961970098787,u:"../Content/Users_Guides/Core/Persistent_Databases/Recovery/Persistent_Recovery_Java.htm",a:"Persistent database recovery can be necessary in the case of a system failure. The eXtremeDB  runtime uses the transaction  log file  to perform recovery automatically when Database method  open() is called.  Note that, for automatic recovery, it is important that either the RedoLog (the default) or ...",t:"Persistent Database Recovery from Failed Processes in Java"},"314":{i:0.000184899194741734,u:"../Content/Users_Guides/Core/Persistent_Databases/Recovery/Persistent_Recovery_Csharp.htm",a:"Persistent database recovery can be necessary in the case of a system failure. The eXtremeDB  runtime uses the transaction  log file  to perform recovery automatically when Database method  Open() is called.  Note that, for automatic recovery, it is important that either the RedoLog (the default) or ...",t:"Persistent Database Recovery from Failed Processes in C#"},"315":{i:0.000195002696953054,u:"../Content/Users_Guides/Core/Persistent_Databases/Recovery/Persistent_Recovery_Python.htm",a:"Persistent database recovery can be necessary in the case of a system failure. The eXtremeDB  runtime uses the transaction  log file  to perform recovery automatically when exdb method  open_database() is called.  Note that, for automatic recovery, it is important that either the RedoLog (the ...",t:"Persistent Database Recovery from Failed Processes in Python"},"316":{i:0.000398047310829109,u:"../Content/Users_Guides/Core/Database_Encryption.htm",a:"eXtremeDB provides the capability to encrypt in-memory and persistent databases with the standard  AES encryption algorithm  or by a custom encryption implementation. It is also possible to encrypt database snapshot and backup files. (Please see the  Database Security web page for  an illustration ...",t:"Database Encryption and CRC"},"317":{i:0.00170151870790771,u:"../Content/Users_Guides/Core/Encryption/Encryption_C.htm",a:"Database Encryption and CRC in C As explained in page  Database Encryption and CRC , eXtremeDB provides the capability to encrypt in-memory and persistent databases with standard   AES encryption  or by a  custom encryption implementation . Also it is possible to change the CRC algorithm from the ...",t:"Database Encryption in C"},"318":{i:0.00012612856096801,u:"../Content/Users_Guides/Core/Encryption/Encryption_Cpp.htm",a:"Database Encryption in C++ C++ in-memory database applications use the same APIs as do C applications to protect the database memory. Please see the  C API Database Encryption  page for details.",t:"Database Encryption in C++"},"319":{i:0.000303989300803868,u:"../Content/Users_Guides/Extension_Modules.htm",a:"eXtremeDB Extension Modules As explained in the  product family  descriptions, eXtremeDB offers the following extension modules for specialized database management features. Please use the links below to view detailed descriptions of the individual modules:",t:"eXtremeDB Extension Modules"},"320":{i:0.000736262188169576,u:"../Content/Users_Guides/Core/Compression.htm",a:"For large databases it can be important to conserve memory and/or disk space by using data compression techniques. As explained in the following sections, eXtremeDB provides this capability for in-memory and persistent databases.  It is also possible to compress the data sent in communications ...",t:"Data Compression"},"321":{i:0.000439663524765273,u:"../Content/Users_Guides/Core/RLE_Compression.htm",a:"Another form of optimization with  sequences is to use the implementation of RLE (Run Length Encoding) compression. Here instead of storing “raw” sequences, repeating values are stored with a value and repeat count. On sequences with many duplicate elements RLE exhibits better performance and ...",t:"RLE Compression"},"322":{i:0.00123276367539989,u:"../Content/Users_Guides/Core/Compression/Compression_C.htm",a:"Please refer to the  Data Compression  page for a discussion of the advantages of in-memory and persistent database compression.  In-Memory Database Compression In-memory database compression is enabled by setting the MCO_DB_INMEMORY_COMPRESSION flag in the   mco_db_params_t.mode_mask parameter ...",t:"Data Compression in C"},"323":{i:0.000195665022113964,u:"../Content/Users_Guides/Core/Compression/Compression_Cpp.htm",a:"Please refer to the  Data Compression  page for a discussion of the advantages of in-memory and persistent database compression.  In-Memory Database Compression For C++ in-memory database applications the APIs for managing data compression are exactly as for C applications. Please see the  C API ...",t:"Data Compression in C++"},"324":{i:0.000199219327136311,u:"../Content/Users_Guides/Core/Compression/Compression_Python.htm",a:"Please refer to the  Data Compression  page for a discussion of the advantages of in-memory and persistent database compression.  In-Memory Database Compression To enable compression for an in-memory database, specify the compressionLevel, compressionMask, and expectedCompressionRatio arguments in ...",t:"Data Compression in Python"},"325":{i:0.000191169112986293,u:"../Content/Users_Guides/Core/Compression/Compression_Java.htm",a:"Please refer to the  Data Compression  page for a discussion of the advantages of in-memory and persistent database compression.  In-Memory Database Compression For Java in-memory database applications the Database.Parameters for managing data compression are compressionLevel, compressionMask and ...",t:"Data Compression in Java"},"326":{i:0.000191169112986293,u:"../Content/Users_Guides/Core/Compression/Compression_Csharp.htm",a:"Please refer to the  Data Compression  page for a discussion of the advantages of in-memory and persistent database compression.  In-Memory Database Compression For C# in-memory database applications the Database.Parameters for managing data compression are CompressionLevel, CompressionMask and ...",t:"Data Compression in C#"},"327":{i:0.000137388441178233,u:"../Content/Users_Guides/Core/Database_Design.htm",a:"This section explains some database design considerations with respect to eXtremeDB.  It is not an exhaustive treatment of the topic of database design.  That is a very large subject and well beyond the scope of this document.  Rather, the objective here is to shed light on the workings of eXtremeDB ...",t:"Database Design Considerations"},"328":{i:0.000137388441178233,u:"../Content/Users_Guides/Core/Programming_Examples.htm",a:"The sample application code in the examples provided below demonstrates basic eXtremeDB operations: creating and connecting to a database, dictionary methods, and simple database writes and reads. Typically, eXtremeDB-based applications use the following scenarios to implement database access: Write ...",t:"Programming Examples"},"329":{i:0.00094241271974157,u:"../Content/Users_Guides/Core/Shared_Memory_Apps.htm",a:" eXtremeDB allows two or more processes in a multi-processing operating environment (for example, Linux and Windows platforms) to share a common database. Overview In order to share the data between multiple processes, the database must be created in shared memory.  Multiple threads within a process ...",t:"Shared Memory Applications"},"330":{i:0.00190698222670868,u:"../Content/Users_Guides/Core/Shared_Memory/Shared_Memory_C.htm",a:"As explained in the  Shared Memory Applications  page, eXtremeDB allows two or more processes to share a common database. General instructions are given there explaining how shared memory segments must be created on different operating systems. Further implementation details for C applications are ...",t:"Shared Memory Applications in C"},"331":{i:0.00028184531026608,u:"../Content/Users_Guides/Core/Shared_Memory/Shared_Memory_Cpp.htm",a:"Shared Memory Applications in C++ For C++ shared memory database applications the APIs for managing shared memory are exactly as for C applications. Please see the  C API Shared Memory Applications  page for details.",t:"Shared Memory Applications in C++"},"332":{i:0.00028184531026608,u:"../Content/Users_Guides/Core/Shared_Memory/Shared_Memory_Csharp.htm",a:"As explained in the  Shared Memory Applications  page, eXtremeDB allows two or more processes to share a common database. General instructions are given there explaining how shared memory segments must be created on different operating systems. Further implementation details for C# applications are ...",t:"Shared Memory Applications in C#"},"333":{i:0.000219647718953974,u:"../Content/Users_Guides/Core/UDA.htm",a:" The Uniform Database Access (UDA) API allows C and C++ applications to bypass the native, generated, API and use a pre-defined generic navigational API to access the database. How it Works The database dictionary generated by the  mcocomp schema compiler for all native API calls is coded into the ...",t:"Uniform Database Access"},"334":{i:0.000133301487174907,u:"../Content/Users_Guides/Core/UDA/Registry.htm",a:"UDA Registry Before using any of the registry functions, the application must allocate space for the meta-dictionary structure and initialize the allocated buffer with the  mco_metadict_init()  API.  Because an application may use more than one database, the meta-dictionary is necessary to contain a ...",t:"UDA Registry"},"335":{i:0.000133301487174907,u:"../Content/Users_Guides/Core/UDA/Fields_and_Indexes.htm",a:"UDA Fields and Indexes Fields in a database class are defined by the following descriptor:  \n    typedef struct tag_mco_dict_field_info_t_ \n    {\n        unsigned short     field_no;       /* field sequential number (from 0) */\n        char             * name;      /* DDL field name */\n        ...",t:"UDA Fields and Indexes"},"336":{i:0.000133301487174907,u:"../Content/Users_Guides/Core/UDA/UDA_Functions.htm",a:"UDA Functions As explained in the  introduction , the UDA is a generic API.  So the objects are defined by descriptors that can contain any type of object, and the values stored in them are defined by descriptors that can handle any type of data. Instances of database classes are defined by the ...",t:"UDA Functions"},"337":{i:0.000133301487174907,u:"../Content/Users_Guides/Core/UDA/Database_Control.htm",a:"Database Control After the meta-dictionary has been registered, a single database is opened with the UDA open API function:  \n    MCO_RET mco_uda_db_open( const mco_metadict_header_t * metadict,\n                unsigned short dict_no,\n                mco_uda_dict_class_storage_t ...",t:"UDA Database Control"},"338":{i:0.000133301487174907,u:"../Content/Users_Guides/Core/UDA/Object_Interfaces.htm",a:"UDA Object Interfaces To allocate a new database object call the following API function:  \n    MCO_RET mco_uda_new( mco_trans_h t,\n                unsigned short struct_no,\n                const void * oid,\n                const mco_uda_value_t * initializers,\n                unsigned short ...",t:"UDA Object Interfaces"},"339":{i:0.000133301487174907,u:"../Content/Users_Guides/Core/UDA/Vector_Functions.htm",a:"Vector Functions To get the size (length) of a vector or array:  \n    MCO_RET mco_uda_length( const mco_uda_object_handle_p obj,\n                    unsigned short field_no,\n                    /* out */ unsigned short * dimension );\n      For a vector, this function might return MCO_S_NULL_VALUE, ...",t:"UDA Vector Functions"},"340":{i:0.000133301487174907,u:"../Content/Users_Guides/Core/UDA/Cursor_Functions.htm",a:"Cursor Functions As explained in the  searches  section, a cursor is used to navigate through a group of records satisfying the search criteria on a specified index.  The function  mco_uda_lookup()  positions the cursor at the first object that satisfies the search criteria. To initialize a cursor ...",t:"UDA Cursor Functions"},"341":{i:0.000133301487174907,u:"../Content/Users_Guides/Core/UDA/User_Defined_Indexes.htm",a:"User Defined Indexes User-defined indexes for the eXtremeDB native API are explained in the  Indexes and Cursors  page.  As with native User-defined Functions (udf) the UDA API requires that the application supply two compare functions for tree indexes and two additional hash functions for hash ...",t:"UDA User Defined Indexes"},"342":{i:0.000133301487174907,u:"../Content/Users_Guides/Core/UDA/Collation.htm",a:"UDA Collation Implementation Collation support in the eXtremeDB core API is explained in section“Character String Collation” in the  Object Interfaces  page.   As with the core collation API, the user-defined collations are registered with the runtime before connecting to the database, then ...",t:"UDA Collation Implementation"},});